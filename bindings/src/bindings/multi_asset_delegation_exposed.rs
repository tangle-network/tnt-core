///Module containing a contract's types and functions.
/**

```solidity
library SlashingManager {
    struct SlashRecord { uint64 round; uint64 serviceId; uint64 blueprintId; uint256 totalSlashed; uint256 exchangeRateBefore; uint256 exchangeRateAfter; bytes32 evidence; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SlashingManager {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct SlashRecord { uint64 round; uint64 serviceId; uint64 blueprintId; uint256 totalSlashed; uint256 exchangeRateBefore; uint256 exchangeRateAfter; bytes32 evidence; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SlashRecord {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub totalSlashed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub exchangeRateBefore: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub exchangeRateAfter: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            u64,
            u64,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SlashRecord> for UnderlyingRustTuple<'_> {
            fn from(value: SlashRecord) -> Self {
                (
                    value.round,
                    value.serviceId,
                    value.blueprintId,
                    value.totalSlashed,
                    value.exchangeRateBefore,
                    value.exchangeRateAfter,
                    value.evidence,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SlashRecord {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    round: tuple.0,
                    serviceId: tuple.1,
                    blueprintId: tuple.2,
                    totalSlashed: tuple.3,
                    exchangeRateBefore: tuple.4,
                    exchangeRateAfter: tuple.5,
                    evidence: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SlashRecord {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SlashRecord {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalSlashed),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.exchangeRateBefore),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.exchangeRateAfter),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SlashRecord {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SlashRecord {
            const NAME: &'static str = "SlashRecord";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SlashRecord(uint64 round,uint64 serviceId,uint64 blueprintId,uint256 totalSlashed,uint256 exchangeRateBefore,uint256 exchangeRateAfter,bytes32 evidence)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.round)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.serviceId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blueprintId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.totalSlashed)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.exchangeRateBefore,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.exchangeRateAfter,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.evidence)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SlashRecord {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.round)
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.serviceId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blueprintId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalSlashed,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.exchangeRateBefore,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.exchangeRateAfter,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.evidence,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.round,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.serviceId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blueprintId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalSlashed,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.exchangeRateBefore,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.exchangeRateAfter,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.evidence,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SlashingManager`](self) contract instance.

See the [wrapper's documentation](`SlashingManagerInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> SlashingManagerInstance<P, N> {
        SlashingManagerInstance::<P, N>::new(address, __provider)
    }
    /**A [`SlashingManager`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SlashingManager`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SlashingManagerInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for SlashingManagerInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SlashingManagerInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SlashingManagerInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`SlashingManager`](self) contract instance.

See the [wrapper's documentation](`SlashingManagerInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> SlashingManagerInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SlashingManagerInstance<P, N> {
            SlashingManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SlashingManagerInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > SlashingManagerInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
///Module containing a contract's types and functions.
/**

```solidity
library Types {
    type AssetKind is uint8;
    type BlueprintSelectionMode is uint8;
    type LockMultiplier is uint8;
    type OperatorStatus is uint8;
    struct Asset { AssetKind kind; address token; }
    struct AssetConfig { bool enabled; uint256 minOperatorStake; uint256 minDelegation; uint256 depositCap; uint256 currentDeposits; uint16 rewardMultiplierBps; }
    struct AssetSecurityCommitment { Asset asset; uint16 exposureBps; }
    struct BondInfoDelegator { address operator; uint256 shares; Asset asset; BlueprintSelectionMode selectionMode; }
    struct BondLessRequest { address operator; Asset asset; uint256 shares; uint64 requestedRound; BlueprintSelectionMode selectionMode; uint256 slashFactorSnapshot; }
    struct Deposit { uint256 amount; uint256 delegatedAmount; }
    struct LockInfo { uint256 amount; LockMultiplier multiplier; uint64 expiryBlock; }
    struct OperatorMetadata { uint256 stake; uint32 delegationCount; OperatorStatus status; uint64 leavingRound; }
    struct OperatorRewardPool { uint256 accRewardPerShare; uint256 totalShares; uint256 totalAssets; uint64 lastUpdateRound; }
    struct OperatorSnapshot { uint256 stake; uint256 totalDelegated; }
    struct WithdrawRequest { Asset asset; uint256 amount; uint64 requestedRound; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Types {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssetKind(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<AssetKind> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl AssetKind {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for AssetKind {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<AssetKind> for u8 {
            fn from(value: AssetKind) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssetKind {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssetKind {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlueprintSelectionMode(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<BlueprintSelectionMode> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl BlueprintSelectionMode {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for BlueprintSelectionMode {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<BlueprintSelectionMode> for u8 {
            fn from(value: BlueprintSelectionMode) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BlueprintSelectionMode {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BlueprintSelectionMode {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LockMultiplier(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<LockMultiplier> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl LockMultiplier {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for LockMultiplier {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<LockMultiplier> for u8 {
            fn from(value: LockMultiplier) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for LockMultiplier {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for LockMultiplier {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<OperatorStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl OperatorStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for OperatorStatus {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<OperatorStatus> for u8 {
            fn from(value: OperatorStatus) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Asset { AssetKind kind; address token; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Asset {
        #[allow(missing_docs)]
        pub kind: <AssetKind as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (AssetKind, alloy::sol_types::sol_data::Address);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <AssetKind as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Asset> for UnderlyingRustTuple<'_> {
            fn from(value: Asset) -> Self {
                (value.kind, value.token)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Asset {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    kind: tuple.0,
                    token: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Asset {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Asset {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <AssetKind as alloy_sol_types::SolType>::tokenize(&self.kind),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Asset {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Asset {
            const NAME: &'static str = "Asset";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Asset(uint8 kind,address token)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <AssetKind as alloy_sol_types::SolType>::eip712_data_word(&self.kind)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.token,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Asset {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <AssetKind as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.kind,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.token,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <AssetKind as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.kind,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.token,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct AssetConfig { bool enabled; uint256 minOperatorStake; uint256 minDelegation; uint256 depositCap; uint256 currentDeposits; uint16 rewardMultiplierBps; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssetConfig {
        #[allow(missing_docs)]
        pub enabled: bool,
        #[allow(missing_docs)]
        pub minOperatorStake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub minDelegation: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub depositCap: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub currentDeposits: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub rewardMultiplierBps: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<16>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            bool,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            u16,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssetConfig> for UnderlyingRustTuple<'_> {
            fn from(value: AssetConfig) -> Self {
                (
                    value.enabled,
                    value.minOperatorStake,
                    value.minDelegation,
                    value.depositCap,
                    value.currentDeposits,
                    value.rewardMultiplierBps,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssetConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    enabled: tuple.0,
                    minOperatorStake: tuple.1,
                    minDelegation: tuple.2,
                    depositCap: tuple.3,
                    currentDeposits: tuple.4,
                    rewardMultiplierBps: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssetConfig {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssetConfig {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.enabled,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minOperatorStake),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minDelegation),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.depositCap),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentDeposits),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.rewardMultiplierBps),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssetConfig {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssetConfig {
            const NAME: &'static str = "AssetConfig";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssetConfig(bool enabled,uint256 minOperatorStake,uint256 minDelegation,uint256 depositCap,uint256 currentDeposits,uint16 rewardMultiplierBps)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.enabled,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.minOperatorStake,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.minDelegation)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.depositCap)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.currentDeposits,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rewardMultiplierBps,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssetConfig {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.enabled,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minOperatorStake,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minDelegation,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.depositCap,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.currentDeposits,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rewardMultiplierBps,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.enabled,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minOperatorStake,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minDelegation,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.depositCap,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.currentDeposits,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rewardMultiplierBps,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct AssetSecurityCommitment { Asset asset; uint16 exposureBps; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssetSecurityCommitment {
        #[allow(missing_docs)]
        pub asset: <Asset as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub exposureBps: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (Asset, alloy::sol_types::sol_data::Uint<16>);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <Asset as alloy::sol_types::SolType>::RustType,
            u16,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssetSecurityCommitment> for UnderlyingRustTuple<'_> {
            fn from(value: AssetSecurityCommitment) -> Self {
                (value.asset, value.exposureBps)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssetSecurityCommitment {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    asset: tuple.0,
                    exposureBps: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssetSecurityCommitment {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssetSecurityCommitment {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <Asset as alloy_sol_types::SolType>::tokenize(&self.asset),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.exposureBps),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssetSecurityCommitment {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssetSecurityCommitment {
            const NAME: &'static str = "AssetSecurityCommitment";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssetSecurityCommitment(Asset asset,uint16 exposureBps)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Asset as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Asset as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <Asset as alloy_sol_types::SolType>::eip712_data_word(&self.asset).0,
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.exposureBps)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssetSecurityCommitment {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <Asset as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.asset,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.exposureBps,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <Asset as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.asset,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.exposureBps,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct BondInfoDelegator { address operator; uint256 shares; Asset asset; BlueprintSelectionMode selectionMode; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BondInfoDelegator {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub shares: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub asset: <Asset as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub selectionMode: <BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            Asset,
            BlueprintSelectionMode,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            <Asset as alloy::sol_types::SolType>::RustType,
            <BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BondInfoDelegator> for UnderlyingRustTuple<'_> {
            fn from(value: BondInfoDelegator) -> Self {
                (value.operator, value.shares, value.asset, value.selectionMode)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BondInfoDelegator {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    shares: tuple.1,
                    asset: tuple.2,
                    selectionMode: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BondInfoDelegator {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BondInfoDelegator {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.shares),
                    <Asset as alloy_sol_types::SolType>::tokenize(&self.asset),
                    <BlueprintSelectionMode as alloy_sol_types::SolType>::tokenize(
                        &self.selectionMode,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BondInfoDelegator {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BondInfoDelegator {
            const NAME: &'static str = "BondInfoDelegator";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BondInfoDelegator(address operator,uint256 shares,Asset asset,uint8 selectionMode)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Asset as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Asset as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.operator,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.shares)
                        .0,
                    <Asset as alloy_sol_types::SolType>::eip712_data_word(&self.asset).0,
                    <BlueprintSelectionMode as alloy_sol_types::SolType>::eip712_data_word(
                            &self.selectionMode,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BondInfoDelegator {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operator,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.shares,
                    )
                    + <Asset as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.asset,
                    )
                    + <BlueprintSelectionMode as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.selectionMode,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operator,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.shares,
                    out,
                );
                <Asset as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.asset,
                    out,
                );
                <BlueprintSelectionMode as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.selectionMode,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct BondLessRequest { address operator; Asset asset; uint256 shares; uint64 requestedRound; BlueprintSelectionMode selectionMode; uint256 slashFactorSnapshot; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BondLessRequest {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub asset: <Asset as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub shares: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub requestedRound: u64,
        #[allow(missing_docs)]
        pub selectionMode: <BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub slashFactorSnapshot: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            Asset,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<64>,
            BlueprintSelectionMode,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            <Asset as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::primitives::aliases::U256,
            u64,
            <BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BondLessRequest> for UnderlyingRustTuple<'_> {
            fn from(value: BondLessRequest) -> Self {
                (
                    value.operator,
                    value.asset,
                    value.shares,
                    value.requestedRound,
                    value.selectionMode,
                    value.slashFactorSnapshot,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BondLessRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    asset: tuple.1,
                    shares: tuple.2,
                    requestedRound: tuple.3,
                    selectionMode: tuple.4,
                    slashFactorSnapshot: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BondLessRequest {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BondLessRequest {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <Asset as alloy_sol_types::SolType>::tokenize(&self.asset),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.shares),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestedRound),
                    <BlueprintSelectionMode as alloy_sol_types::SolType>::tokenize(
                        &self.selectionMode,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashFactorSnapshot),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BondLessRequest {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BondLessRequest {
            const NAME: &'static str = "BondLessRequest";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BondLessRequest(address operator,Asset asset,uint256 shares,uint64 requestedRound,uint8 selectionMode,uint256 slashFactorSnapshot)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Asset as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Asset as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.operator,
                        )
                        .0,
                    <Asset as alloy_sol_types::SolType>::eip712_data_word(&self.asset).0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.shares)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.requestedRound,
                        )
                        .0,
                    <BlueprintSelectionMode as alloy_sol_types::SolType>::eip712_data_word(
                            &self.selectionMode,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.slashFactorSnapshot,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BondLessRequest {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operator,
                    )
                    + <Asset as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.asset,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.shares,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requestedRound,
                    )
                    + <BlueprintSelectionMode as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.selectionMode,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.slashFactorSnapshot,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operator,
                    out,
                );
                <Asset as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.asset,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.shares,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requestedRound,
                    out,
                );
                <BlueprintSelectionMode as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.selectionMode,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.slashFactorSnapshot,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Deposit { uint256 amount; uint256 delegatedAmount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Deposit {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub delegatedAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Deposit> for UnderlyingRustTuple<'_> {
            fn from(value: Deposit) -> Self {
                (value.amount, value.delegatedAmount)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Deposit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amount: tuple.0,
                    delegatedAmount: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Deposit {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Deposit {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.delegatedAmount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Deposit {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Deposit {
            const NAME: &'static str = "Deposit";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Deposit(uint256 amount,uint256 delegatedAmount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.delegatedAmount,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Deposit {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.delegatedAmount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.delegatedAmount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct LockInfo { uint256 amount; LockMultiplier multiplier; uint64 expiryBlock; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LockInfo {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub multiplier: <LockMultiplier as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub expiryBlock: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            LockMultiplier,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            <LockMultiplier as alloy::sol_types::SolType>::RustType,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LockInfo> for UnderlyingRustTuple<'_> {
            fn from(value: LockInfo) -> Self {
                (value.amount, value.multiplier, value.expiryBlock)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LockInfo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    amount: tuple.0,
                    multiplier: tuple.1,
                    expiryBlock: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for LockInfo {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for LockInfo {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <LockMultiplier as alloy_sol_types::SolType>::tokenize(
                        &self.multiplier,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiryBlock),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for LockInfo {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for LockInfo {
            const NAME: &'static str = "LockInfo";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "LockInfo(uint256 amount,uint8 multiplier,uint64 expiryBlock)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <LockMultiplier as alloy_sol_types::SolType>::eip712_data_word(
                            &self.multiplier,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expiryBlock)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for LockInfo {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <LockMultiplier as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.multiplier,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expiryBlock,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <LockMultiplier as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.multiplier,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expiryBlock,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct OperatorMetadata { uint256 stake; uint32 delegationCount; OperatorStatus status; uint64 leavingRound; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorMetadata {
        #[allow(missing_docs)]
        pub stake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub delegationCount: u32,
        #[allow(missing_docs)]
        pub status: <OperatorStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub leavingRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<32>,
            OperatorStatus,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            u32,
            <OperatorStatus as alloy::sol_types::SolType>::RustType,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorMetadata> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorMetadata) -> Self {
                (value.stake, value.delegationCount, value.status, value.leavingRound)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorMetadata {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    stake: tuple.0,
                    delegationCount: tuple.1,
                    status: tuple.2,
                    leavingRound: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OperatorMetadata {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OperatorMetadata {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stake),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.delegationCount),
                    <OperatorStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.leavingRound),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorMetadata {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OperatorMetadata {
            const NAME: &'static str = "OperatorMetadata";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OperatorMetadata(uint256 stake,uint32 delegationCount,uint8 status,uint64 leavingRound)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.stake)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.delegationCount,
                        )
                        .0,
                    <OperatorStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.status,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.leavingRound)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorMetadata {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.stake)
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.delegationCount,
                    )
                    + <OperatorStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.status,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.leavingRound,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stake,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.delegationCount,
                    out,
                );
                <OperatorStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.status,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.leavingRound,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct OperatorRewardPool { uint256 accRewardPerShare; uint256 totalShares; uint256 totalAssets; uint64 lastUpdateRound; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorRewardPool {
        #[allow(missing_docs)]
        pub accRewardPerShare: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub totalShares: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub totalAssets: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lastUpdateRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorRewardPool> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorRewardPool) -> Self {
                (
                    value.accRewardPerShare,
                    value.totalShares,
                    value.totalAssets,
                    value.lastUpdateRound,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorRewardPool {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    accRewardPerShare: tuple.0,
                    totalShares: tuple.1,
                    totalAssets: tuple.2,
                    lastUpdateRound: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OperatorRewardPool {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OperatorRewardPool {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.accRewardPerShare),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalShares),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalAssets),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.lastUpdateRound),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorRewardPool {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OperatorRewardPool {
            const NAME: &'static str = "OperatorRewardPool";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OperatorRewardPool(uint256 accRewardPerShare,uint256 totalShares,uint256 totalAssets,uint64 lastUpdateRound)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.accRewardPerShare,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.totalShares)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.totalAssets)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.lastUpdateRound,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorRewardPool {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.accRewardPerShare,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalShares,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalAssets,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lastUpdateRound,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.accRewardPerShare,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalShares,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalAssets,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lastUpdateRound,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct OperatorSnapshot { uint256 stake; uint256 totalDelegated; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorSnapshot {
        #[allow(missing_docs)]
        pub stake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub totalDelegated: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorSnapshot> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorSnapshot) -> Self {
                (value.stake, value.totalDelegated)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorSnapshot {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    stake: tuple.0,
                    totalDelegated: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OperatorSnapshot {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OperatorSnapshot {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stake),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalDelegated),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorSnapshot {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OperatorSnapshot {
            const NAME: &'static str = "OperatorSnapshot";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OperatorSnapshot(uint256 stake,uint256 totalDelegated)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.stake)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.totalDelegated,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorSnapshot {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.stake)
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalDelegated,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stake,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalDelegated,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct WithdrawRequest { Asset asset; uint256 amount; uint64 requestedRound; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WithdrawRequest {
        #[allow(missing_docs)]
        pub asset: <Asset as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub requestedRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            Asset,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <Asset as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::primitives::aliases::U256,
            u64,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<WithdrawRequest> for UnderlyingRustTuple<'_> {
            fn from(value: WithdrawRequest) -> Self {
                (value.asset, value.amount, value.requestedRound)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for WithdrawRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    asset: tuple.0,
                    amount: tuple.1,
                    requestedRound: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for WithdrawRequest {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for WithdrawRequest {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <Asset as alloy_sol_types::SolType>::tokenize(&self.asset),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestedRound),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for WithdrawRequest {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for WithdrawRequest {
            const NAME: &'static str = "WithdrawRequest";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "WithdrawRequest(Asset asset,uint256 amount,uint64 requestedRound)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Asset as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Asset as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <Asset as alloy_sol_types::SolType>::eip712_data_word(&self.asset).0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.requestedRound,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for WithdrawRequest {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <Asset as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.asset,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requestedRound,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <Asset as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.asset,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requestedRound,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Types`](self) contract instance.

See the [wrapper's documentation](`TypesInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(address: alloy_sol_types::private::Address, __provider: P) -> TypesInstance<P, N> {
        TypesInstance::<P, N>::new(address, __provider)
    }
    /**A [`Types`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Types`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TypesInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for TypesInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TypesInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TypesInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`Types`](self) contract instance.

See the [wrapper's documentation](`TypesInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> TypesInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TypesInstance<P, N> {
            TypesInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TypesInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > TypesInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library SlashingManager {
    struct SlashRecord {
        uint64 round;
        uint64 serviceId;
        uint64 blueprintId;
        uint256 totalSlashed;
        uint256 exchangeRateBefore;
        uint256 exchangeRateAfter;
        bytes32 evidence;
    }
}

library Types {
    type AssetKind is uint8;
    type BlueprintSelectionMode is uint8;
    type LockMultiplier is uint8;
    type OperatorStatus is uint8;
    struct Asset {
        AssetKind kind;
        address token;
    }
    struct AssetConfig {
        bool enabled;
        uint256 minOperatorStake;
        uint256 minDelegation;
        uint256 depositCap;
        uint256 currentDeposits;
        uint16 rewardMultiplierBps;
    }
    struct AssetSecurityCommitment {
        Asset asset;
        uint16 exposureBps;
    }
    struct BondInfoDelegator {
        address operator;
        uint256 shares;
        Asset asset;
        BlueprintSelectionMode selectionMode;
    }
    struct BondLessRequest {
        address operator;
        Asset asset;
        uint256 shares;
        uint64 requestedRound;
        BlueprintSelectionMode selectionMode;
        uint256 slashFactorSnapshot;
    }
    struct Deposit {
        uint256 amount;
        uint256 delegatedAmount;
    }
    struct LockInfo {
        uint256 amount;
        LockMultiplier multiplier;
        uint64 expiryBlock;
    }
    struct OperatorMetadata {
        uint256 stake;
        uint32 delegationCount;
        OperatorStatus status;
        uint64 leavingRound;
    }
    struct OperatorRewardPool {
        uint256 accRewardPerShare;
        uint256 totalShares;
        uint256 totalAssets;
        uint64 lastUpdateRound;
    }
    struct OperatorSnapshot {
        uint256 stake;
        uint256 totalDelegated;
    }
    struct WithdrawRequest {
        Asset asset;
        uint256 amount;
        uint64 requestedRound;
    }
}

interface MultiAssetDelegationExposed {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AddressEmptyCode(address target);
    error AllModeDisallowsBlueprints();
    error AmountLocked(uint256 locked, uint256 requested);
    error AssetNotEnabled(address asset);
    error BelowMinimumDeposit(uint256 minimum, uint256 provided);
    error BlueprintAlreadySelected(uint64 blueprintId);
    error BlueprintNotSelected(uint64 blueprintId);
    error CannotRemoveLastBlueprint();
    error DelegationNotFound(address delegator, address operator);
    error DepositCapExceeded(uint256 cap, uint256 current, uint256 adding);
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error EnforcedPause();
    error ExpectedPause();
    error FailedCall();
    error FixedModeRequiresBlueprints();
    error InsufficientAvailableBalance(uint256 available, uint256 requested);
    error InsufficientDelegation(uint256 available, uint256 requested);
    error InsufficientDeposit(uint256 available, uint256 requested);
    error InsufficientStake(uint256 required, uint256 provided);
    error InvalidDelegationIndex(uint256 index);
    error InvalidInitialization();
    error InvalidLockMultiplier(uint8 value);
    error LeavingTooEarly(uint64 currentRound, uint64 requiredRound);
    error LegacySlashRequiresAllMode(address operator);
    error NoRewardsToClaim();
    error NotFixedMode();
    error NotInitializing();
    error OperatorAlreadyRegistered(address operator);
    error OperatorNotActive(address operator);
    error OperatorNotLeaving(address operator);
    error OperatorNotRegistered(address operator);
    error ReentrancyGuardReentrantCall();
    error RoundAdvanceTooSoon(uint64 nextAllowedTime, uint64 currentTime);
    error SafeERC20FailedOperation(address token);
    error SelectionModeMismatch();
    error TransferFailed();
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);
    error ZeroAddress();
    error ZeroAmount();

    event AdapterRegistered(address indexed token, address indexed adapter);
    event AdapterRemoved(address indexed token);
    event AssetDisabled(address indexed token);
    event AssetEnabled(address indexed token, uint256 minOperatorStake, uint256 minDelegation);
    event BlueprintAddedToDelegation(address indexed delegator, uint256 indexed delegationIndex, uint64 blueprintId);
    event BlueprintRemovedFromDelegation(address indexed delegator, uint256 indexed delegationIndex, uint64 blueprintId);
    event Delegated(address indexed delegator, address indexed operator, address indexed token, uint256 amount, uint256 shares, Types.BlueprintSelectionMode selectionMode);
    event DelegatorUnstakeExecuted(address indexed delegator, address indexed operator, address indexed token, uint256 shares, uint256 amount);
    event DelegatorUnstakeScheduled(address indexed delegator, address indexed operator, address indexed token, uint256 shares, uint256 estimatedAmount, uint64 readyRound);
    event Deposited(address indexed delegator, address indexed token, uint256 amount, Types.LockMultiplier lock);
    event Initialized(uint64 version);
    event OperatorBlueprintAdded(address indexed operator, uint64 indexed blueprintId);
    event OperatorBlueprintRemoved(address indexed operator, uint64 indexed blueprintId);
    event OperatorLeavingScheduled(address indexed operator, uint64 readyRound);
    event OperatorLeft(address indexed operator);
    event OperatorRegistered(address indexed operator, uint256 stake);
    event OperatorSlashed(address indexed operator, uint64 indexed serviceId, uint256 amount, bytes32 evidence);
    event OperatorStakeIncreased(address indexed operator, uint256 amount);
    event OperatorUnstakeExecuted(address indexed operator, uint256 amount);
    event OperatorUnstakeScheduled(address indexed operator, uint256 amount, uint64 readyRound);
    event Paused(address account);
    event RequireAdaptersUpdated(bool required);
    event RewardClaimed(address indexed account, uint256 amount);
    event RewardDistributed(address indexed operator, uint256 amount);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event RoundAdvanced(uint64 indexed round);
    event SlashRecorded(address indexed operator, uint64 indexed slashId, uint256 totalSlashed, uint256 exchangeRateBefore, uint256 exchangeRateAfter);
    event Slashed(address indexed operator, uint64 indexed serviceId, uint256 operatorSlashed, uint256 delegatorsSlashed, uint256 newExchangeRate);
    event SlashedForService(address indexed operator, uint64 indexed serviceId, uint64 indexed blueprintId, uint256 totalSlashed, uint256 commitmentCount);
    event Unpaused(address account);
    event Upgraded(address indexed implementation);
    event WithdrawScheduled(address indexed delegator, address indexed token, uint256 amount, uint64 readyRound);
    event Withdrawn(address indexed delegator, address indexed token, uint256 amount);

    receive() external payable;

    function ADMIN_ROLE() external view returns (bytes32);
    function ASSET_MANAGER_ROLE() external view returns (bytes32);
    function BPS_DENOMINATOR() external view returns (uint256);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function LOCK_ONE_MONTH() external view returns (uint64);
    function LOCK_SIX_MONTHS() external view returns (uint64);
    function LOCK_THREE_MONTHS() external view returns (uint64);
    function LOCK_TWO_MONTHS() external view returns (uint64);
    function MULTIPLIER_NONE() external view returns (uint16);
    function MULTIPLIER_ONE_MONTH() external view returns (uint16);
    function MULTIPLIER_SIX_MONTHS() external view returns (uint16);
    function MULTIPLIER_THREE_MONTHS() external view returns (uint16);
    function MULTIPLIER_TWO_MONTHS() external view returns (uint16);
    function PRECISION() external view returns (uint256);
    function SLASHER_ROLE() external view returns (bytes32);
    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function addBlueprint(uint64 blueprintId) external;
    function addBlueprintToDelegation(uint256 delegationIndex, uint64 blueprintId) external;
    function addSlasher(address slasher) external;
    function advanceRound() external;
    function blueprintPoolTotals(address operator, uint64 blueprintId) external view returns (uint256);
    function blueprintSlashCount(uint64, address) external view returns (uint64);
    function claimDelegatorRewards() external returns (uint256 totalRewards);
    function claimOperatorRewards() external;
    function claimOperatorRewardsTo(address payable recipient) external;
    function completeLeaving() external;
    function currentRound() external view returns (uint64);
    function delegate(address operator, uint256 amount) external;
    function delegateWithOptions(address operator, address token, uint256 amount, Types.BlueprintSelectionMode selectionMode, uint64[] memory blueprintIds) external;
    function delegationBondLessDelay() external view returns (uint64);
    function deposit() external payable;
    function depositAndDelegate(address operator) external payable;
    function depositAndDelegateWithOptions(address operator, address token, uint256 amount, Types.BlueprintSelectionMode selectionMode, uint64[] memory blueprintIds) external payable;
    function depositERC20(address token, uint256 amount) external;
    function depositERC20WithLock(address token, uint256 amount, Types.LockMultiplier lockMultiplier) external;
    function depositWithLock(Types.LockMultiplier lockMultiplier) external payable;
    function disableAsset(address token) external;
    function enableAsset(address token, uint256 _minOperatorStake, uint256 _minDelegation, uint256 _depositCap, uint16 _rewardMultiplierBps) external;
    function enableAssetWithAdapter(address token, address adapter, uint256 _minOperatorStake, uint256 _minDelegation, uint256 _depositCap, uint16 _rewardMultiplierBps) external;
    function executeDelegatorUnstake() external;
    function executeOperatorUnstake() external;
    function executeWithdraw() external;
    function getAssetAdapter(address token) external view returns (address);
    function getAssetConfig(address token) external view returns (Types.AssetConfig memory);
    function getDelegation(address delegator, address operator) external view returns (uint256);
    function getDelegationBlueprints(address delegator, uint256 idx) external view returns (uint64[] memory);
    function getDelegations(address delegator) external view returns (Types.BondInfoDelegator[] memory);
    function getDeposit(address delegator, address token) external view returns (Types.Deposit memory);
    function getLocks(address delegator, address token) external view returns (Types.LockInfo[] memory);
    function getOperatorBlueprints(address operator) external view returns (uint256[] memory);
    function getOperatorDelegatedStake(address operator) external view returns (uint256);
    function getOperatorDelegatorCount(address operator) external view returns (uint256);
    function getOperatorDelegators(address operator) external view returns (address[] memory);
    function getOperatorMetadata(address operator) external view returns (Types.OperatorMetadata memory);
    function getOperatorRewardPool(address operator) external view returns (Types.OperatorRewardPool memory);
    function getOperatorSelfStake(address operator) external view returns (uint256);
    function getOperatorSlashFactor(address operator) external view returns (uint256);
    function getOperatorStake(address operator) external view returns (uint256);
    function getPendingDelegatorRewards(address delegator) external view returns (uint256);
    function getPendingOperatorRewards(address operator) external view returns (uint256);
    function getPendingUnstakes(address delegator) external view returns (Types.BondLessRequest[] memory);
    function getPendingWithdrawals(address delegator) external view returns (Types.WithdrawRequest[] memory);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getSlashCount(address operator) external view returns (uint64);
    function getSlashCountForBlueprint(uint64 blueprintId, address operator) external view returns (uint64);
    function getSlashCountForService(uint64 serviceId, address operator) external view returns (uint64);
    function getSlashImpact(address operator, uint64 slashId, address delegator) external view returns (uint256 lostAmount);
    function getSlashRecord(address operator, uint64 slashId) external view returns (SlashingManager.SlashRecord memory);
    function getSnapshot(uint64 round, address operator) external view returns (Types.OperatorSnapshot memory);
    function getTotalDelegation(address delegator) external view returns (uint256 total);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function increaseStake() external payable;
    function initialize(address admin, uint256 nativeMinOperatorStake, uint256 nativeMinDelegation, uint16 _operatorCommissionBps) external;
    function isOperator(address operator) external view returns (bool);
    function isOperatorActive(address operator) external view returns (bool);
    function isSlasher(address account) external view returns (bool);
    function lastRoundAdvance() external view returns (uint64);
    function leaveDelegatorsDelay() external view returns (uint64);
    function leaveOperatorsDelay() external view returns (uint64);
    function meetsStakeRequirement(address operator, uint256 required) external view returns (bool);
    function minOperatorStake() external view returns (uint256);
    function nativeEnabled() external view returns (bool);
    function nextSlashId(address) external view returns (uint64);
    function notifyReward(address operator, uint64 serviceId, uint256 amount) external;
    function notifyRewardForBlueprint(address operator, uint64 blueprintId, uint64 serviceId, uint256 amount) external;
    function operatorAt(uint256 index) external view returns (address);
    function operatorCommissionBps() external view returns (uint16);
    function operatorCount() external view returns (uint256);
    function operatorStake(address operator) external view returns (uint256);
    function pause() external;
    function paused() external view returns (bool);
    function proxiableUUID() external view returns (bytes32);
    function registerAdapter(address token, address adapter) external;
    function registerOperator() external payable;
    function registerOperatorWithAsset(address token, uint256 amount) external;
    function removeAdapter(address token) external;
    function removeBlueprint(uint64 blueprintId) external;
    function removeBlueprintFromDelegation(uint256 delegationIndex, uint64 blueprintId) external;
    function removeSlasher(address slasher) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function requireAdapters() external view returns (bool);
    function rescueTokens(address token, address to, uint256 amount) external;
    function revokeRole(bytes32 role, address account) external;
    function rewardPoolTotals(address operator) external view returns (uint256);
    function rewardsManager() external view returns (address);
    function roundDuration() external view returns (uint64);
    function scheduleDelegatorUnstake(address operator, address token, uint256 amount) external;
    function scheduleOperatorUnstake(uint256 amount) external;
    function scheduleWithdraw(address token, uint256 amount) external;
    function serviceFeeDistributor() external view returns (address);
    function serviceSlashCount(uint64, address) external view returns (uint64);
    function setDelays(uint64 _delegationBondLessDelay, uint64 _leaveDelegatorsDelay, uint64 _leaveOperatorsDelay) external;
    function setOperatorCommission(uint16 bps) external;
    function setRequireAdapters(bool required) external;
    function setRewardsManager(address manager) external;
    function setServiceFeeDistributor(address distributor) external;
    function slash(address operator, uint64 serviceId, uint256 amount, bytes32 evidence) external returns (uint256 actualSlashed);
    function slashForBlueprint(address operator, uint64 blueprintId, uint64 serviceId, uint256 amount, bytes32 evidence) external returns (uint256 actualSlashed);
    function slashForService(address operator, uint64 blueprintId, uint64 serviceId, Types.AssetSecurityCommitment[] memory commitments, uint256 amount, bytes32 evidence) external returns (uint256 actualSlashed);
    function slashHistory(address, uint64) external view returns (uint64 round, uint64 serviceId, uint64 blueprintId, uint256 totalSlashed, uint256 exchangeRateBefore, uint256 exchangeRateAfter, bytes32 evidence);
    function snapshotOperator(address operator) external;
    function startLeaving() external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function undelegate(address operator, uint256 amount) external;
    function unpause() external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ASSET_MANAGER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "BPS_DENOMINATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LOCK_ONE_MONTH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LOCK_SIX_MONTHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LOCK_THREE_MONTHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "LOCK_TWO_MONTHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MULTIPLIER_NONE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MULTIPLIER_ONE_MONTH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MULTIPLIER_SIX_MONTHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MULTIPLIER_THREE_MONTHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MULTIPLIER_TWO_MONTHS",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PRECISION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SLASHER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "addBlueprint",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addBlueprintToDelegation",
    "inputs": [
      {
        "name": "delegationIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "addSlasher",
    "inputs": [
      {
        "name": "slasher",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "advanceRound",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "blueprintPoolTotals",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "blueprintSlashCount",
    "inputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimDelegatorRewards",
    "inputs": [],
    "outputs": [
      {
        "name": "totalRewards",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimOperatorRewards",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimOperatorRewardsTo",
    "inputs": [
      {
        "name": "recipient",
        "type": "address",
        "internalType": "address payable"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "completeLeaving",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "currentRound",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "delegate",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegateWithOptions",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "selectionMode",
        "type": "uint8",
        "internalType": "enum Types.BlueprintSelectionMode"
      },
      {
        "name": "blueprintIds",
        "type": "uint64[]",
        "internalType": "uint64[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "delegationBondLessDelay",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "deposit",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositAndDelegate",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositAndDelegateWithOptions",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "selectionMode",
        "type": "uint8",
        "internalType": "enum Types.BlueprintSelectionMode"
      },
      {
        "name": "blueprintIds",
        "type": "uint64[]",
        "internalType": "uint64[]"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "depositERC20",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "depositERC20WithLock",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "lockMultiplier",
        "type": "uint8",
        "internalType": "enum Types.LockMultiplier"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "depositWithLock",
    "inputs": [
      {
        "name": "lockMultiplier",
        "type": "uint8",
        "internalType": "enum Types.LockMultiplier"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "disableAsset",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enableAsset",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_minOperatorStake",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_minDelegation",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_depositCap",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_rewardMultiplierBps",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "enableAssetWithAdapter",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "adapter",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_minOperatorStake",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_minDelegation",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_depositCap",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_rewardMultiplierBps",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "executeDelegatorUnstake",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "executeOperatorUnstake",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "executeWithdraw",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "getAssetAdapter",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getAssetConfig",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.AssetConfig",
        "components": [
          {
            "name": "enabled",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "minOperatorStake",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "minDelegation",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "depositCap",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "currentDeposits",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "rewardMultiplierBps",
            "type": "uint16",
            "internalType": "uint16"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDelegation",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDelegationBlueprints",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "idx",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64[]",
        "internalType": "uint64[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDelegations",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct Types.BondInfoDelegator[]",
        "components": [
          {
            "name": "operator",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "shares",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "asset",
            "type": "tuple",
            "internalType": "struct Types.Asset",
            "components": [
              {
                "name": "kind",
                "type": "uint8",
                "internalType": "enum Types.AssetKind"
              },
              {
                "name": "token",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "selectionMode",
            "type": "uint8",
            "internalType": "enum Types.BlueprintSelectionMode"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getDeposit",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.Deposit",
        "components": [
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "delegatedAmount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getLocks",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct Types.LockInfo[]",
        "components": [
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "multiplier",
            "type": "uint8",
            "internalType": "enum Types.LockMultiplier"
          },
          {
            "name": "expiryBlock",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorBlueprints",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorDelegatedStake",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorDelegatorCount",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorDelegators",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorMetadata",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.OperatorMetadata",
        "components": [
          {
            "name": "stake",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "delegationCount",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum Types.OperatorStatus"
          },
          {
            "name": "leavingRound",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorRewardPool",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.OperatorRewardPool",
        "components": [
          {
            "name": "accRewardPerShare",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "totalShares",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "totalAssets",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lastUpdateRound",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorSelfStake",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorSlashFactor",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorStake",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPendingDelegatorRewards",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPendingOperatorRewards",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPendingUnstakes",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct Types.BondLessRequest[]",
        "components": [
          {
            "name": "operator",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "asset",
            "type": "tuple",
            "internalType": "struct Types.Asset",
            "components": [
              {
                "name": "kind",
                "type": "uint8",
                "internalType": "enum Types.AssetKind"
              },
              {
                "name": "token",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "shares",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "requestedRound",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "selectionMode",
            "type": "uint8",
            "internalType": "enum Types.BlueprintSelectionMode"
          },
          {
            "name": "slashFactorSnapshot",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getPendingWithdrawals",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple[]",
        "internalType": "struct Types.WithdrawRequest[]",
        "components": [
          {
            "name": "asset",
            "type": "tuple",
            "internalType": "struct Types.Asset",
            "components": [
              {
                "name": "kind",
                "type": "uint8",
                "internalType": "enum Types.AssetKind"
              },
              {
                "name": "token",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "requestedRound",
            "type": "uint64",
            "internalType": "uint64"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSlashCount",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSlashCountForBlueprint",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSlashCountForService",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSlashImpact",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "lostAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSlashRecord",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct SlashingManager.SlashRecord",
        "components": [
          {
            "name": "round",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "serviceId",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "blueprintId",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "totalSlashed",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "exchangeRateBefore",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "exchangeRateAfter",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "evidence",
            "type": "bytes32",
            "internalType": "bytes32"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSnapshot",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.OperatorSnapshot",
        "components": [
          {
            "name": "stake",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "totalDelegated",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getTotalDelegation",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "total",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "increaseStake",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "nativeMinOperatorStake",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "nativeMinDelegation",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "_operatorCommissionBps",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isOperator",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isOperatorActive",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isSlasher",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "lastRoundAdvance",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "leaveDelegatorsDelay",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "leaveOperatorsDelay",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "meetsStakeRequirement",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "required",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "minOperatorStake",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nativeEnabled",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "nextSlashId",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "notifyReward",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "notifyRewardForBlueprint",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "operatorAt",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "operatorCommissionBps",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "operatorCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "operatorStake",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "registerAdapter",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "adapter",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "registerOperator",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "registerOperatorWithAsset",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeAdapter",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBlueprint",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeBlueprintFromDelegation",
    "inputs": [
      {
        "name": "delegationIndex",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeSlasher",
    "inputs": [
      {
        "name": "slasher",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "requireAdapters",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "rescueTokens",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rewardPoolTotals",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "rewardsManager",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "roundDuration",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "scheduleDelegatorUnstake",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "scheduleOperatorUnstake",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "scheduleWithdraw",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serviceFeeDistributor",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "serviceSlashCount",
    "inputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setDelays",
    "inputs": [
      {
        "name": "_delegationBondLessDelay",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "_leaveDelegatorsDelay",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "_leaveOperatorsDelay",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setOperatorCommission",
    "inputs": [
      {
        "name": "bps",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRequireAdapters",
    "inputs": [
      {
        "name": "required",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setRewardsManager",
    "inputs": [
      {
        "name": "manager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setServiceFeeDistributor",
    "inputs": [
      {
        "name": "distributor",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "slash",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "evidence",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "actualSlashed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "slashForBlueprint",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "evidence",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "actualSlashed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "slashForService",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "commitments",
        "type": "tuple[]",
        "internalType": "struct Types.AssetSecurityCommitment[]",
        "components": [
          {
            "name": "asset",
            "type": "tuple",
            "internalType": "struct Types.Asset",
            "components": [
              {
                "name": "kind",
                "type": "uint8",
                "internalType": "enum Types.AssetKind"
              },
              {
                "name": "token",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "exposureBps",
            "type": "uint16",
            "internalType": "uint16"
          }
        ]
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "evidence",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "actualSlashed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "slashHistory",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "round",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "totalSlashed",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "exchangeRateBefore",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "exchangeRateAfter",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "evidence",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "snapshotOperator",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "startLeaving",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "undelegate",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "AdapterRegistered",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "adapter",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "AdapterRemoved",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "AssetDisabled",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "AssetEnabled",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "minOperatorStake",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "minDelegation",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlueprintAddedToDelegation",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "delegationIndex",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlueprintRemovedFromDelegation",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "delegationIndex",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Delegated",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "shares",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "selectionMode",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum Types.BlueprintSelectionMode"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegatorUnstakeExecuted",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "shares",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "DelegatorUnstakeScheduled",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "shares",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "estimatedAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "readyRound",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Deposited",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "lock",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum Types.LockMultiplier"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorBlueprintAdded",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorBlueprintRemoved",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorLeavingScheduled",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "readyRound",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorLeft",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorRegistered",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "stake",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorSlashed",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "evidence",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorStakeIncreased",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorUnstakeExecuted",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorUnstakeScheduled",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "readyRound",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RequireAdaptersUpdated",
    "inputs": [
      {
        "name": "required",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RewardClaimed",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RewardDistributed",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoundAdvanced",
    "inputs": [
      {
        "name": "round",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashRecorded",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "slashId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "totalSlashed",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "exchangeRateBefore",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "exchangeRateAfter",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Slashed",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operatorSlashed",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "delegatorsSlashed",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "newExchangeRate",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashedForService",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "totalSlashed",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "commitmentCount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "WithdrawScheduled",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "readyRound",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Withdrawn",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AllModeDisallowsBlueprints",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AmountLocked",
    "inputs": [
      {
        "name": "locked",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "requested",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "AssetNotEnabled",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "BelowMinimumDeposit",
    "inputs": [
      {
        "name": "minimum",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "provided",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "BlueprintAlreadySelected",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "BlueprintNotSelected",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "CannotRemoveLastBlueprint",
    "inputs": []
  },
  {
    "type": "error",
    "name": "DelegationNotFound",
    "inputs": [
      {
        "name": "delegator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "DepositCapExceeded",
    "inputs": [
      {
        "name": "cap",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "current",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "adding",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FixedModeRequiresBlueprints",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientAvailableBalance",
    "inputs": [
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "requested",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientDelegation",
    "inputs": [
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "requested",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientDeposit",
    "inputs": [
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "requested",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientStake",
    "inputs": [
      {
        "name": "required",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "provided",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidDelegationIndex",
    "inputs": [
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidLockMultiplier",
    "inputs": [
      {
        "name": "value",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "LeavingTooEarly",
    "inputs": [
      {
        "name": "currentRound",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "requiredRound",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "LegacySlashRequiresAllMode",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NoRewardsToClaim",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotFixedMode",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OperatorAlreadyRegistered",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OperatorNotActive",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OperatorNotLeaving",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OperatorNotRegistered",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "RoundAdvanceTooSoon",
    "inputs": [
      {
        "name": "nextAllowedTime",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "currentTime",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "SafeERC20FailedOperation",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "SelectionModeMismatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TransferFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod MultiAssetDelegationExposed {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a080604052346100e857306080527ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460ff8160401c166100d9576002600160401b03196001600160401b03821601610073575b604051619fa890816100ed82396080518181816139b30152613aa90152f35b6001600160401b0319166001600160401b039081177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005581527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f80610054565b63f92ee8a960e01b5f5260045ffd5b5f80fdfe6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c80627910d01461586457806301ffc9a71461580e578063026e402b146157d957806303587c1d1461573e57806303780211146156b157806305d64e38146156895780630a8ddc5e146156465780630aa8b110146155a85780630c8833ce1461543457806315049a5a146152e0578063168f6865146150f457806318056dc2146150d85780631ba9998b14614fee57806323cc270014614c2c578063248a9ca314614c0e5780632614233514614bd557806328e70ecc14614b745780632acde09814614a445780632e40f7fb14614a1e5780632ee663b81461495b5780632f2ff15d1461492a57806330224fc8146148f257806331cc13ba146147bb57806332273f6114614797578063354ebef9146146b8578063356924ea1461467c57806336568abe146146385780633dcad9db146144755780633f4ba83a146143f757806344aff252146142b557806344d1480b14614018578063453eccea14613ffc578063461cc23b14613fc6578063486398c314613f8e5780634962f88f146117845780634c4ede2d14613f6d5780634d99dd1614613c605780634de8addc14613c375780634e9c929a146124ab5780634f1ef28614613a2e5780635095af6414613a0757806352d1902d146139a157806354de2320146139855780635722d5121461381657806357601c5d146137c8578063585cd34b146137085780635c975abb146136da5780635fdc8f2d14613684578063615d24de1461366157806366c3687514612c1b57806368a9f19c14613638578063697d08f914612d365780636d70f7ae146135f65780636ec3ab67146134e4578063708075281461344457806372b5032d14612bbf57806375b238fc1461340a57806377ab2cf3146133e85780637b76fe5e146133865780637b9996c5146132345780637c6f3158146132175780637d6941c6146131e25780637df92ada146131c55780638456cb5914613154578063859caa1814612e7b5780638770355014612da05780638a19c8bc14612d7b5780638a7fe60f14612d3b5780638c5b4ae714612d365780638d795d5014612cf257806391d1485414612c9d5780639494f42614612c5c5780639608567314612c1b5780639722f4b914612bbf57806397feb92614612b8a5780639e87058514612b6d5780639e8c49d414612ae5578063a217fddf14612acb578063a299e298146129de578063a3b9c5c2146128ca578063a457af3d146127a1578063a4b32de814612767578063a7fa6f981461274b578063aac6aa9c14612722578063aaf5eb6814612700578063ad3cb1cc146126a2578063b0dfce061461266e578063b39bcf3f14611b5b578063b54b2b9e1461264c578063ba05bbf51461262d578063c07449e2146125d1578063c35082a914612507578063c550d938146124ab578063c735302514612427578063cadd550c14612357578063cb15038b146122e6578063cbb6d6bd1461200d578063cea9d26f14611e5e578063d0e30db014611e3b578063d1736ba714611d0f578063d27a6f0614611cf2578063d547741f14611cbc578063d655b92a14611b93578063d673e0b914611b5b578063d775cb6114611b15578063d9e257ef14611a71578063db8a173a14611a4b578063dc972ccc14611997578063defe20531461196f578063e0a5825b146117a0578063e1a4521814611784578063e1ee4bcc146114e6578063e4e88de814611496578063eb47353314611416578063f0b52bb414611221578063f340c0d01461110f578063f38c7c4e146110c7578063f3c4d8a014611042578063f3c9b31114611025578063f46913bb14610fe8578063f7cb789a14610fc0578063f8fd979514610afc578063fbcc7b3d14610ab9578063fbec486114610a6e578063fc5e7e09146109e9578063fc8a91af146105e15763fd7d3dbc0361000e57346105dd576105ca6105c46105a63661633a565b6105b596929596949394616816565b6105bd616716565b369161668e565b9361841e565b60015f80516020619f5c83398151915255005b5f80fd5b346105dd576105ef36616300565b906105f8616816565b81156109da576001600160a01b031690816109be57604051610619816161e2565b5f81525f6020820152915b61062d83617267565b9260018060a01b03851694855f52601860205260405f20600281015490811580156109b2575b1561096c57505083905b5f955f5b335f52601360205260405f205481101561096057335f52601360205261068a8160405f206166e9565b5080546001600160a01b03168a1480610949575b6106ab5750600101610661565b92939495969750505f90335f52601560205260405f205f918154925b8381106108d557505050506106e090600183015461646c565b8381106108b55750335f52601560205260405f209361071160ff60036001600160401b035f54169401541693616440565b906040519261071f84616218565b8984526020840191825260408401968688526060850191825260808501956107468161619c565b865260a085019384528054600160401b8110156108a15761076c9160018201815561674e565b95909561088e57935185546001600160a01b0319166001600160a01b0391909116178555905180518a97600495610818949390926107e29160018a01916107bc906107b68161619c565b836167db565b602001518154610100600160a81b03191660089190911b610100600160a81b0316179055565b5160028701556001600160401b038060038801935116166001600160401b031983541617825551906108138261619c565b6167f3565b519101556001600160401b036001946108385f54838160c01c9116616767565b9060405193845260208401521660408201527f06325d83435da87657b063c6142a5b91a66a7e811827d082d624287a9953c4ba60603392a45b1561087857005b6309078cff60e21b5f523360045260245260445ffd5b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b6108c0879184618ab7565b6388c4fe8f60e01b5f5260045260245260445ffd5b8b6108e0828561674e565b50546001600160a01b03161480610923575b6108ff575b6001016106c7565b9361091b6001916002610912888761674e565b5001549061666a565b9490506108f7565b508161094361093e6001610937858861674e565b5001616795565b617267565b146108f2565b508261095a61093e60028401616795565b1461069e565b50505050505050610871565b8161097e600161098393015488616479565b61666a565b5f1981019190821161099e576109989161648c565b9061065d565b634e487b7160e01b5f52601160045260245ffd5b50600181015415610653565b6040516109ca816161e2565b6001815282602082015291610624565b631f2a200560e01b5f5260045ffd5b346105dd5760203660031901126105dd57610a02616121565b5f906001600160a01b0316815b815f52601360205260405f2054831015610a6357610a5b600191835f526013602052610a55610a418660405f206166e9565b5084808060a01b0382541691015490618ab7565b9061666a565b920191610a0f565b602090604051908152f35b6105ca6105c4610a7d3661633a565b610a8c96929596949394616816565b610a94616716565b6001600160a01b038416610aaa576105bd617777565b610ab48585617cea565b6105bd565b346105dd5760203660031901126105dd57610ad2616121565b610ada616d1a565b602080546001600160a01b0319166001600160a01b0392909216919091179055005b346105dd575f3660031901126105dd57610b14616716565b5f335f52601260205260405f20905f90825492610b3084616677565b610b3d604051918261624e565b848152601f19610b4c86616677565b01366020830137610b5c85616677565b94610b6a604051968761624e565b808652601f19610b7982616677565b015f5b818110610f9d575050610b8e81616677565b93610b9c604051958661624e565b818552601f19610bab83616677565b013660208701375f6001600160401b035f5416906001600160401b0360015416905b8987868310610ef557898b918983610d9f575b50505f5b828110610bfe5760015f80516020619f5c83398151915255005b610c0881856167c7565b5190610c1481846167c7565b51918051610c218161619c565b610c2a8161619c565b610cdb5750905f80808093335af1610c40617748565b5015610c9d576001905b818060a01b036020610c5c83886167c7565b51015116610c6a82856167c7565b516040519081527fd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb60203392a301610be4565b60405162461bcd60e51b815260206004820152601660248201527513985d1a5d99481d1c985b9cd9995c8819985a5b195960521b6044820152606490fd5b602090810180516001600160a01b039081165f908152600690935260409092205490911692908315610d80575060405163f3fef3a360e01b8152336004820152602481019190915291602090839060449082905f905af1918215610d7557600192610d47575b50610c4a565b610d679060203d8111610d6e575b610d5f818361624e565b8101906195c1565b5085610d41565b503d610d55565b6040513d5f823e3d90fd5b5160019350610d9a919033906001600160a01b03166183c4565b610c4a565b909192935f945f5b8454811015610e9657610dba81856167c7565b5115610dc9575b600101610da7565b95868103610de5575b610ddd600191616787565b969050610dc1565b610def8786618405565b50610dfa8287618405565b92909261088e578282610ddd93600195141580610e1d575b505050915050610dd2565b6001600160401b03600281938193610e56575b8881015489870155015416920191166001600160401b0319825416179055898080610e12565b610e6460ff825416876167db565b80548654610100600160a81b031916600891821c60a08c901b8c90031690911b610100600160a81b0316178655610e30565b5091509193925b845484811115610ee8578015610ed4575f1901610eba8187618405565b61088e576002815f80935582600182015501558555610e9d565b634e487b7160e01b5f52603160045260245ffd5b5091935091508380610be0565b610f17846001600160401b036002610f0e878396618405565b50015416616767565b16841015610f29575b50600101610bcd565b610f8e8a95610f69849c610f9494610f59610f53888f8f610f4d60019c8d926167c7565b52618405565b50616795565b610f6383836167c7565b526167c7565b5083610f758d8c618405565b500154610f82888d6167c7565b52836109128d8c618405565b94616787565b98905089610f20565b602090604051610fac816161e2565b5f81525f8382015282828b01015201610b7c565b346105dd575f3660031901126105dd5760206001600160401b035f5460401c16604051908152f35b346105dd5760403660031901126105dd576001600160a01b03611009616121565b165f52600a602052602060243560405f20541015604051908152f35b346105dd575f3660031901126105dd57602060405162ed4e008152f35b346105dd5760203660031901126105dd5760043561ffff81168082036105dd576127109061106e616d1a565b11611094576001805461ffff60801b191660809290921b61ffff60801b16919091179055005b60405162461bcd60e51b815260206004820152600b60248201526a496e76616c69642042505360a81b6044820152606490fd5b60203660031901126105dd5760043560058110156105dd576105ca906110eb616816565b6110f3616716565b6040516110ff816161e2565b5f81525f60208201523490619194565b346105dd5760203660031901126105dd576001600160a01b03611130616121565b165f52601260205260405f2080549061114882616677565b91611156604051938461624e565b8083526020830180925f5260205f205f915b8383106111da578486604051918291602083019060208452518091526040830191905f5b81811061119a575050500390f35b91935091602060806001926001600160401b03604088516111bc8482516161a6565b8581015182850152015116606082015201940191019184939261118c565b600360206001926040516111ed816161fd565b6111f686616795565b815284860154838201526001600160401b036002870154166040820152815201920192019190611168565b346105dd5760c03660031901126105dd5761123a616121565b611242616137565b906044356064359060a4359261ffff84168094036105dd57611262616d89565b6001600160a01b031693611277851515616407565b6001600160a01b03169161128c8315156165c8565b60405163551c457b60e11b81526004810186905293602085602481875afa938415610d7557600561135161ffff926112ef6040987f9a4c59c56153245e23dcb8000e301b9a5e35b8e6693c5cdbf3b6a2aa0f8a37ea9a5f916113e7575b5061661e565b895f526006602052875f20816bffffffffffffffffffffffff60a01b8254161790558751908a7fc47df14ad9309b59073546f93dbe3115ed09c8b206d940f8441ddb07f745b10b5f80a3611342816161e2565b60018152896020820152617267565b86519061135d82616218565b60018252602082018781528883018781526060840191608435835260808501935f855260a086019889525f5260026020526113aa8b5f2095511515869060ff801983541691151516179055565b5160018501555160028401555160038301555160048201550191511661ffff198254161790556113d985618dc6565b5082519182526020820152a2005b611409915060203d60201161140f575b611401818361624e565b810190616606565b8c6112e9565b503d6113f7565b346105dd5760203660031901126105dd576001600160a01b03611437616121565b16805f52600960205260405f205415158061145a575b6020906040519015158152f35b505f52600a60205260ff600160405f20015460201c166003811015611482576020901561144d565b634e487b7160e01b5f52602160045260245ffd5b346105dd5760203660031901126105dd5760206114de6001600160a01b036114bc616121565b16805f52600a835260405f2054905f5260188352600260405f2001549061666a565b604051908152f35b346105dd5760403660031901126105dd576114ff616121565b6024359061150b616816565b81156109da576001600160a01b031690816117695760405161152c816161e2565b5f81525f60208201525b61153f81617267565b335f52601060205260405f20815f5260205260405f209081549061156760018401548361646c565b905f90335f52601160205260405f20905f5260205260405f205f908054915b82811061171d575050508083111561171657856115a3828561646c565b106116ff57508481106116e85750836115bb9161646c565b9055335f52601260205260405f206001600160401b035f541690604051926115e2846161fd565b83526020830190848252604084019283528054600160401b8110156108a15761161091600182018155618405565b93909361088e576001600160401b039260029261166385935161163d81516116378161619c565b896167db565b602001518754610100600160a81b03191660089190911b610100600160a81b0316178755565b5160018601555116920191166001600160401b03198254161790557f91eff7d39d2499d76ac21a1903a95a88f31589cb07b1ffdfb61db9f7cd8a39786116e36116c26001600160401b035f54166001600160401b036001541690616767565b604080519485526001600160401b0390911660208501523393918291820190565b0390a3005b849063adb9e04360e01b5f5260045260245260445ffd5b8590638ec3321160e01b5f5260045260245260445ffd5b855f6115a3565b6117278183619051565b506001600160401b0360014392015460081c1611611748575b600101611586565b926117616001916117598685619051565b50549061666a565b939050611740565b604051611775816161e2565b60018152826020820152611536565b346105dd575f3660031901126105dd5760206040516127108152f35b346105dd5760403660031901126105dd576117b9616121565b602435906117c5616816565b6117cd616716565b335f52600960205260405f205461195c576001600160a01b031680156119495761180b6040516117fc816161e2565b60018152826020820152617267565b5f52600260205260405f2060ff81541615611936576001839101549182821061191f5761183c92503090339061970c565b61184533618d60565b50604051611852816161c7565b818152602081015f8152604082015f815263ffffffff80600160608601955f8752335f52600a60205260405f2090518155019351161663ffffffff19835416178255516003811015611482576118e0926118b46001600160401b039284616f23565b5182546cffffffffffffffff00000000001916911660281b6cffffffffffffffff000000000016179055565b6040519081527fbc11617e575d658c74e921c8df22f8e48566072fa78145a6cfe18420bf8d0c4e60203392a260015f80516020619f5c83398151915255005b50506322df051360e11b5f5260045260245260445ffd5b5063f6f24b8360e01b5f5260045260245ffd5b63f6f24b8360e01b5f525f60045260245ffd5b63866b0dcf60e01b5f523360045260245ffd5b346105dd575f3660031901126105dd57601f546040516001600160a01b039091168152602090f35b346105dd5760203660031901126105dd576001600160a01b036119b8616121565b165f52600c60205260405f20604051806020835491828152019081935f5260205f20905f5b818110611a3557505050816119f391038261624e565b604051918291602083019060208452518091526040830191905f5b818110611a1c575050500390f35b8251845285945060209384019390920191600101611a0e565b82548452602090930192600192830192016119dd565b346105dd575f3660031901126105dd5760206001600160401b0360015416604051908152f35b5f3660031901126105dd57611a84616816565b611a8c616716565b335f52600a60205260405f2060ff600182015460201c16600381101561148257611b025734156109da57611ac134825461666a565b90556040513481527f614a3fa8467eb54cb60af3aab440279837c9fcd75c5a2617fe0af9c6e5e60e8360203392a260015f80516020619f5c83398151915255005b6371ab6ad560e11b5f523360045260245ffd5b346105dd575f3660031901126105dd57611b42604051611b34816161e2565b5f81525f6020820152617267565b5f5260026020526020600160405f200154604051908152f35b346105dd5760203660031901126105dd5760206114de611b79616121565b6001600160a01b03165f908152600a602052604090205490565b346105dd5760403660031901126105dd57611bac616121565b611bb4616137565b90611bbd616d89565b6001600160a01b0316908115611c77576001600160a01b031690611be28215156165c8565b60405163551c457b60e11b815260048101829052602081602481865afa8015610d7557611c15915f91611c58575061661e565b5f81815260066020526040812080546001600160a01b031916841790557fc47df14ad9309b59073546f93dbe3115ed09c8b206d940f8441ddb07f745b10b9080a3005b611c71915060203d60201161140f57611401818361624e565b846112e9565b60405162461bcd60e51b815260206004820152601d60248201527f43616e6e6f7420736574206164617074657220666f72206e61746976650000006044820152606490fd5b346105dd5760403660031901126105dd57610018600435611cdb616137565b90611ced611ce8826163e9565b616e41565b6176ac565b346105dd575f3660031901126105dd5760206040516276a7008152f35b346105dd575f3660031901126105dd57611d27616716565b335f52600a60205260405f2060018101805460ff8160201c16600381101561148257600203611e28576001600160401b03805f54169160281c166001600160401b0360015460401c16906001600160401b03611d838383616767565b168310611dfe57611dc65f8080808989828254925564010000000064ff0000000019825416179055611db43361941b565b50335af1611dc0617748565b506182c7565b337f120599f8830115ed973189f8f4947cc793fcd90a15d47c4d6ad8d1a3f15af7345f80a260015f80516020619f5c83398151915255005b6001600160401b039291611e1191616767565b90631b04d91d60e21b5f526004521660245260445ffd5b639923c53960e01b5f523360045260245ffd5b5f3660031901126105dd57611e4e616816565b611e56616716565b6105ca617777565b346105dd57611e6c36616300565b335f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260409020549192909160ff1615611ff6576001600160a01b03831615611fbd578115611f87576001600160a01b03165f81815260046020526040902054909290611f42575f838152600660205260409020546001600160a01b0316611efd57610018926183c4565b60405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420726573637565206164617074656420617373657400000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601e60248201527f43616e6e6f7420726573637565207265676973746572656420617373657400006044820152606490fd5b60405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b6044820152606490fd5b60405162461bcd60e51b8152602060048201526011602482015270125b9d985b1a59081c9958da5c1a595b9d607a1b6044820152606490fd5b63e2517d3f60e01b5f52336004525f60245260445ffd5b346105dd5760803660031901126105dd57612026616121565b6064359061ffff821682036105dd575f80516020619f7c833981519152549160ff8360401c1615926001600160401b038116801590816122de575b60011490816122d4575b1590816122cb575b506122bc5767ffffffffffffffff1981166001175f80516020619f7c8339815191525568380000000000000000926121289185612290575b506120b4619689565b6120bc619689565b6120c4619689565b6120cc619689565b60ff195f80516020619f3c83398151915254165f80516020619f3c833981519152556120f6619689565b6120fe619689565b60015f80516020619f5c8339815191525561211881616fcd565b5061212281617064565b5061711d565b50612138604051611b34816161e2565b61ffff600560405161214981616218565b6001815260208101602435815260408201604435815260608301905f825260808401925f845260a085019761271089525f52600260205261219d60405f2095511515869060ff801983541691151516179055565b5160018501555160028401555160038301555160048201550191511661ffff19825416179055600160ff196005541617600555601c600154781c0000000000000000000000000000546000000000000000016001600160401b0360801b4260801b16175f5567ffffffffffffffff60401b199261ffff60801b9060801b169071ffff0000000000000000ffffffffffffffff19161717161760015561223e57005b60ff60401b195f80516020619f7c83398151915254165f80516020619f7c833981519152557fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602060405160018152a1005b68ffffffffffffffffff191668010000000000000001175f80516020619f7c83398151915255856120ab565b63f92ee8a960e01b5f5260045ffd5b90501585612073565b303b15915061206b565b859150612061565b346105dd5760603660031901126105dd576122ff616121565b60443560058110156105dd57612313616816565b61231b616716565b6001600160a01b03821680156119495761233b6105ca93602435906195d0565b9060405190612349826161e2565b600182526020820152619194565b346105dd5760203660031901126105dd576001600160a01b03612378616121565b16805f52600a60205260405f2060ff600182015460201c166003811015611482576123f5576001905491805f526018602052600260405f20015490604051936123c0856161e2565b8452602084019182526001600160401b035f54165f52600e60205260405f20905f5260205260405f2092518355519101555f80f35b60405162461bcd60e51b815260206004820152600a6024820152694e6f742061637469766560b01b6044820152606490fd5b346105dd5760203660031901126105dd5761244061614d565b335f52600a60205260ff600160405f20015460201c16600381101561148257611b0257335f52600c6020526124836001600160401b0360405f2092168092618e16565b50337fb6d5e45d77b8967cff525b375be6e07f99ca5af91d88724ac1237aafe295d50e5f80a3005b346105dd5760403660031901126105dd576124c461614d565b6001600160401b036124d4616137565b91165f52605460205260405f209060018060a01b03165f5260205260206001600160401b0360405f205416604051908152f35b346105dd5760403660031901126105dd57612520616121565b612528616137565b612530616592565b50612539616592565b506001600160a01b0316806125b55750604051612555816161e2565b5f81525f6020820152905b6001600160a01b03165f9081526010602052604090209061258090617267565b5f526020526125b161259460405f206165aa565b604051918291829190916020806040830194805184520151910152565b0390f35b604051906125c2826161e2565b60018252602082015290612560565b346105dd5760403660031901126105dd576125ea61614d565b6001600160401b036125fa616137565b91612603616592565b50165f52600e60205260405f209060018060a01b03165f526020526125b161259460405f206165aa565b346105dd575f3660031901126105dd5760205f5460c01c604051908152f35b346105dd575f3660031901126105dd57602060ff600754166040519015158152f35b346105dd575f3660031901126105dd57612686616716565b61268e618305565b5060015f80516020619f5c83398151915255005b346105dd575f3660031901126105dd5760408051906126c1818361624e565b600582526020820191640352e302e360dc1b83528151928391602083525180918160208501528484015e5f828201840152601f01601f19168101030190f35b346105dd575f3660031901126105dd576020604051670de0b6b3a76400008152f35b346105dd5760203660031901126105dd5761001861273e616121565b612746616d1a565b61761b565b346105dd575f3660031901126105dd5760206040516132c88152f35b346105dd575f3660031901126105dd5760206040517fb1fadd3142ab2ad7f1337ea4d97112bcc8337fc11ce5b20cb04ad038adf998198152f35b346105dd5760403660031901126105dd576127ba616121565b6127c2616163565b905f60c06040516127d281616233565b8281528260208201528260408201528260608201528260808201528260a0820152015260018060a01b03165f5260516020526001600160401b0360405f2091165f5260205260e060405f2060405161282981616233565b8154916001600160401b0383169283835260208301906001600160401b038160401c1682526001600160401b03604085019160801c1681526001600160401b0360018401549160608601928352816002860154946080880195865260c0600460038901549860a08b01998a520154980197885260405198895251166020880152511660408601525160608501525160808401525160a08301525160c0820152f35b346105dd5760603660031901126105dd576128e3616121565b6128eb616163565b506044359061271061290661ffff60015460801c1684616479565b049161293e612915848361646c565b9260018060a01b03811694855f52601a60205261293760405f2091825461666a565b905561901b565b825f52601860205260405f20906001820191825415155f146129ad57670de0b6b3a7640000840293808504670de0b6b3a7640000149015171561099e576129a161299a5f80516020619ebc83398151915295602095549061648c565b825461666a565b90555b604051908152a2005b50602091505f80516020619ebc83398151915292845f52601a83526129d760405f2091825461666a565b90556129a4565b346105dd5760203660031901126105dd576001600160a01b036129ff616121565b16805f52600d60205260405f205490612a1782616677565b91612a25604051938461624e565b808352612a3181616677565b602084019290601f19013684375f5b828110612a94578385604051918291602083019060208452518091526040830191905f5b818110612a72575050500390f35b82516001600160a01b0316845285945060209384019390920191600101612a64565b600190825f52600d602052612aac8160405f20618d4b565b838060a01b0391549060031b1c16612ac482886167c7565b5201612a40565b346105dd575f3660031901126105dd5760206040515f8152f35b346105dd5760c03660031901126105dd57612afe616121565b612b06616163565b612b0e616179565b906064356001600160401b0381116105dd57366023820112156105dd5780600401356001600160401b0381116105dd5736602460608302840101116105dd576020946114de94612b5c616df8565b60a435946024608435950192617d43565b346105dd575f3660031901126105dd57602060405162278d008152f35b346105dd5760403660031901126105dd576105ca612ba6616121565b612bae616816565b612bb6616716565b60243590617cea565b346105dd5760403660031901126105dd57612bd861614d565b6001600160401b03612be8616137565b91165f52605360205260405f209060018060a01b03165f5260205260206001600160401b0360405f205416604051908152f35b346105dd5760203660031901126105dd576001600160a01b03612c3c616121565b165f52605260205260206001600160401b0360405f205416604051908152f35b346105dd5760603660031901126105dd57612c75616121565b612c7d616163565b906044356001600160a01b03811681036105dd576020926114de926164aa565b346105dd5760403660031901126105dd57612cb6616137565b6004355f525f80516020619f1c83398151915260205260405f209060018060a01b03165f52602052602060ff60405f2054166040519015158152f35b346105dd5760a03660031901126105dd5760206114de612d10616121565b612d18616163565b90612d21616179565b612d29616df8565b608435926064359261782c565b61628a565b346105dd5760203660031901126105dd576001600160a01b03612d5c616121565b165f526006602052602060018060a01b0360405f205416604051908152f35b346105dd575f3660031901126105dd5760206001600160401b035f5416604051908152f35b346105dd575f3660031901126105dd57335f52600a602052600160405f200160ff815460201c16600381101561148257611b0257612e219064020000000064ff00000000198254161781556001600160401b035f54166cffffffffffffffff000000000082549160281b16906cffffffffffffffff00000000001916179055565b612e446001600160401b035f54166001600160401b0360015460401c1690616767565b6001600160401b03604051911681527ffd47ed8e653fba5e6e9fcaa947419ca2334b3972ce196132ec69708574d6d35a60203392a2005b346105dd5760403660031901126105dd57600435612e97616163565b90612ea0616816565b335f52601360205260405f205481101561314257335f526013602052612ec98160405f206166e9565b5090600160ff600384015416612ede8161619c565b0361313357335f52601460205260405f20815f5260205260405f208054926001841115613124576001600160401b038516935f1993905f5b8181106130f1575b50505f1984146130de57335f908152601e6020908152604080832085546001600160a01b0316845282528083208884529091528120805491905583545f198101959190861161099e57612f986001600160401b03612f89612f8289612fb69561648c565b9888616e93565b90549060031b1c169286616e93565b81939154906001600160401b03809160031b9316831b921b19161790565b905582548015610ed4575f1901612fcd8185616e93565b6001600160401b0382549160031b1b1916905583555f5b835481101561304c57335f908152601e6020908152604080832086546001600160a01b031684529091529020600191906001600160401b03806130278489616e93565b90549060031b1c16165f5260205260405f2061304487825461666a565b905501612fe4565b868383886040519081527fc38cef0d003bc8a9982db0d994b2ea048946028e9255cc061a56abcbb7d548a160203392a36020546001600160a01b03168061308f57005b81546001600160a01b031690803b156105dd5760025f80946130ca60405197889687958694632d01c5cb60e01b865201903360048601616ed1565b03925af16130d457005b5f6100189161624e565b84633062236b60e11b5f5260045260245ffd5b866001600160401b036131048388616e93565b90549060031b1c161461311957600101612f16565b945087905080612f1e565b63301ac92560e21b5f5260045ffd5b63138dfed560e11b5f5260045ffd5b630b21815d60e11b5f5260045260245ffd5b346105dd575f3660031901126105dd5761316c616d1a565b613174616816565b600160ff195f80516020619f3c8339815191525416175f80516020619f3c833981519152557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b346105dd575f3660031901126105dd576020604051624f1a008152f35b346105dd5760203660031901126105dd576004356001600160a01b03811681036105dd5761268e90613212616716565b617798565b346105dd575f3660031901126105dd576020600854604051908152f35b346105dd5760403660031901126105dd576001600160a01b03613255616121565b165f52601460205260405f206024355f5260205260405f20604051908190602081549384815201905f5260205f20925f935b81600386011061333a57916125b19484926132c4945491818110613320575b818110613303575b8181106132e6575b106132d8575b50038261624e565b6040519182916020835260208301906162c4565b60c01c8152602001856132bc565b9260206001916001600160401b038560801c1681520193016132b6565b9260206001916001600160401b038560401c1681520193016132ae565b9260206001916001600160401b03851681520193016132a6565b916001608060049285546001600160401b03811682526001600160401b038160401c1660208301526001600160401b0381841c16604083015260c01c6060820152019301940193613287565b346105dd5760203660031901126105dd576004358015158091036105dd5760207fe2c375ae70efa82f7f1d8e9555f83f2df5c692d66834ebabba9d897fca46f3df916133d0616d89565b60ff196007541660ff821617600755604051908152a1005b346105dd575f3660031901126105dd57602060ff600554166040519015158152f35b346105dd575f3660031901126105dd5760206040517fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c217758152f35b346105dd5760203660031901126105dd5761345d616121565b613465616d89565b6001600160a01b0316806134c657613482604051611b34816161e2565b60ff19600554166005555b5f52600260205260405f2060ff1981541690557ffc9274ad64ab0a7d8dedd8c9297fb4e25d7a17eb057457c6bcf2a8f13dc8859c5f80a2005b6134d56040516117fc816161e2565b6134de82619370565b5061348d565b346105dd5760203660031901126105dd576134fd616121565b5f60a060405161350c81616218565b8281526020810183905260408101839052606081018390526080810183905201526001600160a01b0316806135d8575061354b604051611b34816161e2565b5f52600260205260c060405f2061ffff60405161356781616218565b60ff8354161515928382526001810154602083019081526002820154604084019081526003830154916060850192835260a0866005600487015496608089019788520154169501948552604051968752516020870152516040860152516060850152516080840152511660a0820152f35b60405161354b916135e8826161e2565b600182526020820152617267565b346105dd5760203660031901126105dd57602061362e6001600160a01b0361361c616121565b165f52600960205260405f2054151590565b6040519015158152f35b346105dd5760203660031901126105dd57610018613654616121565b61365c616d1a565b616f48565b346105dd5760203660031901126105dd5760206114de61367f616121565b616440565b346105dd5760403660031901126105dd5761369d616121565b6136a5616163565b9060018060a01b03165f52601b6020526001600160401b0360405f2091165f526020526020600260405f200154604051908152f35b346105dd575f3660031901126105dd57602060ff5f80516020619f3c83398151915254166040519015158152f35b346105dd5760203660031901126105dd57613721616121565b613729616d89565b6001600160a01b039081165f818152600660205260409020549091161561378b575f81815260066020526040812080546001600160a01b03191690557fdf980d21d8c7bb34800e668dbe003299093bac8e693614151d3c57f73f98a93d9080a2005b60405162461bcd60e51b8152602060048201526015602482015274139bc81859185c1d195c881c9959da5cdd195c9959605a1b6044820152606490fd5b346105dd5760203660031901126105dd576137e1616121565b6001600160a01b03165f9081525f80516020619edc833981519152602090815260409182902054915160ff9092161515825290f35b346105dd5760203660031901126105dd576001600160a01b03613837616121565b165f52601560205260405f2080549061384f82616677565b9161385d604051938461624e565b8083526020830180925f5260205f205f915b83831061390e578486604051918291602083019060208452518091526040830191905f5b8181106138a1575050500390f35b91935091602060e060019260a087518580831b0381511683526138ca85820151868501906161a6565b604081015160608401526001600160401b03606082015116608084015260808101516138f58161619c565b82840152015160c0820152019401910191849392613893565b6005602060019260405161392181616218565b848060a01b038654168152613937858701616795565b838201526002860154604082015260ff60038701546001600160401b038116606084015260401c166139688161619c565b6080820152600486015460a082015281520192019201919061386f565b346105dd575f3660031901126105dd576020604051612ee08152f35b346105dd575f3660031901126105dd577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036139f85760206040515f80516020619e9c8339815191528152f35b63703e46dd60e11b5f5260045ffd5b346105dd575f3660031901126105dd5760206040515f80516020619efc8339815191528152f35b60403660031901126105dd57613a42616121565b602435906001600160401b0382116105dd57366023830112156105dd57816004013590613a6e8261626f565b91613a7c604051938461624e565b808352602083019336602483830101116105dd57815f926024602093018737840101526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016308114908115613c15575b506139f857613ae1616d1a565b6040516352d1902d60e01b81526001600160a01b0382169390602081600481885afa5f9181613be1575b50613b235784634c9c8ce360e01b5f5260045260245ffd5b805f80516020619e9c833981519152869203613bcf5750823b15613bbd575f80516020619e9c83398151915280546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a2825115613ba4575f8091610018945190845af4613b9e617748565b91619dd7565b50505034613bae57005b63b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b632a87526960e21b5f5260045260245ffd5b9091506020813d602011613c0d575b81613bfd6020938361624e565b810103126105dd57519086613b0b565b3d9150613bf0565b5f80516020619e9c833981519152546001600160a01b03161415905084613ad4565b346105dd575f3660031901126105dd5760206001600160401b0360015460401c16604051908152f35b346105dd5760403660031901126105dd57613c79616121565b60243590613c85616816565b613c8d616716565b81156109da5760405191613ca0836161e2565b5f83525f6020840152613cb283617267565b9160018060a01b03811693845f52601860205260405f2060028101549081158015613f61575b15613f35575050825b5f945f5b335f52601360205260405f2054811015613f2a57335f526013602052613d0e8160405f206166e9565b5080546001600160a01b0316891480613f13575b613d2f5750600101613ce5565b929394959650505f90335f52601560205260405f205f918154925b838110613eb45750505050613d6390600183015461646c565b828110613ea95750335f52601560205260405f2092613d9460ff60036001600160401b035f54169401541695616440565b60405191613da183616218565b888352602083019081526040830195858752606084019485526080840197613dc88161619c565b885260a084019283528054600160401b8110156108a157613dee9160018201815561674e565b94909461088e57925184546001600160a01b0319166001600160a01b03919091161784555180515f978a97600495613e389490936107e29160018a01916107bc906107b68161619c565b519101556001600160401b03600194613e588554838160c01c9116616767565b9060405193845260208401521660408201527f06325d83435da87657b063c6142a5b91a66a7e811827d082d624287a9953c4ba60603392a45b156108785760015f80516020619f5c83398151915255005b6108c0869186618ab7565b8a613ebf828561674e565b50546001600160a01b03161480613ef9575b613ede575b600101613d4a565b93613ef16001916002610912888761674e565b949050613ed6565b5081613f0d61093e6001610937858861674e565b14613ed1565b5082613f2461093e60028401616795565b14613d22565b505050505050613e91565b8161097e6001613f4793015487616479565b5f1981019190821161099e57613f5c9161648c565b613ce1565b50600181015415613cd8565b346105dd575f3660031901126105dd57613f85616716565b61268e33617798565b346105dd5760203660031901126105dd576001600160a01b03613faf616121565b165f52600d602052602060405f2054604051908152f35b60203660031901126105dd576105ca613fdd616121565b613fe5616816565b613fed616716565b613ff5617777565b349061683d565b346105dd575f3660031901126105dd576020604051613e808152f35b346105dd575f3660031901126105dd57614030616716565b5f805b335f52601360205260405f205482101561423957335f52601360205261405c8260405f206166e9565b5060ff60038201541661406e8161619c565b614104576140f390600192670de0b6b3a76400006140c385808060a01b03855416940154845f52601860205260405f2094335f52601960205260405f2090888060a01b03165f5260205260405f209454616479565b0482548082115f146140fc576140d9908261646c565b925b5f6140eb8783019586549061666a565b94555561666a565b915b0190614033565b505f926140db565b335f9081526014602090815260408083208684529091528120915490916001600160a01b03909116908190835b815481101561422357956001876001600160401b03614151839a86616e93565b90549060031b1c16855f52601b60205260405f206001600160401b0382165f52602052670de0b6b3a76400006141df60405f20335f52601c60205260405f208a5f5260205260405f206001600160401b0385165f5260205260405f2093335f52601e60205260405f208b5f526020526001600160401b0360405f2091165f5260205260405f20549054616479565b049080548083115f146142175761420b6141fa5f928561646c565b9a5b610a558785019c8d549061666a565b99555501909650614131565b505f61420b819a6141fc565b505050506142339060019261666a565b916140f5565b8061425b575b60209060015f80516020619f5c83398151915255604051908152f35b5f80808084335af161426b617748565b50156142a6576020906040518181527f106f923f993c2149d49b4255ff723acafa1f2d94393f561d3eda32ae348f7241833392a2905061423f565b6312171d8360e31b5f5260045ffd5b346105dd5760203660031901126105dd576004356142d1616816565b335f52600a60205260405f2060ff600182015460201c16600381101561148257611b025781156109da5761430a604051611b34816161e2565b5f526002602052600160405f200154335f52600b60205261433160405f205480935461646c565b8161433c858361646c565b106143d7578361434c818561666a565b6001600160401b03600181805f541660405194614368866161e2565b855260208501908152335f52600b60205260405f20945185555116920191166001600160401b03198254161790557ff7e874d9fd42838b0f06a44c7bbe45417b991e6b000e8ca4c5c1f086084a9cd36143d26116c25f546001600160401b038160c01c9116616767565b0390a2005b836143e19161646c565b906322df051360e11b5f5260045260245260445ffd5b346105dd575f3660031901126105dd5761440f616d1a565b5f80516020619f3c8339815191525460ff8116156144665760ff19165f80516020619f3c833981519152557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b638dfc202b60e01b5f5260045ffd5b346105dd5760803660031901126105dd5761448e616121565b614496616163565b9061449f616179565b506064356127106144b961ffff60015460801c1683616479565b04926144ea6144c8858461646c565b9360018060a01b03811695865f52601a60205261293760405f2091825461666a565b835f52601860205260405f20906001820191825480614602575b5050845f52601b6020526001600160401b0360405f2091165f5260205260405f20906001600160401b035f54166001600160401b036003840191166001600160401b0319825416179055600182015480159283156145b2575b505092602092915f80516020619ebc83398151915294541590816145aa575b5061458c575b50604051908152a2005b845f52601a83526145a260405f2091825461666a565b905584614582565b90508661457c565b9392909491670de0b6b3a7640000830294838604670de0b6b3a7640000148415171561099e576145f561299a5f80516020619ebc8339815191529860209861648c565b905591948193945061455d565b670de0b6b3a76400008602868104670de0b6b3a7640000148715171561099e5761462f9161299a9161648c565b90558580614504565b346105dd5760403660031901126105dd57614651616137565b336001600160a01b0382160361466d57610018906004356176ac565b63334bd91960e11b5f5260045ffd5b346105dd5760803660031901126105dd5760206114de61469a616121565b6146a2616163565b906146ab616df8565b60643591604435916172ae565b346105dd5760a03660031901126105dd576146d1616121565b60243590604435906084359261ffff84168094036105dd577f9a4c59c56153245e23dcb8000e301b9a5e35b8e6693c5cdbf3b6a2aa0f8a37ea92604092614716616d89565b6001600160a01b03169461472b861515616407565b61ffff600561473e8651611342816161e2565b86519061474a82616218565b60018252602082018781528883018781526060840191606435835260808501935f855260a086019889525f5260026020526113aa8b5f2095511515869060ff801983541691151516179055565b346105dd575f3660031901126105dd57602061ffff60015460801c16604051908152f35b346105dd5760203660031901126105dd576001600160a01b036147dc616121565b165f52601360205260405f208054906147f482616677565b91614802604051938461624e565b8083526020830180925f5260205f205f915b838310614897578486604051918291602083019060208452518091526040830191905f5b818110614846575050500390f35b91935091602060a0600192606087518580851b0381511683528481015185840152614879604082015160408501906161a6565b01516148848161619c565b6080820152019401910191849392614838565b600460206001926040516148aa816161c7565b848060a01b03865416815284860154838201526148c960028701616795565b604082015260ff6003870154166148df8161619c565b6060820152815201920192019190614814565b346105dd5760203660031901126105dd576001600160a01b03614913616121565b165f52601a602052602060405f2054604051908152f35b346105dd5760403660031901126105dd57610018600435614949616137565b90614956611ce8826163e9565b6171d6565b346105dd5760203660031901126105dd57614974616121565b61497c6163c5565b506149856163c5565b5060018060a01b03165f52600a60205260405f206001604051916149a8836161c7565b805483520154906020810163ffffffff8316815260ff8360201c16604083019160038210156114825763ffffffff9183526001600160401b03606085019560281c1685526040519351845251166020830152516003811015611482576080926001600160401b0391604084015251166060820152f35b346105dd575f3660031901126105dd57602080546040516001600160a01b039091168152f35b5f3660031901126105dd57614a57616816565b614a5f616716565b614a74335f52600960205260405f2054151590565b61195c57614a87604051611b34816161e2565b5f52600260205260405f2060ff815416156119495760010154803410614b5e57614ab033618d60565b50604051614abd816161c7565b348152602081015f8152604082015f815263ffffffff80600160608601955f8752335f52600a60205260405f2090518155019351161663ffffffff1983541617825551600381101561148257614b1f926118b46001600160401b039284616f23565b6040513481527fbc11617e575d658c74e921c8df22f8e48566072fa78145a6cfe18420bf8d0c4e60203392a260015f80516020619f5c83398151915255005b6322df051360e11b5f526004523460245260445ffd5b346105dd5760203660031901126105dd57614b8d61614d565b335f52600c602052614bad6001600160401b0360405f20921680926194c6565b50337f4b9bbf2ebc79e9fb39a64920934b3f458a486552d3df95395aa750ece9e970935f80a3005b346105dd5760203660031901126105dd576020614bf56004356008618d4b565b905460405160039290921b1c6001600160a01b03168152f35b346105dd5760203660031901126105dd5760206114de6004356163e9565b346105dd5760403660031901126105dd57600435614c48616163565b90614c51616816565b335f52601360205260405f205481101561314257335f526013602052614c7a8160405f206166e9565b5090600160ff600384015416614c8f8161619c565b0361313357335f52601460205260405f20815f5260205260405f205f9080546001600160401b038616925b818110614fb457506001850154906001810180821161099e57614cdd908361648c565b9181614e2b575b5050335f52601e60205260405f2060018060a01b0386541660018060a01b03165f5260205260405f20835f526020528060405f205560018060a01b038554165f52601b60205260405f20835f52602052614d65600260405f209260018401614d4d82825461666a565b8091558181145f14614e055750925b0191825461666a565b90558054600160401b8110156108a157612f988184936001614d8994018155616e93565b90556040519081527fa7b81e017abeb50ecf2c121cb0db7087dfc4b3cc85cd8d857f9a5f1e81f6484560203392a36020546001600160a01b031680614dca57005b81546001600160a01b031690803b156105dd5760025f80946130ca604051978896879586946367b2734d60e01b865201903360048601616ed1565b614e1f614e2592614e198588015482616479565b9261646c565b9061648c565b92614d5c565b91614e3d614e4292829896979461648c565b61646c565b935f5b8354811015614fa757806001600160401b03614e6360019387616e93565b90549060031b1c16335f52601e60205260405f2090838060a01b0388541691848060a01b0383165f5260205260405f206001600160401b0382165f5260205260405f205491828a115f14614f9c57614ebb838061646c565b90335f52601e60205260405f2090868060a01b03165f5260205260405f206001600160401b0383165f5260205260405f2055838060a01b038854165f52601b6020526001600160401b0360405f2091165f5260205260405f208381019081549083821015614f2e575b5050505001614e45565b614f3a8460029361646c565b809355019182549182151580614f93575b15614f8d57614e1f82614f6185614f6795616479565b9261666a565b81811115614f7e5750505f905b5589808080614f24565b614f879161646c565b90614f74565b50614f67565b50801515614f4b565b614ebb8a809461646c565b5092949093508680614ce4565b836001600160401b03614fc78386616e93565b90549060031b1c1614614fdc57600101614cba565b8362d00d2f60e11b5f5260045260245ffd5b346105dd575f3660031901126105dd575f546001600160401b038160801c166150236001600160401b038360401c1682616767565b901515806150c6575b61509d57506001600160401b03615044818316616eb4565b1680916001600160401b0360801b4260801b169077ffffffffffffffff0000000000000000ffffffffffffffff191617175f557f7cee7087baafdfa8f9d1bd39c560782e2eedf861e2648b232a805033537c56955f80a2005b6001600160401b039063274928d560e01b5f52166004526001600160401b03421660245260445ffd5b506001600160401b038116421061502c565b346105dd575f3660031901126105dd576020604051612af88152f35b346105dd5760203660031901126105dd5761510d616121565b5f906001600160a01b0316815b815f52601360205260405f2054831015610a6357815f5260136020526151438360405f206166e9565b5060ff6003820154166151558161619c565b6151e457600191610a556151d192670de0b6b3a76400006151af868060a01b0383541692835f52601860205260405f2093895f52601960205260405f2090898060a01b03165f526020528760405f20945491015490616479565b048154908181115f146151da5786916151c79161646c565b915b01549061666a565b925b019161511a565b5050845f916151c9565b5f8381526014602090815260408083208784529091528120805492549395936001600160a01b03169081905b8484106152245750505050506001906151d3565b60016152d38199610a556001600160401b0361524589879d9a9b9c9d616e93565b90549060031b1c16865f52601b60205260405f206001600160401b0382165f52602052670de0b6b3a76400006151af60405f208b5f52601c60205260405f208b5f5260205260405f206001600160401b0385165f5260205260405f20938c5f52601e60205260405f208c5f526020526001600160401b0360405f2091165f5260205260405f20549054616479565b9501939695949750615210565b346105dd5760403660031901126105dd576152f9616121565b615301616137565b6001600160a01b039182169181165f805b845f52601360205260405f2054821015610a6357845f52601360205261533b8260405f206166e9565b5080546001600160a01b031684900361542a5760ff60038201541661535f8161619c565b61537f57600191610a558361537693015487618ab7565b915b0190615312565b5090845f52601460205260405f20815f5260205260405f205f8154915b8282106153ae57505050600190615378565b919394600161541b8998939597829a5f52601e60205260405f20845f5260205260405f206001600160401b03806153e58a8a616e93565b90549060031b1c16165f52602052610a5560405f20546001600160401b0361540d8a8a616e93565b90549060031b1c1687618d07565b9401919697509492939161539c565b5090600190615378565b346105dd5760403660031901126105dd5761544d616121565b6001600160a01b0361545d616137565b168061558c5750604051615470816161e2565b5f81525f6020820152905b6001600160a01b03165f9081526011602052604090209061549b90617267565b5f5260205260405f208054906154b082616677565b916154be604051938461624e565b8083526020830180925f5260205f205f915b838310615543578486604051918291602083019060208452518091526040830191905f5b818110615502575050500390f35b91935091602060606001926001600160401b03604088518051845261552d868201518786019061618f565b01511660408201520194019101918493926154f4565b60026020600192604051615556816161fd565b855481526001600160401b038587015461557560ff8216868501616e87565b60081c1660408201528152019201920191906154d0565b60405190615599826161e2565b6001825260208201529061547b565b346105dd5760403660031901126105dd576155c1616121565b6155c9616163565b9060018060a01b03165f5260516020526001600160401b0360405f2091165f5260205260e060405f20805490600181015490600281015460046003830154920154926001600160401b03604051958181168752818160401c16602088015260801c1660408601526060850152608084015260a083015260c0820152f35b346105dd5760203660031901126105dd5761565f616121565b615667616d1a565b601f80546001600160a01b0319166001600160a01b0392909216919091179055005b346105dd575f3660031901126105dd5760206001600160401b035f5460801c16604051908152f35b346105dd5760603660031901126105dd576156ca61614d565b6156d2616163565b906156db616179565b906156e4616d1a565b5f54906001600160401b0360c01b9060c01b169060018060c01b0316175f556001600160401b0367ffffffffffffffff60401b6001549260401b169216906fffffffffffffffffffffffffffffffff191617176001555f80f35b346105dd5760203660031901126105dd57615757616121565b61575f6163c5565b506157686163c5565b5060018060a01b03165f526018602052608060405f206001600160401b03604051615792816161c7565b825492838252600181015460208301908152606084600360028501549460408701958652015416930192835260405194855251602085015251604084015251166060820152f35b346105dd5760403660031901126105dd576105ca6157f5616121565b6157fd616816565b615805616716565b6024359061683d565b346105dd5760203660031901126105dd5760043563ffffffff60e01b81168091036105dd57602090637965db0b60e01b8114908115615853575b506040519015158152f35b6301ffc9a760e01b14905082615848565b346105dd575f3660031901126105dd5761587c616716565b5f335f52601560205260405f20905f5b82548110156105ca5761589f818461674e565b50915f546001600160401b03806158c0816003880154168460c01c90616767565b16911610616111576158d761093e60018501616795565b9161590860018060a01b038554166158f3600287015482618ab7565b90615902600488015491616440565b91618af2565b935f5b335f5260136020528560405f20548210156161025750335f5260136020526159368160405f206166e9565b50805483546001600160a01b03908116911614806160eb575b61595c575060010161590b565b93600385979297019660ff885416956159748761619c565b6001871480156160ca57335f52601460205260405f20835f5260205260405f2060405180602083549182815201925f5260205f20905f915b81600384011061607a57936159e89284926159ee965491818110616060575b818110616043575b818110616026575b106160185750038261624e565b9861619c565b8061600e575b615f31575b60018060a01b038554169760ff60028701549a54169761271090615a1f60018901616795565b995f615a2a8261619c565b81615f0a5750615a398c61901b565b8b5f52601860205260405f209c335f52601960205260405f208d60018060a01b03165f5260205260405f209b5f9c5f5b335f52601360205260405f2054811015615ae4578f335f526013602052615a938260405f206166e9565b509060018060a01b038254161480615acc575b615ab4575b50600101615a69565b6001919f82615ac59201549061666a565b9e90615aab565b5060ff600382015416615ade8161619c565b15615aa6565b509d8a9f9e615b68989a9d9f8c9d9f670de0b6b3a764000091615b50919e969798999a9c9e80615ecb575b5f9860018301615b2082825461646c565b90556002830180548a81811115615ebc5750505f905b5580821115615eb357615b489161646c565b905b54616479565b0490555b615b62878585858533619970565b33619aaf565b615b7c60016002880154930192835461646c565b8255335f52601060205260405f20905f52602052600160405f2001615bab81548086115f14615eac578061646c565b90555415615d35575b50615bbe9161666a565b9260018060a01b0382541690600260018060a01b03600185015460081c169301549060405191825260208201527fe4183514c7483039538cd1f9ca20e489b3c411f3af1211cf6b5ad0a00ca4e22860403392a482545f19810190811161099e57615c28908461674e565b50615c33828561674e565b91909161088e57808203615c7f575b505082548015610ed4575f1901615c59818561674e565b61088e576004815f8093558260018201558260028201558260038201550155835561588c565b805482546001600160a01b0319166001600160a01b039190911617825560049081906001808201908501828603615cfd575b505060028101546002850155615cf16003850160ff600384016001600160401b0380825416166001600160401b03198454161783555460401c16906167f3565b01549101558380615c42565b81615d0f60ff615d2e945416836167db565b548154610100600160a81b031916610100600160a81b03909116179055565b8780615cb1565b905060018060a01b038354165f52600a602052600160405f200163ffffffff815416801561099e57815463ffffffff19165f1991820163ffffffff1617909155335f908152601360205260409020805491820191821161099e57615daf91615d9c916166e9565b5091335f52601360205260405f206166e9565b61088e57818103615e3e575b5050335f52601360205260405f209081548015610ed4575f190190615de082846166e9565b92909261088e57615bbe935f600385828b975582600182015582600282015501555560018060a01b03845416615e168133617c67565b15615e23575b5091615bb4565b5f52600d602052615e373360405f206194c6565b5087615e1c565b815481546001600160a01b0319166001600160a01b039190911617815560018083015490820155615e8d9160039060ff9082906002808201908601828703615e94575b505001541691016167db565b8580615dbb565b81615d0f86615ea5945416836167db565b8b80615e81565b859061646c565b50505f90615b4a565b615ec59161646c565b90615b36565b83615ed7828454616479565b0485548082115f14615f0257615eec9161646c565b615efb6001870191825461666a565b9055615b0f565b50505f615eec565b909192939597809d9b8d615f2c615b68989a9d9f849d9f855f918a9333619750565b615b54565b97939692909491615f48600289015488519061648c565b955f5b8851811015615fff57335f908152601e602090815260408083208d546001600160a01b0316808552925290912060019291906001600160401b0380615f90858f6167c7565b5116165f5260205260405f20548a8181115f14615ff05750505f905b335f52601e60205260405f2090848060a01b03165f526020528a6001600160401b0380615fdd8560405f20946167c7565b5116165f5260205260405f205501615f4b565b615ff99161646c565b90615fac565b509193979498909295506159f9565b50865115156159f4565b60c01c81526020015f6132bc565b9260206001916001600160401b038560801c1681520193016159db565b9260206001916001600160401b038560401c1681520193016159d3565b9260206001916001600160401b03851681520193016159cb565b92936001608060049286546001600160401b03811682526001600160401b038160401c1660208301526001600160401b0381841c16604083015260c01c60608201520194019201919392936159ac565b6159ee6020604051906160dd818361624e565b5f8252505f3681379861619c565b50856160fc61093e60028401616795565b1461594f565b91939050615bbe92945061666a565b915061611c90616787565b61588c565b600435906001600160a01b03821682036105dd57565b602435906001600160a01b03821682036105dd57565b600435906001600160401b03821682036105dd57565b602435906001600160401b03821682036105dd57565b604435906001600160401b03821682036105dd57565b9060058210156114825752565b6002111561148257565b60209080516161b48161619c565b83528101516001600160a01b0316910152565b608081019081106001600160401b038211176108a157604052565b604081019081106001600160401b038211176108a157604052565b606081019081106001600160401b038211176108a157604052565b60c081019081106001600160401b038211176108a157604052565b60e081019081106001600160401b038211176108a157604052565b90601f801991011681019081106001600160401b038211176108a157604052565b6001600160401b0381116108a157601f01601f191660200190565b346105dd5760203660031901126105dd576162a3616121565b60018060a01b03165f5260186020526020600260405f200154604051908152f35b90602080835192838152019201905f5b8181106162e15750505090565b82516001600160401b03168452602093840193909201916001016162d4565b60609060031901126105dd576004356001600160a01b03811681036105dd57906024356001600160a01b03811681036105dd579060443590565b9060a06003198301126105dd576004356001600160a01b03811681036105dd57916024356001600160a01b03811681036105dd57916044359160643560028110156105dd57916084356001600160401b0381116105dd57826023820112156105dd578060040135926001600160401b0384116105dd5760248460051b830101116105dd576024019190565b604051906163d2826161c7565b5f6060838281528260208201528260408201520152565b5f525f80516020619f1c833981519152602052600160405f20015490565b1561640e57565b60405162461bcd60e51b815260206004820152600a602482015269557365206e617469766560b01b6044820152606490fd5b6001600160a01b03165f908152600f6020526040902054806164695750670de0b6b3a764000090565b90565b9190820391821161099e57565b8181029291811591840414171561099e57565b8115616496570490565b634e487b7160e01b5f52601260045260245ffd5b929190925f9360018060a01b0382165f5260516020526001600160401b0360405f2091165f5260205260405f2090604051926164e584616233565b82546001600160401b0380821691828752818160401c16602088015260801c166040860152600184015460608601526002840154946080810195865260c0600460038701549660a08401978852015491015215616589579061654691617c67565b918215616581575190519081811161655d57505050565b670de0b6b3a764000093945061657d92916165779161646c565b90616479565b0490565b505f93505050565b505f9450505050565b6040519061659f826161e2565b5f6020838281520152565b906040516165b7816161e2565b602060018294805484520154910152565b156165cf57565b60405162461bcd60e51b815260206004820152600f60248201526e24b73b30b634b21030b230b83a32b960891b6044820152606490fd5b908160209103126105dd575180151581036105dd5790565b1561662557565b60405162461bcd60e51b815260206004820152601d60248201527f4164617074657220646f65736e277420737570706f727420746f6b656e0000006044820152606490fd5b9190820180921161099e57565b6001600160401b0381116108a15760051b60200190565b929161669982616677565b936166a7604051958661624e565b602085848152019260051b81019182116105dd57915b8183106166c957505050565b82356001600160401b03811681036105dd578152602092830192016166bd565b8054821015616702575f5260205f209060021b01905f90565b634e487b7160e01b5f52603260045260245ffd5b60025f80516020619f5c833981519152541461673f5760025f80516020619f5c83398151915255565b633ee5aeb560e01b5f5260045ffd5b8054821015616702575f52600560205f20910201905f90565b906001600160401b03809116911601906001600160401b03821161099e57565b5f19811461099e5760010190565b906040516167a2816161e2565b602081935460ff81166167b48161619c565b835260081c6001600160a01b0316910152565b80518210156167025760209160051b010190565b906167e58161619c565b60ff80198354169116179055565b906167fd8161619c565b60ff60401b82549160401b169060ff60401b1916179055565b60ff5f80516020619f3c833981519152541661682e57565b63d93c066560e01b5f5260045ffd5b6040519161684a836161e2565b5f83525f6020840152602091604051616863848261624e565b5f81525f36813782156109da578051616d0b576001600160a01b0382165f90815260098552604090205415616cea5760018060a01b0382165f52600a8452600160405f20019460ff8654861c16600381101561148257616ccc576168c681617267565b335f526010865260405f20815f52865260405f20928354936168ed6001820154809661646c565b878110616cb557506168ff8787619b60565b9485156109da57876169109161666a565b60018201555f985f805b335f5260138b5260405f2054811015616ca557335f5260138b526169418160405f206166e9565b5080546001600160a01b038b811691161480616c8e575b616965575060010161691a565b91509192939495969798999a5060ff60038201541660025f10156114825761698c8161619c565b616c7f5760010161699e88825461666a565b905560015b616b865750335f526013895260405f2054335f5260138a5260405f206040516169cb816161c7565b6001600160a01b038a1681528b8101898152604082018981529260608301905f82528054600160401b8110156108a157616a0a916001820181556166e9565b93909361088e57616a9c948f600394616a8b9360018060a01b039060018060a01b03905116166bffffffffffffffffffffffff60a01b88541617875551600187015560028601915190616a678251616a618161619c565b846167db565b01518154610100600160a81b03191660089190911b610100600160a81b0316179055565b5191616a968361619c565b016167db565b335f908152601d8b5260408082206001600160a01b038b1683528c52808220928252918b5220805460ff19166001179055805463ffffffff9081169490851461099e576001616b25938a9363ffffffff83616b3199011663ffffffff19825416179055818060a01b038a165f52600d8c52616b1a3360405f20618e16565b505b01549033619bbb565b905f8786868933618b65565b60200151604051938452938301526001600160a01b0392909216915f60408301526001600160a01b03169033907f4fe2fde631e986ee26283901b9cc8d6d4a311b750f9fa0d659520deba2995f1f90606090a4565b9050929192335f5260138952600160ff6003616ba58460405f206166e9565b50015416616bb28161619c565b14616bca575b5086616b3193926001616b2593616b1c565b979491969295939097335f526014865260405f20905f52855260405f209586548015155f14616c7757616bfd908461648c565b975b5f5b8854811015616c6357335f908152601e895260408082206001600160a01b038a1683528a529020600191906001600160401b0380616c3f848e616e93565b90549060031b1c16165f52895260405f20616c5b8c825461666a565b905501616c01565b509598939750939550909390929186616bb8565b505f97616bff565b630abce6af60e41b5f5260045ffd5b5086616c9f61093e60028401616795565b14616958565b50909192939495969798996169a3565b87906312e1fa3760e11b5f5260045260245260445ffd5b6371ab6ad560e11b5f9081526001600160a01b038416600452602490fd5b5063bd62013360e01b5f9081526001600160a01b0391909116600452602490fd5b6310db86df60e21b5f5260045ffd5b335f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c602052604090205460ff1615616d5257565b63e2517d3f60e01b5f52336004527fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c2177560245260445ffd5b335f9081527f5bc841a6d925a620866922bada36d16da3dcc9d52290519ea1126e5ca2372139602052604090205460ff1615616dc157565b63e2517d3f60e01b5f52336004527fb1fadd3142ab2ad7f1337ea4d97112bcc8337fc11ce5b20cb04ad038adf9981960245260445ffd5b335f9081525f80516020619edc833981519152602052604090205460ff1615616e1d57565b63e2517d3f60e01b5f52336004525f80516020619efc83398151915260245260445ffd5b5f8181525f80516020619f1c8339815191526020908152604080832033845290915290205460ff1615616e715750565b63e2517d3f60e01b5f523360045260245260445ffd5b60058210156114825752565b9190918054831015616702575f52601860205f208360021c019260031b1690565b6001600160401b03166001600160401b03811461099e5760010190565b6001600160a01b03918216815291166020820152905460a0820193926080916001600160401b03919060ff8116616f078161619c565b604086015260081c6001600160a01b0316606085015216910152565b9060038110156114825764ff0000000082549160201b169064ff000000001916179055565b6001600160a01b0381165f9081525f80516020619edc833981519152602052604090205460ff16616fc8576001600160a01b03165f8181525f80516020619edc83398151915260205260408120805460ff191660011790553391905f80516020619efc833981519152905f80516020619e7c8339815191529080a4600190565b505f90565b6001600160a01b0381165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff16616fc8576001600160a01b03165f8181527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260408120805460ff191660011790553391905f80516020619e7c8339815191528180a4600190565b6001600160a01b0381165f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c602052604090205460ff16616fc8576001600160a01b03165f8181527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c60205260408120805460ff191660011790553391907fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775905f80516020619e7c8339815191529080a4600190565b6001600160a01b0381165f9081527f5bc841a6d925a620866922bada36d16da3dcc9d52290519ea1126e5ca2372139602052604090205460ff16616fc8576001600160a01b03165f8181527f5bc841a6d925a620866922bada36d16da3dcc9d52290519ea1126e5ca237213960205260408120805460ff191660011790553391907fb1fadd3142ab2ad7f1337ea4d97112bcc8337fc11ce5b20cb04ad038adf99819905f80516020619e7c8339815191529080a4600190565b5f8181525f80516020619f1c833981519152602090815260408083206001600160a01b038616845290915290205460ff16617261575f8181525f80516020619f1c833981519152602090815260408083206001600160a01b0395909516808452949091528120805460ff19166001179055339291905f80516020619e7c8339815191529080a4600190565b50505f90565b8051906172738261619c565b602060018060a01b03910151166040519060208201926172928161619c565b83526040820152604081526172a860608261624e565b51902090565b9093929160018060a01b03821691825f52600a60205260405f20906172de845f52600960205260405f2054151590565b15617608576172ec81618e63565b6175f557835f52601860205260405f2096839761730f600285549201548261666a565b9485156175e85785106175de575b8461732b617330928b616479565b61648c565b9161735761735161734083618ee6565b9461734b8185618f45565b9b61646c565b82618f7e565b986173628a8261666a565b9961736c83618ee6565b9561737c604051611b34816161e2565b5f526002602052600160405f2001548154106175c2575b50875f5260526020528a60405f20998a546001600160401b03169a6173b78c616eb4565b6001600160401b03166001600160401b0319825416179055878a5f546001600160401b031693604051946173ea86616233565b85528d60208601996001600160401b0316998a815260408701915f83526060880193845260808801948d865260a0890196875260c089019788525f52605160205260405f20906001600160401b03165f5260205260405f2096516001600160401b03166001600160401b03166001600160401b0319885416178755516001600160401b031661749c90879067ffffffffffffffff60401b82549160401b169067ffffffffffffffff60401b1916179055565b51855467ffffffffffffffff60801b191660809190911b67ffffffffffffffff60801b16178555516001850155516002840155516003830155519060040155835f52605360205260405f20885f5260205260405f2080546001600160401b031661750590616eb4565b6001600160401b03166001600160401b03198254161790556127108b02918b8304612710148c15171561099e5761758989946175837f1508fbe22c9805770740c8f3827567950022729e0096e311dc087990c157fffc9a7f91754b254153861c1e9bc9186484a0bb770823acfa00423044ba1759a01210e79661648c565b90618fc1565b604080519182526020820192909252908101869052606090a360408051888152602081019290925281019190915280606081015b0390a3565b600101805464ff0000000019166401000000001790555f617393565b939750879361731d565b505f985050505050505050565b8363b516260d60e01b5f5260045260245ffd5b8363bd62013360e01b5f5260045260245ffd5b6001600160a01b0381165f9081525f80516020619edc833981519152602052604090205460ff1615616fc8576001600160a01b03165f8181525f80516020619edc83398151915260205260408120805460ff191690553391905f80516020619efc833981519152907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9080a4600190565b5f8181525f80516020619f1c833981519152602090815260408083206001600160a01b038616845290915290205460ff1615617261575f8181525f80516020619f1c833981519152602090815260408083206001600160a01b0395909516808452949091528120805460ff19169055339291907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9080a4600190565b3d15617772573d906177598261626f565b91617767604051938461624e565b82523d5f602084013e565b606090565b617796604051617786816161e2565b5f81525f6020820152349061906a565b565b6001600160a01b031690811561781d57335f52601a60205260405f205491821561780e575f8080858194338352601a6020528260408120555af16177da617748565b50156142a6576040518281527f106f923f993c2149d49b4255ff723acafa1f2d94393f561d3eda32ae348f724160203392a2565b6373380d9960e01b5f5260045ffd5b63d92e233d60e01b5f5260045ffd5b6001600160a01b0381165f908152600a6020908152604080832060099092529091205494969492939290919015617c47576001600160a01b0381165f908152601860209081526040808320601b83528184206001600160401b038916855290925290912083546002928301549290910154909491906178af9061097e838861666a565b948515617c395789866178f0928161732b9a9b9c9d11617c2f575b816178df614e3d9361732b6178e89487616479565b9a8b9685616479565b93849261646c565b61791861791061790961790287618ee6565b9987618f45565b9386618f7e565b918986619577565b956179278761097e848661666a565b9a8b9961793387618ee6565b97617943604051611b34816161e2565b5f526002602052600160405f200154815410617c13575b506001600160a01b0387165f90815260526020526040902080546001600160401b03169b8c93918a918d9161798e87616eb4565b6001600160401b03166001600160401b03198254161790555f546001600160401b031694604051956179bf87616233565b8652602086019a6001600160401b03169a8b815260408701916001600160401b031697888352606088019384526080880194855260a0880195865260c088019687528d600160a01b60019003165f52605160205260405f20906001600160401b03165f5260205260405f2096516001600160401b03166001600160401b03166001600160401b0319885416178755516001600160401b0316617a8490879067ffffffffffffffff60401b82549160401b169067ffffffffffffffff60401b1916179055565b51855467ffffffffffffffff60801b191660809190911b67ffffffffffffffff60801b16178555516001850155516002840155516003830155519060040155845f52605360205260405f20600160a01b6001900387165f5260205260405f2080546001600160401b0316617af790616eb4565b6001600160401b03166001600160401b03198254161790555f52605460205260405f20600160a01b6001900386165f5260205260405f2080546001600160401b0316617b4290616eb4565b6001600160401b03166001600160401b03198254161790556127108b028b8104612710148c15171561099e577f1508fbe22c9805770740c8f3827567950022729e0096e311dc087990c157fffc977f91754b254153861c1e9bc9186484a0bb770823acfa00423044ba1759a01210e79361097e617bc38a95617bc99561648c565b89618fc1565b6040805194855260208501919091528301526001600160a01b03841691606090a36040805188815260208101959095528401919091526001600160a01b03169180606081016175bd565b600101805464ff0000000019166401000000001790555f61795a565b90915081906178ca565b505050505050509150505f90565b63bd62013360e01b5f9081526001600160a01b0391909116600452602490fd5b90915f925f5b6001600160a01b0384165f81815260136020526040902054821015617ce357805f526013602052617ca18260405f206166e9565b50546001600160a01b03848116911614617cbf575b50600101617c6d565b60019195617cdc915f526013602052826109128860405f206166e9565b9490617cb6565b5050509050565b6001600160a01b0381169081156119495761779692617d08916195d0565b9060405190617d16826161e2565b60018252602082015261906a565b9190811015616702576060020190565b3561ffff811681036105dd5790565b6001600160a01b0381165f908152600a60209081526040808320600990925290912054959897969495909391929190156182a9578815618299576001600160a01b0383165f908152601860209081526040808320601b83528184206001600160401b03871685529092528220865460029283015492909101549892979192885b8d80821061820957505088156181f9578883116181f1575b617de487618ee6565b99617df38161097e878661666a565b156181e0578992918e915f935f975f935f945b86861061815f575050505050505092614f61617e5f617e58617e5186614e3d617e4988617e4061097e9a61732b617e679e61732b9e616479565b9a8b9985616479565b98899261646c565b938a618f45565b9489618f7e565b918789619577565b98617e7184618ee6565b94617e81604051611b34816161e2565b5f526002602052600160405f200154815410618143575b506001600160a01b0384165f90815260526020526040902080546001600160401b03169890617ec68a616eb4565b6001600160401b03166001600160401b03198254161790555f546001600160401b03169060405191617ef783616233565b82528960208301946001600160401b0316948581528d60408501976001600160401b0316978881526060860191825260808601928d845260a08701948c865260c08801968752600160a01b600190038c165f52605160205260405f20906001600160401b03165f5260205260405f2096516001600160401b03166001600160401b03166001600160401b0319885416178755516001600160401b0316617fc090879067ffffffffffffffff60401b82549160401b169067ffffffffffffffff60401b1916179055565b51855467ffffffffffffffff60801b191660809190911b67ffffffffffffffff60801b16178555516001850155516002840155516003830155519060040155815f52605360205260405f20600160a01b6001900385165f5260205260405f2080546001600160401b031661803390616eb4565b6001600160401b03166001600160401b0319825416179055825f52605460205260405f20600160a01b6001900385165f5260205260405f2080546001600160401b031661807f90616eb4565b6001600160401b03166001600160401b03198254161790556127108a02958a8704612710148b15171561099e576180da6180e0917f1508fbe22c9805770740c8f3827567950022729e0096e311dc087990c157fffc9861648c565b85618fc1565b604051908a825260208201527feb0d9b34ef071b87da8591ddd82cc67f90c6806201b5c9ddc91f0624677dc815604060018060a01b03861692a46040805188815260208101959095528401919091526001600160a01b03169180606081016175bd565b600101805464ff0000000019166401000000001790555f617e98565b90919293949596999750618174868884617d24565b60400161818090617d34565b61ffff169961818f8b86616479565b612710900461819d9161666a565b976181a88b85616479565b61271090046181b69161666a565b996181c19086616479565b61271090046181cf9161666a565b94600101939291908e979695617e06565b505f9c505050505050505050505050565b889250617ddb565b505f9b5050505050505050505050565b8161821791849c939c617d24565b80359160028310156105dd578c87866001956182328161619c565b618273579361ffff61825d60406182566127109661097e6182649761826b9b61666a565b9301617d34565b1690616479565b049061666a565b995b01617dc3565b9361ffff61825d60406182566127109661097e618264976182939b61666a565b9961826d565b939450915061646995965061782c565b63bd62013360e01b5f9081526001600160a01b038416600452602490fd5b156182ce57565b60405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b6044820152606490fd5b335f52600b60205260405f209081549182156183be575f546001600160401b036001818316930154169060c01c906001600160401b036183458383616767565b168310611dfe5750505081335f52600a60205260405f2061836782825461646c565b9055335f52600b6020525f60016040822082815501556183905f80808085335af1611dc0617748565b6040519081527fda2b51341079f3dd8e6763a50f329bbc3dc6ca6a51b920fe99fbf89a54ec0e2760203392a2565b505f9150565b60405163a9059cbb60e01b60208201526001600160a01b039290921660248301526044808301939093529181526177969161840060648361624e565b6196b4565b8054821015616702575f52600360205f20910201905f90565b92939291906001600160a01b031680618a9b575060405161843e816161e2565b5f81525f6020820152935b81156109da576184588161619c565b8015948515618a86578451616d0b575b6001600160a01b0384165f8181526009602052604090205490949015618a7357845f52600a602052600160405f20019060ff825460201c16600381101561148257618a60576184b683617267565b96335f52601060205260405f20885f5260205260405f2097600189549901936184e18554809b61646c565b888110618a4957506184f38885619b60565b998a156109da57886185049161666a565b85555f9a5f805b335f52601360205260405f2054811015618a3757335f5260136020526185348160405f206166e9565b5080546001600160a01b03168d1480618a20575b618555575060010161850b565b91509192939495969798809a9b9c9d5060ff6003830154166185768261619c565b61857f8161619c565b03616c7f576001016185928d825461666a565b905560015b6189215750335f9081526013602052604090819020805491519192916185bc816161c7565b8c8152602081018e8152604082018b81529260608301906185dc8e61619c565b8d82528054600160401b8110156108a1576185fc916001820181556166e9565b93909361088e575183546001600160a01b0319166001600160a01b03919091161783559051600183015591518051618649936003929091616a8b9160028601916107bc906107b68161619c565b6186528961619c565b1561873057335f52601d60205260405f208a5f5260205260405f20905f5260205260405f20600160ff198254161790555b63ffffffff8154169163ffffffff831461099e57866186da8a8d936186e1998e839763ffffffff8f9a6001011663ffffffff198254161790555f52600d6020526186d03360405f20618e16565b505b549033619bbb565b9533618b65565b602060018060a01b03910151169360405192835260208301526187038161619c565b60408201527f4fe2fde631e986ee26283901b9cc8d6d4a311b750f9fa0d659520deba2995f1f60603392a4565b9995929794919896939099335f52601460205260405f20905f5260205260405f2088516001600160401b0381116108a157600160401b81116108a15781548183558082106188c7575b5060208a01915f5260205f208160021c915f5b8381106188825750600319811690038061882a575b505089519150508015618822576187b8908761648c565b985b5f5b895181101561881157600190335f52601e60205260405f208a5f526020528a6001600160401b03806187f28460405f20946167c7565b5116165f5260205260405f206188098d825461666a565b9055016187bc565b509194979295999093969850618683565b505f986187ba565b925f935f5b8181106188445750505001555f8080806187a1565b90919460206188786001926001600160401b03895116908560031b6001600160401b03809160031b9316831b921b19161790565b960192910161882f565b5f805b6004811061889a57508382015560010161878c565b86519096916001916020916001600160401b0360068b901b81811b199092169216901b1792019601618885565b825f5260205f20600380840160021c8201920160021c019060188360031b1680618906575b505b8181106188fb5750618779565b5f81556001016188ee565b5f198201908154905f199060200360031b1c1690555f6188ec565b9150509390919293335f526013602052600160ff60036189448460405f206166e9565b500154166189518161619c565b1461896c575b508689866186da836186e19897968b966186d2565b98949197959296939098335f52601460205260405f20905f5260205260405f209687548015155f14618a18576189a2908761648c565b985b5f5b8954811015618a0157600190335f52601e60205260405f208a5f526020528a6001600160401b03806189dc8460405f2094616e93565b90549060031b1c16165f5260205260405f206189f98d825461666a565b9055016189a6565b509599969850939650919490939192919086618957565b505f986189a4565b5085618a3161093e60028401616795565b14618548565b50909192939495969798999a9b618597565b88906312e1fa3760e11b5f5260045260245260445ffd5b856371ab6ad560e11b5f5260045260245ffd5b8463bd62013360e01b5f5260045260245ffd5b845161846857631db6d08b60e11b5f5260045ffd5b60405190618aa8826161e2565b60018252602082015293618449565b6001600160a01b03165f9081526018602052604090206001810154908115618aeb5761646992600261732b92015490616479565b5050505f90565b9181158015618b12575b618b0d5761732b9061646993616479565b505090565b5081811015618afc565b60058110156114825760018114618b5e5760028114618b575760038114618b5057600414618b4a5761271090565b613e8090565b506132c890565b50612ee090565b50612af890565b93969296959195949094618b788261619c565b81618ce957618b868661901b565b60018060a01b03861696875f52601860205260405f209660018060a01b03871696875f52601960205260405f208a5f5260205260405f205f995f5b8a5f52601360205260405f2054811015618c3c578a5f526013602052618bea8160405f206166e9565b5080546001600160a01b03168e1480618c24575b618c0c575b50600101618bc1565b6001919c82618c1d9201549061666a565b9b90618c03565b5060ff600382015416618c368161619c565b15618bfe565b506001989b50670de0b6b3a76400009294969950615b488d618c686177969f618c949597999b9e61646c565b80618cab575b8b8401618c7c83825461666a565b905560028401618c8d8c825461666a565b905561666a565b0490555b618ca6888686868686619970565b619aaf565b85618cb7828654616479565b0487548082115f14618ce157618ccc9161646c565b618cda8d890191825461666a565b9055618c6e565b50505f618ccc565b919484618d02876001866177969c86839a9d989b619750565b618c98565b60018060a01b03165f52601b6020526001600160401b0360405f2091165f5260205260405f206001810154908115618b0d5761646992600261732b92015490616479565b8054821015616702575f5260205f2001905f90565b805f52600960205260405f2054155f14616fc857600854600160401b8110156108a157618daf618d998260018594016008556008618d4b565b819391549060031b91821b915f19901b19161790565b9055600854905f52600960205260405f2055600190565b805f52600460205260405f2054155f14616fc857600354600160401b8110156108a157618dff618d998260018594016003556003618d4b565b9055600354905f52600460205260405f2055600190565b5f82815260018201602052604090205461726157805490600160401b8210156108a15782618e4e618d99846001809601855584618d4b565b90558054925f520160205260405f2055600190565b6001600160a01b03165f818152600c60205260409020805491908215618aeb575f5b838110618e9457505050505f90565b6001600160401b03618ea68284618d4b565b90549060031b1c16835f52601b6020526001600160401b0360405f2091165f52602052600260405f200154618edd57600101618e85565b50505050600190565b6001600160a01b03165f9081526018602052604090206001810154908115618f37576002015490670de0b6b3a7640000820291808304670de0b6b3a7640000149015171561099e576164699161648c565b5050670de0b6b3a764000090565b6001600160a01b03165f908152600a602052604090208054828110618f755750618f7082825461646c565b905590565b5f919392509255565b6001600160a01b03165f908152601860205260409020600201805480158015618fb9575b618aeb57828110618f755750618f7082825461646c565b508215618fa2565b9080158015619010575b61900c57618fd882616440565b906127100390612710821161099e5761271091618ff491616479565b049060018060a01b03165f52600f60205260405f2055565b5050565b506127108111618fcb565b60018060a01b03165f52601860205260405f206001600160401b036003815f5416920191166001600160401b0319825416179055565b8054821015616702575f5260205f209060011b01905f90565b81156109da5761907981617267565b805f52600260205260405f2060ff815416156191705760028101548085106191595750600381015480151580619143575b61912457506004016190bd84825461666a565b9055335f52601060205260405f20905f5260205260405f206190e083825461666a565b9055602001516040519182526001600160a01b0316905f60208201527f754fff2205ca9f1a08ae1f38f487839ba7e18895f0238908ea8b8842d7424fbb60403392a3565b60048592015490634b98504560e01b5f5260045260245260445260645ffd5b508061915386600485015461666a565b116190aa565b8490631e2be21160e01b5f5260045260245260445ffd5b602083015163f6f24b8360e01b5f9081526001600160a01b03909116600452602490fd5b81156109da576191a381617267565b90815f52600260205260405f2060ff8154161561934c5760028101548085106191595750600381015480151580619336575b61912457506004016191e884825461666a565b9055335f52601060205260405f20825f5260205260405f2061920b84825461666a565b905560058410156114825783619268575b6020908101516040519384526001600160a01b03169361924092509083019061618f565b7f754fff2205ca9f1a08ae1f38f487839ba7e18895f0238908ea8b8842d7424fbb60403392a3565b61927184619cff565b61927a84619d8c565b91335f52601160205260405f20905f526020526192a460405f20926001600160401b034316616767565b916040516192b1816161fd565b84815260208101916192c38784616e87565b6001600160401b0360408301951685528054600160401b8110156108a1576192f091600182018155619051565b61088e576001915181550190516005811015611482576192409360ff68ffffffffffffffff008454925160081b1692169068ffffffffffffffffff19161717905561921c565b508061934686600485015461666a565b116191d5565b506020015163f6f24b8360e01b5f9081526001600160a01b03909116600452602490fd5b5f818152600460205260409020548015617261575f19810181811161099e576003545f1981019190821161099e578181036193e3575b5050506003548015610ed4575f19016193c0816003618d4b565b8154905f199060031b1b191690556003555f5260046020525f6040812055600190565b6194056193f4618d99936003618d4b565b90549060031b1c9283926003618d4b565b90555f52600460205260405f20555f80806193a6565b5f818152600960205260409020548015617261575f19810181811161099e576008545f1981019190821161099e5781810361948e575b5050506008548015610ed4575f190161946b816008618d4b565b8154905f199060031b1b191690556008555f5260096020525f6040812055600190565b6194b061949f618d99936008618d4b565b90549060031b1c9283926008618d4b565b90555f52600960205260405f20555f8080619451565b906001820191815f528260205260405f20548015155f1461956f575f19810181811161099e5782545f1981019190821161099e5781810361953a575b50505080548015610ed4575f19019061951b8282618d4b565b8154905f199060031b1b19169055555f526020525f6040812055600190565b61955a61954a618d999386618d4b565b90549060031b1c92839286618d4b565b90555f528360205260405f20555f8080619502565b505050505f90565b60018060a01b03165f52601b6020526001600160401b0360405f2091165f52602052600260405f2001805480158015618fb957618aeb57828110618f755750618f7082825461646c565b908160209103126105dd575190565b6001600160a01b039081165f8181526006602052604090205490911690811561965d57506040516311f9fbc960e21b81523360048201526024810192909252602090829060449082905f905af1908115610d75575f9161962e575090565b90506020813d602011619655575b816196496020938361624e565b810103126105dd575190565b3d915061963c565b905060ff600754166196775781616469913090339061970c565b63f6f24b8360e01b5f5260045260245ffd5b60ff5f80516020619f7c8339815191525460401c16156196a557565b631afcd79f60e31b5f5260045ffd5b905f602091828151910182855af115610d75575f513d61970357506001600160a01b0381163b155b6196e35750565b635274afe760e01b5f9081526001600160a01b0391909116600452602490fd5b600114156196dc565b6040516323b872dd60e01b60208201526001600160a01b0392831660248201529290911660448301526064808301939093529181526177969161840060848361624e565b9594909392918151908115619966576197759161976c9161648c565b9282519061648c565b905f5b815181101561996657806001600160401b03619796600193856167c7565b5116828060a01b0388165f52601b60205260405f206001600160401b0382165f52602052670de0b6b3a76400006198a360405f20858060a01b038d1693845f52601c60205260405f20878060a01b038d165f5260205260405f206001600160401b0382165f5260205260405f20946001600160401b035f54166001600160401b036003850191166001600160401b03198254161790555f52601e60205260405f20878060a01b038d165f526020526001600160401b0360405f2091165f52602052898960405f205491619957575b5080619919575b8a156198cd5786820161987f8b825461666a565b9055600282016198908a825461666a565b90555b898b156198ac57615b489161666a565b04905501619778565b5089808211156198c5576198bf9161646c565b90615b4a565b50505f6198bf565b81870180548b8181111561990a5750505f905b556002820180548a818111156198fb5750505f905b55619893565b6199049161646c565b906198f5565b6199139161646c565b906198e0565b83619925828454616479565b0485548082115f1461994f5761993a9161646c565b61994888870191825461666a565b905561986b565b50505f61993a565b6199609161646c565b89619864565b5050505050509050565b601f545f96929491939192916001600160a01b03909116908115619aa55780516199998161619c565b6199a28161619c565b619a9257505f955b15619a325750601f546001600160a01b031691823b15619a2e576040516316f60ec560e11b81526001600160a01b0394851660048201529484166024860152949092166044840152606483019390935261ffff166084820152908290829060a490829084905af1619a19575050565b619a2482809261624e565b619a2b5750565b80fd5b8680fd5b929194955050813b156105dd5760405162f74bbf60e71b81526001600160a01b039182166004820152928116602484015290931660448201526064810191909152905f908290608490829084905af1619a885750565b5f6177969161624e565b602001516001600160a01b0316956199aa565b5050505050505050565b90929694919460205460018060a01b0316948515619b5557853b156105dd57619b425f98899561ffff93619b159c6040519d8e9c8d9b8c9a6308aec52d60e31b8c5260018060a01b031660048c015260018060a01b031660248b015260448a01906161a6565b6084880152151560a4870152619b2a8161619c565b60c486015261012060e48601526101248501906162c4565b911661010483015203925af1619a885750565b505050505050505050565b6001600160a01b03165f908152601860205260409020600181015480158015619baf575b618b0d57619b97600291619ba094616479565b9101549061648c565b908115619ba957565b60019150565b50600282015415619b84565b9290918115619c74575f925f9460018060a01b03165f52601160205260405f20905f5260205260405f205f908054915b828110619c9a575050508215619c745781808210619c9257619c0c9161646c565b82811015619c8b575b80831115619c8457619c27908361646c565b80821015619c7e575080925b8315619c745761ffff93610a55619c50619c709561732b9461648c565b91619c6b87619c626127109584616479565b9416918661646c565b616479565b1690565b5050505061271090565b92619c33565b505f619c27565b5081619c15565b50505f619c0c565b619ca48183619051565b506001810154436001600160401b038260081c1611619cc8575b5050600101619beb565b97610a55619cf7929861ffff619cef619ce660ff6001989e16618b1c565b9b54809361666a565b9a1690619e35565b96905f619cbe565b90600582101590816114825782158015619d7f575b828115619d6f575b8115619d5f575b8115619d4f575b50619d4a57506114825760ff9063aae758a160e01b5f521660045260245ffd5b915050565b9050611482576004831482619d2a565b9050611482576003831482619d23565b9050611482576002831482619d1c565b505f915060018314619d14565b60058110156114825760018114619dcf5760028114619dc75760038114619dbf57600414619db8575f90565b62ed4e0090565b506276a70090565b50624f1a0090565b5062278d0090565b90619dfb5750805115619dec57805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580619e2c575b619e0c575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b15619e04565b81810291905f5f19838309848082109103818114619e73570360011115619e6157509060019109900390565b634e487b71905260116020526024601cfd5b50505050509056fe2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbce34918ff1c7084970068b53fd71ad6d8b04e9f15d3886cbf006443e6cdc52ea669892194d2f1eb4d48bd09f166bfce1754a681e8e17011b3e12b710cce56a87b12b42e8a160f6064dc959c6f251e3af0750ad213dbecf573b4710d67d6c28e3902dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800cd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033009b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00a164736f6c634300081a000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0\x80`@R4a\0\xE8W0`\x80R\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`\xFF\x81`@\x1C\x16a\0\xD9W`\x02`\x01`@\x1B\x03\x19`\x01`\x01`@\x1B\x03\x82\x16\x01a\0sW[`@Qa\x9F\xA8\x90\x81a\0\xED\x829`\x80Q\x81\x81\x81a9\xB3\x01Ra:\xA9\x01R\xF3[`\x01`\x01`@\x1B\x03\x19\x16`\x01`\x01`@\x1B\x03\x90\x81\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x90\xA1_\x80a\0TV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x1AW[6\x15a\0\x18W_\x80\xFD[\0[_5`\xE0\x1C\x80by\x10\xD0\x14aXdW\x80c\x01\xFF\xC9\xA7\x14aX\x0EW\x80c\x02n@+\x14aW\xD9W\x80c\x03X|\x1D\x14aW>W\x80c\x03x\x02\x11\x14aV\xB1W\x80c\x05\xD6N8\x14aV\x89W\x80c\n\x8D\xDC^\x14aVFW\x80c\n\xA8\xB1\x10\x14aU\xA8W\x80c\x0C\x883\xCE\x14aT4W\x80c\x15\x04\x9AZ\x14aR\xE0W\x80c\x16\x8Fhe\x14aP\xF4W\x80c\x18\x05m\xC2\x14aP\xD8W\x80c\x1B\xA9\x99\x8B\x14aO\xEEW\x80c#\xCC'\0\x14aL,W\x80c$\x8A\x9C\xA3\x14aL\x0EW\x80c&\x14#5\x14aK\xD5W\x80c(\xE7\x0E\xCC\x14aKtW\x80c*\xCD\xE0\x98\x14aJDW\x80c.@\xF7\xFB\x14aJ\x1EW\x80c.\xE6c\xB8\x14aI[W\x80c//\xF1]\x14aI*W\x80c0\"O\xC8\x14aH\xF2W\x80c1\xCC\x13\xBA\x14aG\xBBW\x80c2'?a\x14aG\x97W\x80c5N\xBE\xF9\x14aF\xB8W\x80c5i$\xEA\x14aF|W\x80c6V\x8A\xBE\x14aF8W\x80c=\xCA\xD9\xDB\x14aDuW\x80c?K\xA8:\x14aC\xF7W\x80cD\xAF\xF2R\x14aB\xB5W\x80cD\xD1H\x0B\x14a@\x18W\x80cE>\xCC\xEA\x14a?\xFCW\x80cF\x1C\xC2;\x14a?\xC6W\x80cHc\x98\xC3\x14a?\x8EW\x80cIb\xF8\x8F\x14a\x17\x84W\x80cLN\xDE-\x14a?mW\x80cM\x99\xDD\x16\x14a<`W\x80cM\xE8\xAD\xDC\x14a<7W\x80cN\x9C\x92\x9A\x14a$\xABW\x80cO\x1E\xF2\x86\x14a:.W\x80cP\x95\xAFd\x14a:\x07W\x80cR\xD1\x90-\x14a9\xA1W\x80cT\xDE# \x14a9\x85W\x80cW\"\xD5\x12\x14a8\x16W\x80cW`\x1C]\x14a7\xC8W\x80cX\\\xD3K\x14a7\x08W\x80c\\\x97Z\xBB\x14a6\xDAW\x80c_\xDC\x8F-\x14a6\x84W\x80ca]$\xDE\x14a6aW\x80cf\xC3hu\x14a,\x1BW\x80ch\xA9\xF1\x9C\x14a68W\x80ci}\x08\xF9\x14a-6W\x80cmp\xF7\xAE\x14a5\xF6W\x80cn\xC3\xABg\x14a4\xE4W\x80cp\x80u(\x14a4DW\x80cr\xB5\x03-\x14a+\xBFW\x80cu\xB28\xFC\x14a4\nW\x80cw\xAB,\xF3\x14a3\xE8W\x80c{v\xFE^\x14a3\x86W\x80c{\x99\x96\xC5\x14a24W\x80c|o1X\x14a2\x17W\x80c}iA\xC6\x14a1\xE2W\x80c}\xF9*\xDA\x14a1\xC5W\x80c\x84V\xCBY\x14a1TW\x80c\x85\x9C\xAA\x18\x14a.{W\x80c\x87p5P\x14a-\xA0W\x80c\x8A\x19\xC8\xBC\x14a-{W\x80c\x8A\x7F\xE6\x0F\x14a-;W\x80c\x8C[J\xE7\x14a-6W\x80c\x8Dy]P\x14a,\xF2W\x80c\x91\xD1HT\x14a,\x9DW\x80c\x94\x94\xF4&\x14a,\\W\x80c\x96\x08Vs\x14a,\x1BW\x80c\x97\"\xF4\xB9\x14a+\xBFW\x80c\x97\xFE\xB9&\x14a+\x8AW\x80c\x9E\x87\x05\x85\x14a+mW\x80c\x9E\x8CI\xD4\x14a*\xE5W\x80c\xA2\x17\xFD\xDF\x14a*\xCBW\x80c\xA2\x99\xE2\x98\x14a)\xDEW\x80c\xA3\xB9\xC5\xC2\x14a(\xCAW\x80c\xA4W\xAF=\x14a'\xA1W\x80c\xA4\xB3-\xE8\x14a'gW\x80c\xA7\xFAo\x98\x14a'KW\x80c\xAA\xC6\xAA\x9C\x14a'\"W\x80c\xAA\xF5\xEBh\x14a'\0W\x80c\xAD<\xB1\xCC\x14a&\xA2W\x80c\xB0\xDF\xCE\x06\x14a&nW\x80c\xB3\x9B\xCF?\x14a\x1B[W\x80c\xB5K+\x9E\x14a&LW\x80c\xBA\x05\xBB\xF5\x14a&-W\x80c\xC0tI\xE2\x14a%\xD1W\x80c\xC3P\x82\xA9\x14a%\x07W\x80c\xC5P\xD98\x14a$\xABW\x80c\xC750%\x14a$'W\x80c\xCA\xDDU\x0C\x14a#WW\x80c\xCB\x15\x03\x8B\x14a\"\xE6W\x80c\xCB\xB6\xD6\xBD\x14a \rW\x80c\xCE\xA9\xD2o\x14a\x1E^W\x80c\xD0\xE3\r\xB0\x14a\x1E;W\x80c\xD1sk\xA7\x14a\x1D\x0FW\x80c\xD2zo\x06\x14a\x1C\xF2W\x80c\xD5Gt\x1F\x14a\x1C\xBCW\x80c\xD6U\xB9*\x14a\x1B\x93W\x80c\xD6s\xE0\xB9\x14a\x1B[W\x80c\xD7u\xCBa\x14a\x1B\x15W\x80c\xD9\xE2W\xEF\x14a\x1AqW\x80c\xDB\x8A\x17:\x14a\x1AKW\x80c\xDC\x97,\xCC\x14a\x19\x97W\x80c\xDE\xFE S\x14a\x19oW\x80c\xE0\xA5\x82[\x14a\x17\xA0W\x80c\xE1\xA4R\x18\x14a\x17\x84W\x80c\xE1\xEEK\xCC\x14a\x14\xE6W\x80c\xE4\xE8\x8D\xE8\x14a\x14\x96W\x80c\xEBG53\x14a\x14\x16W\x80c\xF0\xB5+\xB4\x14a\x12!W\x80c\xF3@\xC0\xD0\x14a\x11\x0FW\x80c\xF3\x8C|N\x14a\x10\xC7W\x80c\xF3\xC4\xD8\xA0\x14a\x10BW\x80c\xF3\xC9\xB3\x11\x14a\x10%W\x80c\xF4i\x13\xBB\x14a\x0F\xE8W\x80c\xF7\xCBx\x9A\x14a\x0F\xC0W\x80c\xF8\xFD\x97\x95\x14a\n\xFCW\x80c\xFB\xCC{=\x14a\n\xB9W\x80c\xFB\xECHa\x14a\nnW\x80c\xFC^~\t\x14a\t\xE9W\x80c\xFC\x8A\x91\xAF\x14a\x05\xE1Wc\xFD}=\xBC\x03a\0\x0EW4a\x05\xDDWa\x05\xCAa\x05\xC4a\x05\xA66ac:V[a\x05\xB5\x96\x92\x95\x96\x94\x93\x94ah\x16V[a\x05\xBDag\x16V[6\x91af\x8EV[\x93a\x84\x1EV[`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[_\x80\xFD[4a\x05\xDDWa\x05\xEF6ac\0V[\x90a\x05\xF8ah\x16V[\x81\x15a\t\xDAW`\x01`\x01`\xA0\x1B\x03\x16\x90\x81a\t\xBEW`@Qa\x06\x19\x81aa\xE2V[_\x81R_` \x82\x01R\x91[a\x06-\x83argV[\x92`\x01\x80`\xA0\x1B\x03\x85\x16\x94\x85_R`\x18` R`@_ `\x02\x81\x01T\x90\x81\x15\x80\x15a\t\xB2W[\x15a\tlWPP\x83\x90[_\x95_[3_R`\x13` R`@_ T\x81\x10\x15a\t`W3_R`\x13` Ra\x06\x8A\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x8A\x14\x80a\tIW[a\x06\xABWP`\x01\x01a\x06aV[\x92\x93\x94\x95\x96\x97PP_\x903_R`\x15` R`@_ _\x91\x81T\x92[\x83\x81\x10a\x08\xD5WPPPPa\x06\xE0\x90`\x01\x83\x01TadlV[\x83\x81\x10a\x08\xB5WP3_R`\x15` R`@_ \x93a\x07\x11`\xFF`\x03`\x01`\x01`@\x1B\x03_T\x16\x94\x01T\x16\x93ad@V[\x90`@Q\x92a\x07\x1F\x84ab\x18V[\x89\x84R` \x84\x01\x91\x82R`@\x84\x01\x96\x86\x88R``\x85\x01\x91\x82R`\x80\x85\x01\x95a\x07F\x81aa\x9CV[\x86R`\xA0\x85\x01\x93\x84R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x07l\x91`\x01\x82\x01\x81UagNV[\x95\x90\x95a\x08\x8EW\x93Q\x85T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x85U\x90Q\x80Q\x8A\x97`\x04\x95a\x08\x18\x94\x93\x90\x92a\x07\xE2\x91`\x01\x8A\x01\x91a\x07\xBC\x90a\x07\xB6\x81aa\x9CV[\x83ag\xDBV[` \x01Q\x81Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x90UV[Q`\x02\x87\x01U`\x01`\x01`@\x1B\x03\x80`\x03\x88\x01\x93Q\x16\x16`\x01`\x01`@\x1B\x03\x19\x83T\x16\x17\x82UQ\x90a\x08\x13\x82aa\x9CV[ag\xF3V[Q\x91\x01U`\x01`\x01`@\x1B\x03`\x01\x94a\x088_T\x83\x81`\xC0\x1C\x91\x16aggV[\x90`@Q\x93\x84R` \x84\x01R\x16`@\x82\x01R\x7F\x062]\x83C]\xA8vW\xB0c\xC6\x14*[\x91\xA6j~\x81\x18'\xD0\x82\xD6$(z\x99S\xC4\xBA``3\x92\xA4[\x15a\x08xW\0[c\t\x07\x8C\xFF`\xE2\x1B_R3`\x04R`$R`D_\xFD[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[a\x08\xC0\x87\x91\x84a\x8A\xB7V[c\x88\xC4\xFE\x8F`\xE0\x1B_R`\x04R`$R`D_\xFD[\x8Ba\x08\xE0\x82\x85agNV[PT`\x01`\x01`\xA0\x1B\x03\x16\x14\x80a\t#W[a\x08\xFFW[`\x01\x01a\x06\xC7V[\x93a\t\x1B`\x01\x91`\x02a\t\x12\x88\x87agNV[P\x01T\x90afjV[\x94\x90Pa\x08\xF7V[P\x81a\tCa\t>`\x01a\t7\x85\x88agNV[P\x01ag\x95V[argV[\x14a\x08\xF2V[P\x82a\tZa\t>`\x02\x84\x01ag\x95V[\x14a\x06\x9EV[PPPPPPPa\x08qV[\x81a\t~`\x01a\t\x83\x93\x01T\x88adyV[afjV[_\x19\x81\x01\x91\x90\x82\x11a\t\x9EWa\t\x98\x91ad\x8CV[\x90a\x06]V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[P`\x01\x81\x01T\x15a\x06SV[`@Qa\t\xCA\x81aa\xE2V[`\x01\x81R\x82` \x82\x01R\x91a\x06$V[c\x1F* \x05`\xE0\x1B_R`\x04_\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa\n\x02aa!V[_\x90`\x01`\x01`\xA0\x1B\x03\x16\x81[\x81_R`\x13` R`@_ T\x83\x10\x15a\ncWa\n[`\x01\x91\x83_R`\x13` Ra\nUa\nA\x86`@_ af\xE9V[P\x84\x80\x80`\xA0\x1B\x03\x82T\x16\x91\x01T\x90a\x8A\xB7V[\x90afjV[\x92\x01\x91a\n\x0FV[` \x90`@Q\x90\x81R\xF3[a\x05\xCAa\x05\xC4a\n}6ac:V[a\n\x8C\x96\x92\x95\x96\x94\x93\x94ah\x16V[a\n\x94ag\x16V[`\x01`\x01`\xA0\x1B\x03\x84\x16a\n\xAAWa\x05\xBDawwV[a\n\xB4\x85\x85a|\xEAV[a\x05\xBDV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa\n\xD2aa!V[a\n\xDAam\x1AV[` \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa\x0B\x14ag\x16V[_3_R`\x12` R`@_ \x90_\x90\x82T\x92a\x0B0\x84afwV[a\x0B=`@Q\x91\x82abNV[\x84\x81R`\x1F\x19a\x0BL\x86afwV[\x016` \x83\x017a\x0B\\\x85afwV[\x94a\x0Bj`@Q\x96\x87abNV[\x80\x86R`\x1F\x19a\x0By\x82afwV[\x01_[\x81\x81\x10a\x0F\x9DWPPa\x0B\x8E\x81afwV[\x93a\x0B\x9C`@Q\x95\x86abNV[\x81\x85R`\x1F\x19a\x0B\xAB\x83afwV[\x016` \x87\x017_`\x01`\x01`@\x1B\x03_T\x16\x90`\x01`\x01`@\x1B\x03`\x01T\x16\x90[\x89\x87\x86\x83\x10a\x0E\xF5W\x89\x8B\x91\x89\x83a\r\x9FW[PP_[\x82\x81\x10a\x0B\xFEW`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[a\x0C\x08\x81\x85ag\xC7V[Q\x90a\x0C\x14\x81\x84ag\xC7V[Q\x91\x80Qa\x0C!\x81aa\x9CV[a\x0C*\x81aa\x9CV[a\x0C\xDBWP\x90_\x80\x80\x80\x933Z\xF1a\x0C@awHV[P\x15a\x0C\x9DW`\x01\x90[\x81\x80`\xA0\x1B\x03` a\x0C\\\x83\x88ag\xC7V[Q\x01Q\x16a\x0Cj\x82\x85ag\xC7V[Q`@Q\x90\x81R\x7F\xD1\xC1\x9F\xBC\xD4U\x1A^\xDF\xB6mC\xD2\xE37\xC0H7\xAF\xDA4\x82\xB4+\xDFV\x9A\x8F\xCC\xDA\xE5\xFB` 3\x92\xA3\x01a\x0B\xE4V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01Ru\x13\x98]\x1A]\x99H\x1D\x1C\x98[\x9C\xD9\x99\\\x88\x19\x98Z[\x19Y`R\x1B`D\x82\x01R`d\x90\xFD[` \x90\x81\x01\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x90\x81R`\x06\x90\x93R`@\x90\x92 T\x90\x91\x16\x92\x90\x83\x15a\r\x80WP`@Qc\xF3\xFE\xF3\xA3`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x91\x90\x91R\x91` \x90\x83\x90`D\x90\x82\x90_\x90Z\xF1\x91\x82\x15a\ruW`\x01\x92a\rGW[Pa\x0CJV[a\rg\x90` =\x81\x11a\rnW[a\r_\x81\x83abNV[\x81\x01\x90a\x95\xC1V[P\x85a\rAV[P=a\rUV[`@Q=_\x82>=\x90\xFD[Q`\x01\x93Pa\r\x9A\x91\x903\x90`\x01`\x01`\xA0\x1B\x03\x16a\x83\xC4V[a\x0CJV[\x90\x91\x92\x93_\x94_[\x84T\x81\x10\x15a\x0E\x96Wa\r\xBA\x81\x85ag\xC7V[Q\x15a\r\xC9W[`\x01\x01a\r\xA7V[\x95\x86\x81\x03a\r\xE5W[a\r\xDD`\x01\x91ag\x87V[\x96\x90Pa\r\xC1V[a\r\xEF\x87\x86a\x84\x05V[Pa\r\xFA\x82\x87a\x84\x05V[\x92\x90\x92a\x08\x8EW\x82\x82a\r\xDD\x93`\x01\x95\x14\x15\x80a\x0E\x1DW[PPP\x91PPa\r\xD2V[`\x01`\x01`@\x1B\x03`\x02\x81\x93\x81\x93a\x0EVW[\x88\x81\x01T\x89\x87\x01U\x01T\x16\x92\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x89\x80\x80a\x0E\x12V[a\x0Ed`\xFF\x82T\x16\x87ag\xDBV[\x80T\x86Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x82\x1C`\xA0\x8C\x90\x1B\x8C\x90\x03\x16\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x86Ua\x0E0V[P\x91P\x91\x93\x92[\x84T\x84\x81\x11\x15a\x0E\xE8W\x80\x15a\x0E\xD4W_\x19\x01a\x0E\xBA\x81\x87a\x84\x05V[a\x08\x8EW`\x02\x81_\x80\x93U\x82`\x01\x82\x01U\x01U\x85Ua\x0E\x9DV[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[P\x91\x93P\x91P\x83\x80a\x0B\xE0V[a\x0F\x17\x84`\x01`\x01`@\x1B\x03`\x02a\x0F\x0E\x87\x83\x96a\x84\x05V[P\x01T\x16aggV[\x16\x84\x10\x15a\x0F)W[P`\x01\x01a\x0B\xCDV[a\x0F\x8E\x8A\x95a\x0Fi\x84\x9Ca\x0F\x94\x94a\x0FYa\x0FS\x88\x8F\x8Fa\x0FM`\x01\x9C\x8D\x92ag\xC7V[Ra\x84\x05V[Pag\x95V[a\x0Fc\x83\x83ag\xC7V[Rag\xC7V[P\x83a\x0Fu\x8D\x8Ca\x84\x05V[P\x01Ta\x0F\x82\x88\x8Dag\xC7V[R\x83a\t\x12\x8D\x8Ca\x84\x05V[\x94ag\x87V[\x98\x90P\x89a\x0F V[` \x90`@Qa\x0F\xAC\x81aa\xE2V[_\x81R_\x83\x82\x01R\x82\x82\x8B\x01\x01R\x01a\x0B|V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03_T`@\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a\x10\taa!V[\x16_R`\n` R` `$5`@_ T\x10\x15`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qb\xEDN\0\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045a\xFF\xFF\x81\x16\x80\x82\x03a\x05\xDDWa'\x10\x90a\x10nam\x1AV[\x11a\x10\x94W`\x01\x80Ta\xFF\xFF`\x80\x1B\x19\x16`\x80\x92\x90\x92\x1Ba\xFF\xFF`\x80\x1B\x16\x91\x90\x91\x17\x90U\0[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01RjInvalid BPS`\xA8\x1B`D\x82\x01R`d\x90\xFD[` 6`\x03\x19\x01\x12a\x05\xDDW`\x045`\x05\x81\x10\x15a\x05\xDDWa\x05\xCA\x90a\x10\xEBah\x16V[a\x10\xF3ag\x16V[`@Qa\x10\xFF\x81aa\xE2V[_\x81R_` \x82\x01R4\x90a\x91\x94V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a\x110aa!V[\x16_R`\x12` R`@_ \x80T\x90a\x11H\x82afwV[\x91a\x11V`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x80\x92_R` _ _\x91[\x83\x83\x10a\x11\xDAW\x84\x86`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10a\x11\x9AWPPP\x03\x90\xF3[\x91\x93P\x91` `\x80`\x01\x92`\x01`\x01`@\x1B\x03`@\x88Qa\x11\xBC\x84\x82Qaa\xA6V[\x85\x81\x01Q\x82\x85\x01R\x01Q\x16``\x82\x01R\x01\x94\x01\x91\x01\x91\x84\x93\x92a\x11\x8CV[`\x03` `\x01\x92`@Qa\x11\xED\x81aa\xFDV[a\x11\xF6\x86ag\x95V[\x81R\x84\x86\x01T\x83\x82\x01R`\x01`\x01`@\x1B\x03`\x02\x87\x01T\x16`@\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90a\x11hV[4a\x05\xDDW`\xC06`\x03\x19\x01\x12a\x05\xDDWa\x12:aa!V[a\x12Baa7V[\x90`D5`d5\x90`\xA45\x92a\xFF\xFF\x84\x16\x80\x94\x03a\x05\xDDWa\x12bam\x89V[`\x01`\x01`\xA0\x1B\x03\x16\x93a\x12w\x85\x15\x15ad\x07V[`\x01`\x01`\xA0\x1B\x03\x16\x91a\x12\x8C\x83\x15\x15ae\xC8V[`@QcU\x1CE{`\xE1\x1B\x81R`\x04\x81\x01\x86\x90R\x93` \x85`$\x81\x87Z\xFA\x93\x84\x15a\ruW`\x05a\x13Qa\xFF\xFF\x92a\x12\xEF`@\x98\x7F\x9ALY\xC5aS$^#\xDC\xB8\0\x0E0\x1B\x9A^5\xB8\xE6i<\\\xDB\xF3\xB6\xA2\xAA\x0F\x8A7\xEA\x9A_\x91a\x13\xE7W[Paf\x1EV[\x89_R`\x06` R\x87_ \x81k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x82T\x16\x17\x90U\x87Q\x90\x8A\x7F\xC4}\xF1J\xD90\x9BY\x075F\xF9=\xBE1\x15\xED\t\xC8\xB2\x06\xD9@\xF8D\x1D\xDB\x07\xF7E\xB1\x0B_\x80\xA3a\x13B\x81aa\xE2V[`\x01\x81R\x89` \x82\x01RargV[\x86Q\x90a\x13]\x82ab\x18V[`\x01\x82R` \x82\x01\x87\x81R\x88\x83\x01\x87\x81R``\x84\x01\x91`\x845\x83R`\x80\x85\x01\x93_\x85R`\xA0\x86\x01\x98\x89R_R`\x02` Ra\x13\xAA\x8B_ \x95Q\x15\x15\x86\x90`\xFF\x80\x19\x83T\x16\x91\x15\x15\x16\x17\x90UV[Q`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ`\x04\x82\x01U\x01\x91Q\x16a\xFF\xFF\x19\x82T\x16\x17\x90Ua\x13\xD9\x85a\x8D\xC6V[P\x82Q\x91\x82R` \x82\x01R\xA2\0[a\x14\t\x91P` =` \x11a\x14\x0FW[a\x14\x01\x81\x83abNV[\x81\x01\x90af\x06V[\x8Ca\x12\xE9V[P=a\x13\xF7V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a\x147aa!V[\x16\x80_R`\t` R`@_ T\x15\x15\x80a\x14ZW[` \x90`@Q\x90\x15\x15\x81R\xF3[P_R`\n` R`\xFF`\x01`@_ \x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82W` \x90\x15a\x14MV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDE`\x01`\x01`\xA0\x1B\x03a\x14\xBCaa!V[\x16\x80_R`\n\x83R`@_ T\x90_R`\x18\x83R`\x02`@_ \x01T\x90afjV[`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x14\xFFaa!V[`$5\x90a\x15\x0Bah\x16V[\x81\x15a\t\xDAW`\x01`\x01`\xA0\x1B\x03\x16\x90\x81a\x17iW`@Qa\x15,\x81aa\xE2V[_\x81R_` \x82\x01R[a\x15?\x81argV[3_R`\x10` R`@_ \x81_R` R`@_ \x90\x81T\x90a\x15g`\x01\x84\x01T\x83adlV[\x90_\x903_R`\x11` R`@_ \x90_R` R`@_ _\x90\x80T\x91[\x82\x81\x10a\x17\x1DWPPP\x80\x83\x11\x15a\x17\x16W\x85a\x15\xA3\x82\x85adlV[\x10a\x16\xFFWP\x84\x81\x10a\x16\xE8WP\x83a\x15\xBB\x91adlV[\x90U3_R`\x12` R`@_ `\x01`\x01`@\x1B\x03_T\x16\x90`@Q\x92a\x15\xE2\x84aa\xFDV[\x83R` \x83\x01\x90\x84\x82R`@\x84\x01\x92\x83R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x16\x10\x91`\x01\x82\x01\x81Ua\x84\x05V[\x93\x90\x93a\x08\x8EW`\x01`\x01`@\x1B\x03\x92`\x02\x92a\x16c\x85\x93Qa\x16=\x81Qa\x167\x81aa\x9CV[\x89ag\xDBV[` \x01Q\x87Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x87UV[Q`\x01\x86\x01UQ\x16\x92\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x7F\x91\xEF\xF7\xD3\x9D$\x99\xD7j\xC2\x1A\x19\x03\xA9Z\x88\xF3\x15\x89\xCB\x07\xB1\xFF\xDF\xB6\x1D\xB9\xF7\xCD\x8A9xa\x16\xE3a\x16\xC2`\x01`\x01`@\x1B\x03_T\x16`\x01`\x01`@\x1B\x03`\x01T\x16\x90aggV[`@\x80Q\x94\x85R`\x01`\x01`@\x1B\x03\x90\x91\x16` \x85\x01R3\x93\x91\x82\x91\x82\x01\x90V[\x03\x90\xA3\0[\x84\x90c\xAD\xB9\xE0C`\xE0\x1B_R`\x04R`$R`D_\xFD[\x85\x90c\x8E\xC32\x11`\xE0\x1B_R`\x04R`$R`D_\xFD[\x85_a\x15\xA3V[a\x17'\x81\x83a\x90QV[P`\x01`\x01`@\x1B\x03`\x01C\x92\x01T`\x08\x1C\x16\x11a\x17HW[`\x01\x01a\x15\x86V[\x92a\x17a`\x01\x91a\x17Y\x86\x85a\x90QV[PT\x90afjV[\x93\x90Pa\x17@V[`@Qa\x17u\x81aa\xE2V[`\x01\x81R\x82` \x82\x01Ra\x156V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa'\x10\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x17\xB9aa!V[`$5\x90a\x17\xC5ah\x16V[a\x17\xCDag\x16V[3_R`\t` R`@_ Ta\x19\\W`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\x19IWa\x18\x0B`@Qa\x17\xFC\x81aa\xE2V[`\x01\x81R\x82` \x82\x01RargV[_R`\x02` R`@_ `\xFF\x81T\x16\x15a\x196W`\x01\x83\x91\x01T\x91\x82\x82\x10a\x19\x1FWa\x18<\x92P0\x903\x90a\x97\x0CV[a\x18E3a\x8D`V[P`@Qa\x18R\x81aa\xC7V[\x81\x81R` \x81\x01_\x81R`@\x82\x01_\x81Rc\xFF\xFF\xFF\xFF\x80`\x01``\x86\x01\x95_\x87R3_R`\n` R`@_ \x90Q\x81U\x01\x93Q\x16\x16c\xFF\xFF\xFF\xFF\x19\x83T\x16\x17\x82UQ`\x03\x81\x10\x15a\x14\x82Wa\x18\xE0\x92a\x18\xB4`\x01`\x01`@\x1B\x03\x92\x84ao#V[Q\x82Tl\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x19\x16\x91\x16`(\x1Bl\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x16\x17\x90UV[`@Q\x90\x81R\x7F\xBC\x11a~W]e\x8Ct\xE9!\xC8\xDF\"\xF8\xE4\x85f\x07/\xA7\x81E\xA6\xCF\xE1\x84 \xBF\x8D\x0CN` 3\x92\xA2`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[PPc\"\xDF\x05\x13`\xE1\x1B_R`\x04R`$R`D_\xFD[Pc\xF6\xF2K\x83`\xE0\x1B_R`\x04R`$_\xFD[c\xF6\xF2K\x83`\xE0\x1B_R_`\x04R`$_\xFD[c\x86k\r\xCF`\xE0\x1B_R3`\x04R`$_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW`\x1FT`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a\x19\xB8aa!V[\x16_R`\x0C` R`@_ `@Q\x80` \x83T\x91\x82\x81R\x01\x90\x81\x93_R` _ \x90_[\x81\x81\x10a\x1A5WPPP\x81a\x19\xF3\x91\x03\x82abNV[`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10a\x1A\x1CWPPP\x03\x90\xF3[\x82Q\x84R\x85\x94P` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x1A\x0EV[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a\x19\xDDV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03`\x01T\x16`@Q\x90\x81R\xF3[_6`\x03\x19\x01\x12a\x05\xDDWa\x1A\x84ah\x16V[a\x1A\x8Cag\x16V[3_R`\n` R`@_ `\xFF`\x01\x82\x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x1B\x02W4\x15a\t\xDAWa\x1A\xC14\x82TafjV[\x90U`@Q4\x81R\x7FaJ?\xA8F~\xB5L\xB6\n\xF3\xAA\xB4@'\x987\xC9\xFC\xD7\\Z&\x17\xFE\n\xF9\xC6\xE5\xE6\x0E\x83` 3\x92\xA2`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[cq\xABj\xD5`\xE1\x1B_R3`\x04R`$_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa\x1BB`@Qa\x1B4\x81aa\xE2V[_\x81R_` \x82\x01RargV[_R`\x02` R` `\x01`@_ \x01T`@Q\x90\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDEa\x1Byaa!V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\n` R`@\x90 T\x90V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x1B\xACaa!V[a\x1B\xB4aa7V[\x90a\x1B\xBDam\x89V[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15a\x1CwW`\x01`\x01`\xA0\x1B\x03\x16\x90a\x1B\xE2\x82\x15\x15ae\xC8V[`@QcU\x1CE{`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R` \x81`$\x81\x86Z\xFA\x80\x15a\ruWa\x1C\x15\x91_\x91a\x1CXWPaf\x1EV[_\x81\x81R`\x06` R`@\x81 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x84\x17\x90U\x7F\xC4}\xF1J\xD90\x9BY\x075F\xF9=\xBE1\x15\xED\t\xC8\xB2\x06\xD9@\xF8D\x1D\xDB\x07\xF7E\xB1\x0B\x90\x80\xA3\0[a\x1Cq\x91P` =` \x11a\x14\x0FWa\x14\x01\x81\x83abNV[\x84a\x12\xE9V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FCannot set adapter for native\0\0\0`D\x82\x01R`d\x90\xFD[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\0\x18`\x045a\x1C\xDBaa7V[\x90a\x1C\xEDa\x1C\xE8\x82ac\xE9V[anAV[av\xACV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qbv\xA7\0\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa\x1D'ag\x16V[3_R`\n` R`@_ `\x01\x81\x01\x80T`\xFF\x81` \x1C\x16`\x03\x81\x10\x15a\x14\x82W`\x02\x03a\x1E(W`\x01`\x01`@\x1B\x03\x80_T\x16\x91`(\x1C\x16`\x01`\x01`@\x1B\x03`\x01T`@\x1C\x16\x90`\x01`\x01`@\x1B\x03a\x1D\x83\x83\x83aggV[\x16\x83\x10a\x1D\xFEWa\x1D\xC6_\x80\x80\x80\x89\x89\x82\x82T\x92Ud\x01\0\0\0\0d\xFF\0\0\0\0\x19\x82T\x16\x17\x90Ua\x1D\xB43a\x94\x1BV[P3Z\xF1a\x1D\xC0awHV[Pa\x82\xC7V[3\x7F\x12\x05\x99\xF8\x83\x01\x15\xED\x971\x89\xF8\xF4\x94|\xC7\x93\xFC\xD9\n\x15\xD4|Mj\xD8\xD1\xA3\xF1Z\xF74_\x80\xA2`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[`\x01`\x01`@\x1B\x03\x92\x91a\x1E\x11\x91aggV[\x90c\x1B\x04\xD9\x1D`\xE2\x1B_R`\x04R\x16`$R`D_\xFD[c\x99#\xC59`\xE0\x1B_R3`\x04R`$_\xFD[_6`\x03\x19\x01\x12a\x05\xDDWa\x1ENah\x16V[a\x1EVag\x16V[a\x05\xCAawwV[4a\x05\xDDWa\x1El6ac\0V[3_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T\x91\x92\x90\x91`\xFF\x16\x15a\x1F\xF6W`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x1F\xBDW\x81\x15a\x1F\x87W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R`\x04` R`@\x90 T\x90\x92\x90a\x1FBW_\x83\x81R`\x06` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a\x1E\xFDWa\0\x18\x92a\x83\xC4V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot rescue adapted asset\0\0\0\0\0`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FCannot rescue registered asset\0\0`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x12[\x9D\x98[\x1AY\x08\x18[[\xDD[\x9D`\x92\x1B`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x12[\x9D\x98[\x1AY\x08\x1C\x99X\xDA\\\x1AY[\x9D`z\x1B`D\x82\x01R`d\x90\xFD[c\xE2Q}?`\xE0\x1B_R3`\x04R_`$R`D_\xFD[4a\x05\xDDW`\x806`\x03\x19\x01\x12a\x05\xDDWa &aa!V[`d5\x90a\xFF\xFF\x82\x16\x82\x03a\x05\xDDW_\x80Q` a\x9F|\x839\x81Q\x91RT\x91`\xFF\x83`@\x1C\x16\x15\x92`\x01`\x01`@\x1B\x03\x81\x16\x80\x15\x90\x81a\"\xDEW[`\x01\x14\x90\x81a\"\xD4W[\x15\x90\x81a\"\xCBW[Pa\"\xBCWg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x81\x16`\x01\x17_\x80Q` a\x9F|\x839\x81Q\x91RUh8\0\0\0\0\0\0\0\0\x92a!(\x91\x85a\"\x90W[Pa \xB4a\x96\x89V[a \xBCa\x96\x89V[a \xC4a\x96\x89V[a \xCCa\x96\x89V[`\xFF\x19_\x80Q` a\x9F<\x839\x81Q\x91RT\x16_\x80Q` a\x9F<\x839\x81Q\x91RUa \xF6a\x96\x89V[a \xFEa\x96\x89V[`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RUa!\x18\x81ao\xCDV[Pa!\"\x81apdV[Paq\x1DV[Pa!8`@Qa\x1B4\x81aa\xE2V[a\xFF\xFF`\x05`@Qa!I\x81ab\x18V[`\x01\x81R` \x81\x01`$5\x81R`@\x82\x01`D5\x81R``\x83\x01\x90_\x82R`\x80\x84\x01\x92_\x84R`\xA0\x85\x01\x97a'\x10\x89R_R`\x02` Ra!\x9D`@_ \x95Q\x15\x15\x86\x90`\xFF\x80\x19\x83T\x16\x91\x15\x15\x16\x17\x90UV[Q`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ`\x04\x82\x01U\x01\x91Q\x16a\xFF\xFF\x19\x82T\x16\x17\x90U`\x01`\xFF\x19`\x05T\x16\x17`\x05U`\x1C`\x01Tx\x1C\0\0\0\0\0\0\0\0\0\0\0\0\0\0T`\0\0\0\0\0\0\0\x01`\x01`\x01`@\x1B\x03`\x80\x1BB`\x80\x1B\x16\x17_Ug\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x92a\xFF\xFF`\x80\x1B\x90`\x80\x1B\x16\x90q\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x17\x17\x16\x17`\x01Ua\">W\0[`\xFF`@\x1B\x19_\x80Q` a\x9F|\x839\x81Q\x91RT\x16_\x80Q` a\x9F|\x839\x81Q\x91RU\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2` `@Q`\x01\x81R\xA1\0[h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16h\x01\0\0\0\0\0\0\0\x01\x17_\x80Q` a\x9F|\x839\x81Q\x91RU\x85a \xABV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[\x90P\x15\x85a sV[0;\x15\x91Pa kV[\x85\x91Pa aV[4a\x05\xDDW``6`\x03\x19\x01\x12a\x05\xDDWa\"\xFFaa!V[`D5`\x05\x81\x10\x15a\x05\xDDWa#\x13ah\x16V[a#\x1Bag\x16V[`\x01`\x01`\xA0\x1B\x03\x82\x16\x80\x15a\x19IWa#;a\x05\xCA\x93`$5\x90a\x95\xD0V[\x90`@Q\x90a#I\x82aa\xE2V[`\x01\x82R` \x82\x01Ra\x91\x94V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a#xaa!V[\x16\x80_R`\n` R`@_ `\xFF`\x01\x82\x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa#\xF5W`\x01\x90T\x91\x80_R`\x18` R`\x02`@_ \x01T\x90`@Q\x93a#\xC0\x85aa\xE2V[\x84R` \x84\x01\x91\x82R`\x01`\x01`@\x1B\x03_T\x16_R`\x0E` R`@_ \x90_R` R`@_ \x92Q\x83UQ\x91\x01U_\x80\xF3[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\n`$\x82\x01RiNot active`\xB0\x1B`D\x82\x01R`d\x90\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa$@aaMV[3_R`\n` R`\xFF`\x01`@_ \x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x1B\x02W3_R`\x0C` Ra$\x83`\x01`\x01`@\x1B\x03`@_ \x92\x16\x80\x92a\x8E\x16V[P3\x7F\xB6\xD5\xE4]w\xB8\x96|\xFFR[7[\xE6\xE0\x7F\x99\xCAZ\xF9\x1D\x88rJ\xC1#z\xAF\xE2\x95\xD5\x0E_\x80\xA3\0[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa$\xC4aaMV[`\x01`\x01`@\x1B\x03a$\xD4aa7V[\x91\x16_R`T` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R` `\x01`\x01`@\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa% aa!V[a%(aa7V[a%0ae\x92V[Pa%9ae\x92V[P`\x01`\x01`\xA0\x1B\x03\x16\x80a%\xB5WP`@Qa%U\x81aa\xE2V[_\x81R_` \x82\x01R\x90[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x10` R`@\x90 \x90a%\x80\x90argV[_R` Ra%\xB1a%\x94`@_ ae\xAAV[`@Q\x91\x82\x91\x82\x91\x90\x91` \x80`@\x83\x01\x94\x80Q\x84R\x01Q\x91\x01RV[\x03\x90\xF3[`@Q\x90a%\xC2\x82aa\xE2V[`\x01\x82R` \x82\x01R\x90a%`V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa%\xEAaaMV[`\x01`\x01`@\x1B\x03a%\xFAaa7V[\x91a&\x03ae\x92V[P\x16_R`\x0E` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` Ra%\xB1a%\x94`@_ ae\xAAV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` _T`\xC0\x1C`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\xFF`\x07T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa&\x86ag\x16V[a&\x8Ea\x83\x05V[P`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW`@\x80Q\x90a&\xC1\x81\x83abNV[`\x05\x82R` \x82\x01\x91d\x03R\xE3\x02\xE3`\xDC\x1B\x83R\x81Q\x92\x83\x91` \x83RQ\x80\x91\x81` \x85\x01R\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x81\x01\x03\x01\x90\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qg\r\xE0\xB6\xB3\xA7d\0\0\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa\0\x18a'>aa!V[a'Fam\x1AV[av\x1BV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa2\xC8\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Q\x7F\xB1\xFA\xDD1B\xAB*\xD7\xF13~\xA4\xD9q\x12\xBC\xC83\x7F\xC1\x1C\xE5\xB2\x0C\xB0J\xD08\xAD\xF9\x98\x19\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa'\xBAaa!V[a'\xC2aacV[\x90_`\xC0`@Qa'\xD2\x81ab3V[\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x01R`\x01\x80`\xA0\x1B\x03\x16_R`Q` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`\xE0`@_ `@Qa()\x81ab3V[\x81T\x91`\x01`\x01`@\x1B\x03\x83\x16\x92\x83\x83R` \x83\x01\x90`\x01`\x01`@\x1B\x03\x81`@\x1C\x16\x82R`\x01`\x01`@\x1B\x03`@\x85\x01\x91`\x80\x1C\x16\x81R`\x01`\x01`@\x1B\x03`\x01\x84\x01T\x91``\x86\x01\x92\x83R\x81`\x02\x86\x01T\x94`\x80\x88\x01\x95\x86R`\xC0`\x04`\x03\x89\x01T\x98`\xA0\x8B\x01\x99\x8AR\x01T\x98\x01\x97\x88R`@Q\x98\x89RQ\x16` \x88\x01RQ\x16`@\x86\x01RQ``\x85\x01RQ`\x80\x84\x01RQ`\xA0\x83\x01RQ`\xC0\x82\x01R\xF3[4a\x05\xDDW``6`\x03\x19\x01\x12a\x05\xDDWa(\xE3aa!V[a(\xEBaacV[P`D5\x90a'\x10a)\x06a\xFF\xFF`\x01T`\x80\x1C\x16\x84adyV[\x04\x91a)>a)\x15\x84\x83adlV[\x92`\x01\x80`\xA0\x1B\x03\x81\x16\x94\x85_R`\x1A` Ra)7`@_ \x91\x82TafjV[\x90Ua\x90\x1BV[\x82_R`\x18` R`@_ \x90`\x01\x82\x01\x91\x82T\x15\x15_\x14a)\xADWg\r\xE0\xB6\xB3\xA7d\0\0\x84\x02\x93\x80\x85\x04g\r\xE0\xB6\xB3\xA7d\0\0\x14\x90\x15\x17\x15a\t\x9EWa)\xA1a)\x9A_\x80Q` a\x9E\xBC\x839\x81Q\x91R\x95` \x95T\x90ad\x8CV[\x82TafjV[\x90U[`@Q\x90\x81R\xA2\0[P` \x91P_\x80Q` a\x9E\xBC\x839\x81Q\x91R\x92\x84_R`\x1A\x83Ra)\xD7`@_ \x91\x82TafjV[\x90Ua)\xA4V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a)\xFFaa!V[\x16\x80_R`\r` R`@_ T\x90a*\x17\x82afwV[\x91a*%`@Q\x93\x84abNV[\x80\x83Ra*1\x81afwV[` \x84\x01\x92\x90`\x1F\x19\x016\x847_[\x82\x81\x10a*\x94W\x83\x85`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10a*rWPPP\x03\x90\xF3[\x82Q`\x01`\x01`\xA0\x1B\x03\x16\x84R\x85\x94P` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a*dV[`\x01\x90\x82_R`\r` Ra*\xAC\x81`@_ a\x8DKV[\x83\x80`\xA0\x1B\x03\x91T\x90`\x03\x1B\x1C\x16a*\xC4\x82\x88ag\xC7V[R\x01a*@V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Q_\x81R\xF3[4a\x05\xDDW`\xC06`\x03\x19\x01\x12a\x05\xDDWa*\xFEaa!V[a+\x06aacV[a+\x0EaayV[\x90`d5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xDDW6`#\x82\x01\x12\x15a\x05\xDDW\x80`\x04\x015`\x01`\x01`@\x1B\x03\x81\x11a\x05\xDDW6`$``\x83\x02\x84\x01\x01\x11a\x05\xDDW` \x94a\x14\xDE\x94a+\\am\xF8V[`\xA45\x94`$`\x845\x95\x01\x92a}CV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qb'\x8D\0\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x05\xCAa+\xA6aa!V[a+\xAEah\x16V[a+\xB6ag\x16V[`$5\x90a|\xEAV[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa+\xD8aaMV[`\x01`\x01`@\x1B\x03a+\xE8aa7V[\x91\x16_R`S` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R` `\x01`\x01`@\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a,<aa!V[\x16_R`R` R` `\x01`\x01`@\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW``6`\x03\x19\x01\x12a\x05\xDDWa,uaa!V[a,}aacV[\x90`D5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW` \x92a\x14\xDE\x92ad\xAAV[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa,\xB6aa7V[`\x045_R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW`\xA06`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDEa-\x10aa!V[a-\x18aacV[\x90a-!aayV[a-)am\xF8V[`\x845\x92`d5\x92ax,V[ab\x8AV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a-\\aa!V[\x16_R`\x06` R` `\x01\x80`\xA0\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03_T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW3_R`\n` R`\x01`@_ \x01`\xFF\x81T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x1B\x02Wa.!\x90d\x02\0\0\0\0d\xFF\0\0\0\0\x19\x82T\x16\x17\x81U`\x01`\x01`@\x1B\x03_T\x16l\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x82T\x91`(\x1B\x16\x90l\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x19\x16\x17\x90UV[a.D`\x01`\x01`@\x1B\x03_T\x16`\x01`\x01`@\x1B\x03`\x01T`@\x1C\x16\x90aggV[`\x01`\x01`@\x1B\x03`@Q\x91\x16\x81R\x7F\xFDG\xED\x8Ee?\xBA^n\x9F\xCA\xA9GA\x9C\xA23K9r\xCE\x19a2\xECip\x85t\xD6\xD3Z` 3\x92\xA2\0[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDW`\x045a.\x97aacV[\x90a.\xA0ah\x16V[3_R`\x13` R`@_ T\x81\x10\x15a1BW3_R`\x13` Ra.\xC9\x81`@_ af\xE9V[P\x90`\x01`\xFF`\x03\x84\x01T\x16a.\xDE\x81aa\x9CV[\x03a13W3_R`\x14` R`@_ \x81_R` R`@_ \x80T\x92`\x01\x84\x11\x15a1$W`\x01`\x01`@\x1B\x03\x85\x16\x93_\x19\x93\x90_[\x81\x81\x10a0\xF1W[PP_\x19\x84\x14a0\xDEW3_\x90\x81R`\x1E` \x90\x81R`@\x80\x83 \x85T`\x01`\x01`\xA0\x1B\x03\x16\x84R\x82R\x80\x83 \x88\x84R\x90\x91R\x81 \x80T\x91\x90U\x83T_\x19\x81\x01\x95\x91\x90\x86\x11a\t\x9EWa/\x98`\x01`\x01`@\x1B\x03a/\x89a/\x82\x89a/\xB6\x95ad\x8CV[\x98\x88an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x92\x86an\x93V[\x81\x93\x91T\x90`\x01`\x01`@\x1B\x03\x80\x91`\x03\x1B\x93\x16\x83\x1B\x92\x1B\x19\x16\x17\x90V[\x90U\x82T\x80\x15a\x0E\xD4W_\x19\x01a/\xCD\x81\x85an\x93V[`\x01`\x01`@\x1B\x03\x82T\x91`\x03\x1B\x1B\x19\x16\x90U\x83U_[\x83T\x81\x10\x15a0LW3_\x90\x81R`\x1E` \x90\x81R`@\x80\x83 \x86T`\x01`\x01`\xA0\x1B\x03\x16\x84R\x90\x91R\x90 `\x01\x91\x90`\x01`\x01`@\x1B\x03\x80a0'\x84\x89an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x16_R` R`@_ a0D\x87\x82TafjV[\x90U\x01a/\xE4V[\x86\x83\x83\x88`@Q\x90\x81R\x7F\xC3\x8C\xEF\r\0;\xC8\xA9\x98-\xB0\xD9\x94\xB2\xEA\x04\x89F\x02\x8E\x92U\xCC\x06\x1AV\xAB\xCB\xB7\xD5H\xA1` 3\x92\xA3` T`\x01`\x01`\xA0\x1B\x03\x16\x80a0\x8FW\0[\x81T`\x01`\x01`\xA0\x1B\x03\x16\x90\x80;\x15a\x05\xDDW`\x02_\x80\x94a0\xCA`@Q\x97\x88\x96\x87\x95\x86\x94c-\x01\xC5\xCB`\xE0\x1B\x86R\x01\x903`\x04\x86\x01an\xD1V[\x03\x92Z\xF1a0\xD4W\0[_a\0\x18\x91abNV[\x84c0b#k`\xE1\x1B_R`\x04R`$_\xFD[\x86`\x01`\x01`@\x1B\x03a1\x04\x83\x88an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x14a1\x19W`\x01\x01a/\x16V[\x94P\x87\x90P\x80a/\x1EV[c0\x1A\xC9%`\xE2\x1B_R`\x04_\xFD[c\x13\x8D\xFE\xD5`\xE1\x1B_R`\x04_\xFD[c\x0B!\x81]`\xE1\x1B_R`\x04R`$_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa1lam\x1AV[a1tah\x16V[`\x01`\xFF\x19_\x80Q` a\x9F<\x839\x81Q\x91RT\x16\x17_\x80Q` a\x9F<\x839\x81Q\x91RU\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@QbO\x1A\0\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDWa&\x8E\x90a2\x12ag\x16V[aw\x98V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x08T`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a2Uaa!V[\x16_R`\x14` R`@_ `$5_R` R`@_ `@Q\x90\x81\x90` \x81T\x93\x84\x81R\x01\x90_R` _ \x92_\x93[\x81`\x03\x86\x01\x10a3:W\x91a%\xB1\x94\x84\x92a2\xC4\x94T\x91\x81\x81\x10a3 W[\x81\x81\x10a3\x03W[\x81\x81\x10a2\xE6W[\x10a2\xD8W[P\x03\x82abNV[`@Q\x91\x82\x91` \x83R` \x83\x01\x90ab\xC4V[`\xC0\x1C\x81R` \x01\x85a2\xBCV[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85`\x80\x1C\x16\x81R\x01\x93\x01a2\xB6V[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85`@\x1C\x16\x81R\x01\x93\x01a2\xAEV[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85\x16\x81R\x01\x93\x01a2\xA6V[\x91`\x01`\x80`\x04\x92\x85T`\x01`\x01`@\x1B\x03\x81\x16\x82R`\x01`\x01`@\x1B\x03\x81`@\x1C\x16` \x83\x01R`\x01`\x01`@\x1B\x03\x81\x84\x1C\x16`@\x83\x01R`\xC0\x1C``\x82\x01R\x01\x93\x01\x94\x01\x93a2\x87V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045\x80\x15\x15\x80\x91\x03a\x05\xDDW` \x7F\xE2\xC3u\xAEp\xEF\xA8/\x7F\x1D\x8E\x95U\xF8?-\xF5\xC6\x92\xD6h4\xEB\xAB\xBA\x9D\x89\x7F\xCAF\xF3\xDF\x91a3\xD0am\x89V[`\xFF\x19`\x07T\x16`\xFF\x82\x16\x17`\x07U`@Q\x90\x81R\xA1\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\xFF`\x05T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Q\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa4]aa!V[a4eam\x89V[`\x01`\x01`\xA0\x1B\x03\x16\x80a4\xC6Wa4\x82`@Qa\x1B4\x81aa\xE2V[`\xFF\x19`\x05T\x16`\x05U[_R`\x02` R`@_ `\xFF\x19\x81T\x16\x90U\x7F\xFC\x92t\xADd\xAB\n}\x8D\xED\xD8\xC9)\x7F\xB4\xE2]z\x17\xEB\x05tW\xC6\xBC\xF2\xA8\xF1=\xC8\x85\x9C_\x80\xA2\0[a4\xD5`@Qa\x17\xFC\x81aa\xE2V[a4\xDE\x82a\x93pV[Pa4\x8DV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa4\xFDaa!V[_`\xA0`@Qa5\x0C\x81ab\x18V[\x82\x81R` \x81\x01\x83\x90R`@\x81\x01\x83\x90R``\x81\x01\x83\x90R`\x80\x81\x01\x83\x90R\x01R`\x01`\x01`\xA0\x1B\x03\x16\x80a5\xD8WPa5K`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\xC0`@_ a\xFF\xFF`@Qa5g\x81ab\x18V[`\xFF\x83T\x16\x15\x15\x92\x83\x82R`\x01\x81\x01T` \x83\x01\x90\x81R`\x02\x82\x01T`@\x84\x01\x90\x81R`\x03\x83\x01T\x91``\x85\x01\x92\x83R`\xA0\x86`\x05`\x04\x87\x01T\x96`\x80\x89\x01\x97\x88R\x01T\x16\x95\x01\x94\x85R`@Q\x96\x87RQ` \x87\x01RQ`@\x86\x01RQ``\x85\x01RQ`\x80\x84\x01RQ\x16`\xA0\x82\x01R\xF3[`@Qa5K\x91a5\xE8\x82aa\xE2V[`\x01\x82R` \x82\x01RargV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a6.`\x01`\x01`\xA0\x1B\x03a6\x1Caa!V[\x16_R`\t` R`@_ T\x15\x15\x90V[`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa\0\x18a6Taa!V[a6\\am\x1AV[aoHV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDEa6\x7Faa!V[ad@V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa6\x9Daa!V[a6\xA5aacV[\x90`\x01\x80`\xA0\x1B\x03\x16_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R` `\x02`@_ \x01T`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\xFF_\x80Q` a\x9F<\x839\x81Q\x91RT\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa7!aa!V[a7)am\x89V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x81\x81R`\x06` R`@\x90 T\x90\x91\x16\x15a7\x8BW_\x81\x81R`\x06` R`@\x81 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90U\x7F\xDF\x98\r!\xD8\xC7\xBB4\x80\x0Ef\x8D\xBE\x002\x99\t;\xAC\x8Ei6\x14\x15\x1D<W\xF7?\x98\xA9=\x90\x80\xA2\0[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01Rt\x13\x9B\xC8\x18Y\x18\\\x1D\x19\\\x88\x1C\x99Y\xDA\\\xDD\x19\\\x99Y`Z\x1B`D\x82\x01R`d\x90\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa7\xE1aa!V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` \x90\x81R`@\x91\x82\x90 T\x91Q`\xFF\x90\x92\x16\x15\x15\x82R\x90\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a87aa!V[\x16_R`\x15` R`@_ \x80T\x90a8O\x82afwV[\x91a8]`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x80\x92_R` _ _\x91[\x83\x83\x10a9\x0EW\x84\x86`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10a8\xA1WPPP\x03\x90\xF3[\x91\x93P\x91` `\xE0`\x01\x92`\xA0\x87Q\x85\x80\x83\x1B\x03\x81Q\x16\x83Ra8\xCA\x85\x82\x01Q\x86\x85\x01\x90aa\xA6V[`@\x81\x01Q``\x84\x01R`\x01`\x01`@\x1B\x03``\x82\x01Q\x16`\x80\x84\x01R`\x80\x81\x01Qa8\xF5\x81aa\x9CV[\x82\x84\x01R\x01Q`\xC0\x82\x01R\x01\x94\x01\x91\x01\x91\x84\x93\x92a8\x93V[`\x05` `\x01\x92`@Qa9!\x81ab\x18V[\x84\x80`\xA0\x1B\x03\x86T\x16\x81Ra97\x85\x87\x01ag\x95V[\x83\x82\x01R`\x02\x86\x01T`@\x82\x01R`\xFF`\x03\x87\x01T`\x01`\x01`@\x1B\x03\x81\x16``\x84\x01R`@\x1C\x16a9h\x81aa\x9CV[`\x80\x82\x01R`\x04\x86\x01T`\xA0\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90a8oV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa.\xE0\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x160\x03a9\xF8W` `@Q_\x80Q` a\x9E\x9C\x839\x81Q\x91R\x81R\xF3[cp>F\xDD`\xE1\x1B_R`\x04_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Q_\x80Q` a\x9E\xFC\x839\x81Q\x91R\x81R\xF3[`@6`\x03\x19\x01\x12a\x05\xDDWa:Baa!V[`$5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xDDW6`#\x83\x01\x12\x15a\x05\xDDW\x81`\x04\x015\x90a:n\x82aboV[\x91a:|`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x936`$\x83\x83\x01\x01\x11a\x05\xDDW\x81_\x92`$` \x93\x01\x877\x84\x01\x01R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x81\x14\x90\x81\x15a<\x15W[Pa9\xF8Wa:\xE1am\x1AV[`@QcR\xD1\x90-`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16\x93\x90` \x81`\x04\x81\x88Z\xFA_\x91\x81a;\xE1W[Pa;#W\x84cL\x9C\x8C\xE3`\xE0\x1B_R`\x04R`$_\xFD[\x80_\x80Q` a\x9E\x9C\x839\x81Q\x91R\x86\x92\x03a;\xCFWP\x82;\x15a;\xBDW_\x80Q` a\x9E\x9C\x839\x81Q\x91R\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x82\x17\x90U\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a;\xA4W_\x80\x91a\0\x18\x94Q\x90\x84Z\xF4a;\x9EawHV[\x91a\x9D\xD7V[PPP4a;\xAEW\0[c\xB3\x98\x97\x9F`\xE0\x1B_R`\x04_\xFD[cL\x9C\x8C\xE3`\xE0\x1B_R`\x04R`$_\xFD[c*\x87Ri`\xE2\x1B_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a<\rW[\x81a;\xFD` \x93\x83abNV[\x81\x01\x03\x12a\x05\xDDWQ\x90\x86a;\x0BV[=\x91Pa;\xF0V[_\x80Q` a\x9E\x9C\x839\x81Q\x91RT`\x01`\x01`\xA0\x1B\x03\x16\x14\x15\x90P\x84a:\xD4V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03`\x01T`@\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa<yaa!V[`$5\x90a<\x85ah\x16V[a<\x8Dag\x16V[\x81\x15a\t\xDAW`@Q\x91a<\xA0\x83aa\xE2V[_\x83R_` \x84\x01Ra<\xB2\x83argV[\x91`\x01\x80`\xA0\x1B\x03\x81\x16\x93\x84_R`\x18` R`@_ `\x02\x81\x01T\x90\x81\x15\x80\x15a?aW[\x15a?5WPP\x82[_\x94_[3_R`\x13` R`@_ T\x81\x10\x15a?*W3_R`\x13` Ra=\x0E\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x89\x14\x80a?\x13W[a=/WP`\x01\x01a<\xE5V[\x92\x93\x94\x95\x96PP_\x903_R`\x15` R`@_ _\x91\x81T\x92[\x83\x81\x10a>\xB4WPPPPa=c\x90`\x01\x83\x01TadlV[\x82\x81\x10a>\xA9WP3_R`\x15` R`@_ \x92a=\x94`\xFF`\x03`\x01`\x01`@\x1B\x03_T\x16\x94\x01T\x16\x95ad@V[`@Q\x91a=\xA1\x83ab\x18V[\x88\x83R` \x83\x01\x90\x81R`@\x83\x01\x95\x85\x87R``\x84\x01\x94\x85R`\x80\x84\x01\x97a=\xC8\x81aa\x9CV[\x88R`\xA0\x84\x01\x92\x83R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa=\xEE\x91`\x01\x82\x01\x81UagNV[\x94\x90\x94a\x08\x8EW\x92Q\x84T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x84UQ\x80Q_\x97\x8A\x97`\x04\x95a>8\x94\x90\x93a\x07\xE2\x91`\x01\x8A\x01\x91a\x07\xBC\x90a\x07\xB6\x81aa\x9CV[Q\x91\x01U`\x01`\x01`@\x1B\x03`\x01\x94a>X\x85T\x83\x81`\xC0\x1C\x91\x16aggV[\x90`@Q\x93\x84R` \x84\x01R\x16`@\x82\x01R\x7F\x062]\x83C]\xA8vW\xB0c\xC6\x14*[\x91\xA6j~\x81\x18'\xD0\x82\xD6$(z\x99S\xC4\xBA``3\x92\xA4[\x15a\x08xW`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[a\x08\xC0\x86\x91\x86a\x8A\xB7V[\x8Aa>\xBF\x82\x85agNV[PT`\x01`\x01`\xA0\x1B\x03\x16\x14\x80a>\xF9W[a>\xDEW[`\x01\x01a=JV[\x93a>\xF1`\x01\x91`\x02a\t\x12\x88\x87agNV[\x94\x90Pa>\xD6V[P\x81a?\ra\t>`\x01a\t7\x85\x88agNV[\x14a>\xD1V[P\x82a?$a\t>`\x02\x84\x01ag\x95V[\x14a=\"V[PPPPPPa>\x91V[\x81a\t~`\x01a?G\x93\x01T\x87adyV[_\x19\x81\x01\x91\x90\x82\x11a\t\x9EWa?\\\x91ad\x8CV[a<\xE1V[P`\x01\x81\x01T\x15a<\xD8V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa?\x85ag\x16V[a&\x8E3aw\x98V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a?\xAFaa!V[\x16_R`\r` R` `@_ T`@Q\x90\x81R\xF3[` 6`\x03\x19\x01\x12a\x05\xDDWa\x05\xCAa?\xDDaa!V[a?\xE5ah\x16V[a?\xEDag\x16V[a?\xF5awwV[4\x90ah=V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa>\x80\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa@0ag\x16V[_\x80[3_R`\x13` R`@_ T\x82\x10\x15aB9W3_R`\x13` Ra@\\\x82`@_ af\xE9V[P`\xFF`\x03\x82\x01T\x16a@n\x81aa\x9CV[aA\x04Wa@\xF3\x90`\x01\x92g\r\xE0\xB6\xB3\xA7d\0\0a@\xC3\x85\x80\x80`\xA0\x1B\x03\x85T\x16\x94\x01T\x84_R`\x18` R`@_ \x943_R`\x19` R`@_ \x90\x88\x80`\xA0\x1B\x03\x16_R` R`@_ \x94TadyV[\x04\x82T\x80\x82\x11_\x14a@\xFCWa@\xD9\x90\x82adlV[\x92[_a@\xEB\x87\x83\x01\x95\x86T\x90afjV[\x94UUafjV[\x91[\x01\x90a@3V[P_\x92a@\xDBV[3_\x90\x81R`\x14` \x90\x81R`@\x80\x83 \x86\x84R\x90\x91R\x81 \x91T\x90\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x81\x90\x83[\x81T\x81\x10\x15aB#W\x95`\x01\x87`\x01`\x01`@\x1B\x03aAQ\x83\x9A\x86an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x85_R`\x1B` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` Rg\r\xE0\xB6\xB3\xA7d\0\0aA\xDF`@_ 3_R`\x1C` R`@_ \x8A_R` R`@_ `\x01`\x01`@\x1B\x03\x85\x16_R` R`@_ \x933_R`\x1E` R`@_ \x8B_R` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ T\x90TadyV[\x04\x90\x80T\x80\x83\x11_\x14aB\x17WaB\x0BaA\xFA_\x92\x85adlV[\x9A[a\nU\x87\x85\x01\x9C\x8DT\x90afjV[\x99UU\x01\x90\x96PaA1V[P_aB\x0B\x81\x9AaA\xFCV[PPPPaB3\x90`\x01\x92afjV[\x91a@\xF5V[\x80aB[W[` \x90`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU`@Q\x90\x81R\xF3[_\x80\x80\x80\x843Z\xF1aBkawHV[P\x15aB\xA6W` \x90`@Q\x81\x81R\x7F\x10o\x92?\x99<!I\xD4\x9BBU\xFFr:\xCA\xFA\x1F-\x949?V\x1D>\xDA2\xAE4\x8FrA\x833\x92\xA2\x90PaB?V[c\x12\x17\x1D\x83`\xE3\x1B_R`\x04_\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045aB\xD1ah\x16V[3_R`\n` R`@_ `\xFF`\x01\x82\x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x1B\x02W\x81\x15a\t\xDAWaC\n`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\x01`@_ \x01T3_R`\x0B` RaC1`@_ T\x80\x93TadlV[\x81aC<\x85\x83adlV[\x10aC\xD7W\x83aCL\x81\x85afjV[`\x01`\x01`@\x1B\x03`\x01\x81\x80_T\x16`@Q\x94aCh\x86aa\xE2V[\x85R` \x85\x01\x90\x81R3_R`\x0B` R`@_ \x94Q\x85UQ\x16\x92\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x7F\xF7\xE8t\xD9\xFDB\x83\x8B\x0F\x06\xA4L{\xBEEA{\x99\x1Ek\0\x0E\x8C\xA4\xC5\xC1\xF0\x86\x08J\x9C\xD3aC\xD2a\x16\xC2_T`\x01`\x01`@\x1B\x03\x81`\xC0\x1C\x91\x16aggV[\x03\x90\xA2\0[\x83aC\xE1\x91adlV[\x90c\"\xDF\x05\x13`\xE1\x1B_R`\x04R`$R`D_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWaD\x0Fam\x1AV[_\x80Q` a\x9F<\x839\x81Q\x91RT`\xFF\x81\x16\x15aDfW`\xFF\x19\x16_\x80Q` a\x9F<\x839\x81Q\x91RU\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[c\x8D\xFC +`\xE0\x1B_R`\x04_\xFD[4a\x05\xDDW`\x806`\x03\x19\x01\x12a\x05\xDDWaD\x8Eaa!V[aD\x96aacV[\x90aD\x9FaayV[P`d5a'\x10aD\xB9a\xFF\xFF`\x01T`\x80\x1C\x16\x83adyV[\x04\x92aD\xEAaD\xC8\x85\x84adlV[\x93`\x01\x80`\xA0\x1B\x03\x81\x16\x95\x86_R`\x1A` Ra)7`@_ \x91\x82TafjV[\x83_R`\x18` R`@_ \x90`\x01\x82\x01\x91\x82T\x80aF\x02W[PP\x84_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ \x90`\x01`\x01`@\x1B\x03_T\x16`\x01`\x01`@\x1B\x03`\x03\x84\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U`\x01\x82\x01T\x80\x15\x92\x83\x15aE\xB2W[PP\x92` \x92\x91_\x80Q` a\x9E\xBC\x839\x81Q\x91R\x94T\x15\x90\x81aE\xAAW[PaE\x8CW[P`@Q\x90\x81R\xA2\0[\x84_R`\x1A\x83RaE\xA2`@_ \x91\x82TafjV[\x90U\x84aE\x82V[\x90P\x86aE|V[\x93\x92\x90\x94\x91g\r\xE0\xB6\xB3\xA7d\0\0\x83\x02\x94\x83\x86\x04g\r\xE0\xB6\xB3\xA7d\0\0\x14\x84\x15\x17\x15a\t\x9EWaE\xF5a)\x9A_\x80Q` a\x9E\xBC\x839\x81Q\x91R\x98` \x98ad\x8CV[\x90U\x91\x94\x81\x93\x94PaE]V[g\r\xE0\xB6\xB3\xA7d\0\0\x86\x02\x86\x81\x04g\r\xE0\xB6\xB3\xA7d\0\0\x14\x87\x15\x17\x15a\t\x9EWaF/\x91a)\x9A\x91ad\x8CV[\x90U\x85\x80aE\x04V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWaFQaa7V[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03aFmWa\0\x18\x90`\x045av\xACV[c3K\xD9\x19`\xE1\x1B_R`\x04_\xFD[4a\x05\xDDW`\x806`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDEaF\x9Aaa!V[aF\xA2aacV[\x90aF\xABam\xF8V[`d5\x91`D5\x91ar\xAEV[4a\x05\xDDW`\xA06`\x03\x19\x01\x12a\x05\xDDWaF\xD1aa!V[`$5\x90`D5\x90`\x845\x92a\xFF\xFF\x84\x16\x80\x94\x03a\x05\xDDW\x7F\x9ALY\xC5aS$^#\xDC\xB8\0\x0E0\x1B\x9A^5\xB8\xE6i<\\\xDB\xF3\xB6\xA2\xAA\x0F\x8A7\xEA\x92`@\x92aG\x16am\x89V[`\x01`\x01`\xA0\x1B\x03\x16\x94aG+\x86\x15\x15ad\x07V[a\xFF\xFF`\x05aG>\x86Qa\x13B\x81aa\xE2V[\x86Q\x90aGJ\x82ab\x18V[`\x01\x82R` \x82\x01\x87\x81R\x88\x83\x01\x87\x81R``\x84\x01\x91`d5\x83R`\x80\x85\x01\x93_\x85R`\xA0\x86\x01\x98\x89R_R`\x02` Ra\x13\xAA\x8B_ \x95Q\x15\x15\x86\x90`\xFF\x80\x19\x83T\x16\x91\x15\x15\x16\x17\x90UV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` a\xFF\xFF`\x01T`\x80\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03aG\xDCaa!V[\x16_R`\x13` R`@_ \x80T\x90aG\xF4\x82afwV[\x91aH\x02`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x80\x92_R` _ _\x91[\x83\x83\x10aH\x97W\x84\x86`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10aHFWPPP\x03\x90\xF3[\x91\x93P\x91` `\xA0`\x01\x92``\x87Q\x85\x80\x85\x1B\x03\x81Q\x16\x83R\x84\x81\x01Q\x85\x84\x01RaHy`@\x82\x01Q`@\x85\x01\x90aa\xA6V[\x01QaH\x84\x81aa\x9CV[`\x80\x82\x01R\x01\x94\x01\x91\x01\x91\x84\x93\x92aH8V[`\x04` `\x01\x92`@QaH\xAA\x81aa\xC7V[\x84\x80`\xA0\x1B\x03\x86T\x16\x81R\x84\x86\x01T\x83\x82\x01RaH\xC9`\x02\x87\x01ag\x95V[`@\x82\x01R`\xFF`\x03\x87\x01T\x16aH\xDF\x81aa\x9CV[``\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90aH\x14V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03aI\x13aa!V[\x16_R`\x1A` R` `@_ T`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\0\x18`\x045aIIaa7V[\x90aIVa\x1C\xE8\x82ac\xE9V[aq\xD6V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaItaa!V[aI|ac\xC5V[PaI\x85ac\xC5V[P`\x01\x80`\xA0\x1B\x03\x16_R`\n` R`@_ `\x01`@Q\x91aI\xA8\x83aa\xC7V[\x80T\x83R\x01T\x90` \x81\x01c\xFF\xFF\xFF\xFF\x83\x16\x81R`\xFF\x83` \x1C\x16`@\x83\x01\x91`\x03\x82\x10\x15a\x14\x82Wc\xFF\xFF\xFF\xFF\x91\x83R`\x01`\x01`@\x1B\x03``\x85\x01\x95`(\x1C\x16\x85R`@Q\x93Q\x84RQ\x16` \x83\x01RQ`\x03\x81\x10\x15a\x14\x82W`\x80\x92`\x01`\x01`@\x1B\x03\x91`@\x84\x01RQ\x16``\x82\x01R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` \x80T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R\xF3[_6`\x03\x19\x01\x12a\x05\xDDWaJWah\x16V[aJ_ag\x16V[aJt3_R`\t` R`@_ T\x15\x15\x90V[a\x19\\WaJ\x87`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`@_ `\xFF\x81T\x16\x15a\x19IW`\x01\x01T\x804\x10aK^WaJ\xB03a\x8D`V[P`@QaJ\xBD\x81aa\xC7V[4\x81R` \x81\x01_\x81R`@\x82\x01_\x81Rc\xFF\xFF\xFF\xFF\x80`\x01``\x86\x01\x95_\x87R3_R`\n` R`@_ \x90Q\x81U\x01\x93Q\x16\x16c\xFF\xFF\xFF\xFF\x19\x83T\x16\x17\x82UQ`\x03\x81\x10\x15a\x14\x82WaK\x1F\x92a\x18\xB4`\x01`\x01`@\x1B\x03\x92\x84ao#V[`@Q4\x81R\x7F\xBC\x11a~W]e\x8Ct\xE9!\xC8\xDF\"\xF8\xE4\x85f\x07/\xA7\x81E\xA6\xCF\xE1\x84 \xBF\x8D\x0CN` 3\x92\xA2`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[c\"\xDF\x05\x13`\xE1\x1B_R`\x04R4`$R`D_\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaK\x8DaaMV[3_R`\x0C` RaK\xAD`\x01`\x01`@\x1B\x03`@_ \x92\x16\x80\x92a\x94\xC6V[P3\x7FK\x9B\xBF.\xBCy\xE9\xFB9\xA6I \x93K?E\x8AHeR\xD3\xDF\x959Z\xA7P\xEC\xE9\xE9p\x93_\x80\xA3\0[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` aK\xF5`\x045`\x08a\x8DKV[\x90T`@Q`\x03\x92\x90\x92\x1B\x1C`\x01`\x01`\xA0\x1B\x03\x16\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDE`\x045ac\xE9V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDW`\x045aLHaacV[\x90aLQah\x16V[3_R`\x13` R`@_ T\x81\x10\x15a1BW3_R`\x13` RaLz\x81`@_ af\xE9V[P\x90`\x01`\xFF`\x03\x84\x01T\x16aL\x8F\x81aa\x9CV[\x03a13W3_R`\x14` R`@_ \x81_R` R`@_ _\x90\x80T`\x01`\x01`@\x1B\x03\x86\x16\x92[\x81\x81\x10aO\xB4WP`\x01\x85\x01T\x90`\x01\x81\x01\x80\x82\x11a\t\x9EWaL\xDD\x90\x83ad\x8CV[\x91\x81aN+W[PP3_R`\x1E` R`@_ `\x01\x80`\xA0\x1B\x03\x86T\x16`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x83_R` R\x80`@_ U`\x01\x80`\xA0\x1B\x03\x85T\x16_R`\x1B` R`@_ \x83_R` RaMe`\x02`@_ \x92`\x01\x84\x01aMM\x82\x82TafjV[\x80\x91U\x81\x81\x14_\x14aN\x05WP\x92[\x01\x91\x82TafjV[\x90U\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa/\x98\x81\x84\x93`\x01aM\x89\x94\x01\x81Uan\x93V[\x90U`@Q\x90\x81R\x7F\xA7\xB8\x1E\x01z\xBE\xB5\x0E\xCF,\x12\x1C\xB0\xDBp\x87\xDF\xC4\xB3\xCC\x85\xCD\x8D\x85\x7F\x9A_\x1E\x81\xF6HE` 3\x92\xA3` T`\x01`\x01`\xA0\x1B\x03\x16\x80aM\xCAW\0[\x81T`\x01`\x01`\xA0\x1B\x03\x16\x90\x80;\x15a\x05\xDDW`\x02_\x80\x94a0\xCA`@Q\x97\x88\x96\x87\x95\x86\x94cg\xB2sM`\xE0\x1B\x86R\x01\x903`\x04\x86\x01an\xD1V[aN\x1FaN%\x92aN\x19\x85\x88\x01T\x82adyV[\x92adlV[\x90ad\x8CV[\x92aM\\V[\x91aN=aNB\x92\x82\x98\x96\x97\x94ad\x8CV[adlV[\x93_[\x83T\x81\x10\x15aO\xA7W\x80`\x01`\x01`@\x1B\x03aNc`\x01\x93\x87an\x93V[\x90T\x90`\x03\x1B\x1C\x163_R`\x1E` R`@_ \x90\x83\x80`\xA0\x1B\x03\x88T\x16\x91\x84\x80`\xA0\x1B\x03\x83\x16_R` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` R`@_ T\x91\x82\x8A\x11_\x14aO\x9CWaN\xBB\x83\x80adlV[\x903_R`\x1E` R`@_ \x90\x86\x80`\xA0\x1B\x03\x16_R` R`@_ `\x01`\x01`@\x1B\x03\x83\x16_R` R`@_ U\x83\x80`\xA0\x1B\x03\x88T\x16_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ \x83\x81\x01\x90\x81T\x90\x83\x82\x10\x15aO.W[PPPP\x01aNEV[aO:\x84`\x02\x93adlV[\x80\x93U\x01\x91\x82T\x91\x82\x15\x15\x80aO\x93W[\x15aO\x8DWaN\x1F\x82aOa\x85aOg\x95adyV[\x92afjV[\x81\x81\x11\x15aO~WPP_\x90[U\x89\x80\x80\x80aO$V[aO\x87\x91adlV[\x90aOtV[PaOgV[P\x80\x15\x15aOKV[aN\xBB\x8A\x80\x94adlV[P\x92\x94\x90\x93P\x86\x80aL\xE4V[\x83`\x01`\x01`@\x1B\x03aO\xC7\x83\x86an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x14aO\xDCW`\x01\x01aL\xBAV[\x83b\xD0\r/`\xE1\x1B_R`\x04R`$_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW_T`\x01`\x01`@\x1B\x03\x81`\x80\x1C\x16aP#`\x01`\x01`@\x1B\x03\x83`@\x1C\x16\x82aggV[\x90\x15\x15\x80aP\xC6W[aP\x9DWP`\x01`\x01`@\x1B\x03aPD\x81\x83\x16an\xB4V[\x16\x80\x91`\x01`\x01`@\x1B\x03`\x80\x1BB`\x80\x1B\x16\x90w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x17\x17_U\x7F|\xEEp\x87\xBA\xAF\xDF\xA8\xF9\xD1\xBD9\xC5`x..\xED\xF8a\xE2d\x8B#*\x80P3S|V\x95_\x80\xA2\0[`\x01`\x01`@\x1B\x03\x90c'I(\xD5`\xE0\x1B_R\x16`\x04R`\x01`\x01`@\x1B\x03B\x16`$R`D_\xFD[P`\x01`\x01`@\x1B\x03\x81\x16B\x10aP,V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa*\xF8\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaQ\raa!V[_\x90`\x01`\x01`\xA0\x1B\x03\x16\x81[\x81_R`\x13` R`@_ T\x83\x10\x15a\ncW\x81_R`\x13` RaQC\x83`@_ af\xE9V[P`\xFF`\x03\x82\x01T\x16aQU\x81aa\x9CV[aQ\xE4W`\x01\x91a\nUaQ\xD1\x92g\r\xE0\xB6\xB3\xA7d\0\0aQ\xAF\x86\x80`\xA0\x1B\x03\x83T\x16\x92\x83_R`\x18` R`@_ \x93\x89_R`\x19` R`@_ \x90\x89\x80`\xA0\x1B\x03\x16_R` R\x87`@_ \x94T\x91\x01T\x90adyV[\x04\x81T\x90\x81\x81\x11_\x14aQ\xDAW\x86\x91aQ\xC7\x91adlV[\x91[\x01T\x90afjV[\x92[\x01\x91aQ\x1AV[PP\x84_\x91aQ\xC9V[_\x83\x81R`\x14` \x90\x81R`@\x80\x83 \x87\x84R\x90\x91R\x81 \x80T\x92T\x93\x95\x93`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x90[\x84\x84\x10aR$WPPPPP`\x01\x90aQ\xD3V[`\x01aR\xD3\x81\x99a\nU`\x01`\x01`@\x1B\x03aRE\x89\x87\x9D\x9A\x9B\x9C\x9Dan\x93V[\x90T\x90`\x03\x1B\x1C\x16\x86_R`\x1B` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` Rg\r\xE0\xB6\xB3\xA7d\0\0aQ\xAF`@_ \x8B_R`\x1C` R`@_ \x8B_R` R`@_ `\x01`\x01`@\x1B\x03\x85\x16_R` R`@_ \x93\x8C_R`\x1E` R`@_ \x8C_R` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ T\x90TadyV[\x95\x01\x93\x96\x95\x94\x97PaR\x10V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWaR\xF9aa!V[aS\x01aa7V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x81\x16_\x80[\x84_R`\x13` R`@_ T\x82\x10\x15a\ncW\x84_R`\x13` RaS;\x82`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x84\x90\x03aT*W`\xFF`\x03\x82\x01T\x16aS_\x81aa\x9CV[aS\x7FW`\x01\x91a\nU\x83aSv\x93\x01T\x87a\x8A\xB7V[\x91[\x01\x90aS\x12V[P\x90\x84_R`\x14` R`@_ \x81_R` R`@_ _\x81T\x91[\x82\x82\x10aS\xAEWPPP`\x01\x90aSxV[\x91\x93\x94`\x01aT\x1B\x89\x98\x93\x95\x97\x82\x9A_R`\x1E` R`@_ \x84_R` R`@_ `\x01`\x01`@\x1B\x03\x80aS\xE5\x8A\x8Aan\x93V[\x90T\x90`\x03\x1B\x1C\x16\x16_R` Ra\nU`@_ T`\x01`\x01`@\x1B\x03aT\r\x8A\x8Aan\x93V[\x90T\x90`\x03\x1B\x1C\x16\x87a\x8D\x07V[\x94\x01\x91\x96\x97P\x94\x92\x93\x91aS\x9CV[P\x90`\x01\x90aSxV[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWaTMaa!V[`\x01`\x01`\xA0\x1B\x03aT]aa7V[\x16\x80aU\x8CWP`@QaTp\x81aa\xE2V[_\x81R_` \x82\x01R\x90[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x11` R`@\x90 \x90aT\x9B\x90argV[_R` R`@_ \x80T\x90aT\xB0\x82afwV[\x91aT\xBE`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x80\x92_R` _ _\x91[\x83\x83\x10aUCW\x84\x86`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10aU\x02WPPP\x03\x90\xF3[\x91\x93P\x91` ```\x01\x92`\x01`\x01`@\x1B\x03`@\x88Q\x80Q\x84RaU-\x86\x82\x01Q\x87\x86\x01\x90aa\x8FV[\x01Q\x16`@\x82\x01R\x01\x94\x01\x91\x01\x91\x84\x93\x92aT\xF4V[`\x02` `\x01\x92`@QaUV\x81aa\xFDV[\x85T\x81R`\x01`\x01`@\x1B\x03\x85\x87\x01TaUu`\xFF\x82\x16\x86\x85\x01an\x87V[`\x08\x1C\x16`@\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90aT\xD0V[`@Q\x90aU\x99\x82aa\xE2V[`\x01\x82R` \x82\x01R\x90aT{V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWaU\xC1aa!V[aU\xC9aacV[\x90`\x01\x80`\xA0\x1B\x03\x16_R`Q` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`\xE0`@_ \x80T\x90`\x01\x81\x01T\x90`\x02\x81\x01T`\x04`\x03\x83\x01T\x92\x01T\x92`\x01`\x01`@\x1B\x03`@Q\x95\x81\x81\x16\x87R\x81\x81`@\x1C\x16` \x88\x01R`\x80\x1C\x16`@\x86\x01R``\x85\x01R`\x80\x84\x01R`\xA0\x83\x01R`\xC0\x82\x01R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaV_aa!V[aVgam\x1AV[`\x1F\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03_T`\x80\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xDDW``6`\x03\x19\x01\x12a\x05\xDDWaV\xCAaaMV[aV\xD2aacV[\x90aV\xDBaayV[\x90aV\xE4am\x1AV[_T\x90`\x01`\x01`@\x1B\x03`\xC0\x1B\x90`\xC0\x1B\x16\x90`\x01\x80`\xC0\x1B\x03\x16\x17_U`\x01`\x01`@\x1B\x03g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B`\x01T\x92`@\x1B\x16\x92\x16\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x17\x17`\x01U_\x80\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaWWaa!V[aW_ac\xC5V[PaWhac\xC5V[P`\x01\x80`\xA0\x1B\x03\x16_R`\x18` R`\x80`@_ `\x01`\x01`@\x1B\x03`@QaW\x92\x81aa\xC7V[\x82T\x92\x83\x82R`\x01\x81\x01T` \x83\x01\x90\x81R``\x84`\x03`\x02\x85\x01T\x94`@\x87\x01\x95\x86R\x01T\x16\x93\x01\x92\x83R`@Q\x94\x85RQ` \x85\x01RQ`@\x84\x01RQ\x16``\x82\x01R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x05\xCAaW\xF5aa!V[aW\xFDah\x16V[aX\x05ag\x16V[`$5\x90ah=V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045c\xFF\xFF\xFF\xFF`\xE0\x1B\x81\x16\x80\x91\x03a\x05\xDDW` \x90cye\xDB\x0B`\xE0\x1B\x81\x14\x90\x81\x15aXSW[P`@Q\x90\x15\x15\x81R\xF3[c\x01\xFF\xC9\xA7`\xE0\x1B\x14\x90P\x82aXHV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWaX|ag\x16V[_3_R`\x15` R`@_ \x90_[\x82T\x81\x10\x15a\x05\xCAWaX\x9F\x81\x84agNV[P\x91_T`\x01`\x01`@\x1B\x03\x80aX\xC0\x81`\x03\x88\x01T\x16\x84`\xC0\x1C\x90aggV[\x16\x91\x16\x10aa\x11WaX\xD7a\t>`\x01\x85\x01ag\x95V[\x91aY\x08`\x01\x80`\xA0\x1B\x03\x85T\x16aX\xF3`\x02\x87\x01T\x82a\x8A\xB7V[\x90aY\x02`\x04\x88\x01T\x91ad@V[\x91a\x8A\xF2V[\x93_[3_R`\x13` R\x85`@_ T\x82\x10\x15aa\x02WP3_R`\x13` RaY6\x81`@_ af\xE9V[P\x80T\x83T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x16\x14\x80a`\xEBW[aY\\WP`\x01\x01aY\x0BV[\x93`\x03\x85\x97\x92\x97\x01\x96`\xFF\x88T\x16\x95aYt\x87aa\x9CV[`\x01\x87\x14\x80\x15a`\xCAW3_R`\x14` R`@_ \x83_R` R`@_ `@Q\x80` \x83T\x91\x82\x81R\x01\x92_R` _ \x90_\x91[\x81`\x03\x84\x01\x10a`zW\x93aY\xE8\x92\x84\x92aY\xEE\x96T\x91\x81\x81\x10a``W[\x81\x81\x10a`CW[\x81\x81\x10a`&W[\x10a`\x18WP\x03\x82abNV[\x98aa\x9CV[\x80a`\x0EW[a_1W[`\x01\x80`\xA0\x1B\x03\x85T\x16\x97`\xFF`\x02\x87\x01T\x9AT\x16\x97a'\x10\x90aZ\x1F`\x01\x89\x01ag\x95V[\x99_aZ*\x82aa\x9CV[\x81a_\nWPaZ9\x8Ca\x90\x1BV[\x8B_R`\x18` R`@_ \x9C3_R`\x19` R`@_ \x8D`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x9B_\x9C_[3_R`\x13` R`@_ T\x81\x10\x15aZ\xE4W\x8F3_R`\x13` RaZ\x93\x82`@_ af\xE9V[P\x90`\x01\x80`\xA0\x1B\x03\x82T\x16\x14\x80aZ\xCCW[aZ\xB4W[P`\x01\x01aZiV[`\x01\x91\x9F\x82aZ\xC5\x92\x01T\x90afjV[\x9E\x90aZ\xABV[P`\xFF`\x03\x82\x01T\x16aZ\xDE\x81aa\x9CV[\x15aZ\xA6V[P\x9D\x8A\x9F\x9Ea[h\x98\x9A\x9D\x9F\x8C\x9D\x9Fg\r\xE0\xB6\xB3\xA7d\0\0\x91a[P\x91\x9E\x96\x97\x98\x99\x9A\x9C\x9E\x80a^\xCBW[_\x98`\x01\x83\x01a[ \x82\x82TadlV[\x90U`\x02\x83\x01\x80T\x8A\x81\x81\x11\x15a^\xBCWPP_\x90[U\x80\x82\x11\x15a^\xB3Wa[H\x91adlV[\x90[TadyV[\x04\x90U[a[b\x87\x85\x85\x85\x853a\x99pV[3a\x9A\xAFV[a[|`\x01`\x02\x88\x01T\x93\x01\x92\x83TadlV[\x82U3_R`\x10` R`@_ \x90_R` R`\x01`@_ \x01a[\xAB\x81T\x80\x86\x11_\x14a^\xACW\x80adlV[\x90UT\x15a]5W[Pa[\xBE\x91afjV[\x92`\x01\x80`\xA0\x1B\x03\x82T\x16\x90`\x02`\x01\x80`\xA0\x1B\x03`\x01\x85\x01T`\x08\x1C\x16\x93\x01T\x90`@Q\x91\x82R` \x82\x01R\x7F\xE4\x185\x14\xC7H09S\x8C\xD1\xF9\xCA \xE4\x89\xB3\xC4\x11\xF3\xAF\x12\x11\xCFkZ\xD0\xA0\x0C\xA4\xE2(`@3\x92\xA4\x82T_\x19\x81\x01\x90\x81\x11a\t\x9EWa\\(\x90\x84agNV[Pa\\3\x82\x85agNV[\x91\x90\x91a\x08\x8EW\x80\x82\x03a\\\x7FW[PP\x82T\x80\x15a\x0E\xD4W_\x19\x01a\\Y\x81\x85agNV[a\x08\x8EW`\x04\x81_\x80\x93U\x82`\x01\x82\x01U\x82`\x02\x82\x01U\x82`\x03\x82\x01U\x01U\x83UaX\x8CV[\x80T\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x82U`\x04\x90\x81\x90`\x01\x80\x82\x01\x90\x85\x01\x82\x86\x03a\\\xFDW[PP`\x02\x81\x01T`\x02\x85\x01Ua\\\xF1`\x03\x85\x01`\xFF`\x03\x84\x01`\x01`\x01`@\x1B\x03\x80\x82T\x16\x16`\x01`\x01`@\x1B\x03\x19\x84T\x16\x17\x83UT`@\x1C\x16\x90ag\xF3V[\x01T\x91\x01U\x83\x80a\\BV[\x81a]\x0F`\xFFa].\x94T\x16\x83ag\xDBV[T\x81Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16a\x01\0`\x01`\xA8\x1B\x03\x90\x91\x16\x17\x90UV[\x87\x80a\\\xB1V[\x90P`\x01\x80`\xA0\x1B\x03\x83T\x16_R`\n` R`\x01`@_ \x01c\xFF\xFF\xFF\xFF\x81T\x16\x80\x15a\t\x9EW\x81Tc\xFF\xFF\xFF\xFF\x19\x16_\x19\x91\x82\x01c\xFF\xFF\xFF\xFF\x16\x17\x90\x91U3_\x90\x81R`\x13` R`@\x90 \x80T\x91\x82\x01\x91\x82\x11a\t\x9EWa]\xAF\x91a]\x9C\x91af\xE9V[P\x913_R`\x13` R`@_ af\xE9V[a\x08\x8EW\x81\x81\x03a^>W[PP3_R`\x13` R`@_ \x90\x81T\x80\x15a\x0E\xD4W_\x19\x01\x90a]\xE0\x82\x84af\xE9V[\x92\x90\x92a\x08\x8EWa[\xBE\x93_`\x03\x85\x82\x8B\x97U\x82`\x01\x82\x01U\x82`\x02\x82\x01U\x01UU`\x01\x80`\xA0\x1B\x03\x84T\x16a^\x16\x813a|gV[\x15a^#W[P\x91a[\xB4V[_R`\r` Ra^73`@_ a\x94\xC6V[P\x87a^\x1CV[\x81T\x81T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x81U`\x01\x80\x83\x01T\x90\x82\x01Ua^\x8D\x91`\x03\x90`\xFF\x90\x82\x90`\x02\x80\x82\x01\x90\x86\x01\x82\x87\x03a^\x94W[PP\x01T\x16\x91\x01ag\xDBV[\x85\x80a]\xBBV[\x81a]\x0F\x86a^\xA5\x94T\x16\x83ag\xDBV[\x8B\x80a^\x81V[\x85\x90adlV[PP_\x90a[JV[a^\xC5\x91adlV[\x90a[6V[\x83a^\xD7\x82\x84TadyV[\x04\x85T\x80\x82\x11_\x14a_\x02Wa^\xEC\x91adlV[a^\xFB`\x01\x87\x01\x91\x82TafjV[\x90Ua[\x0FV[PP_a^\xECV[\x90\x91\x92\x93\x95\x97\x80\x9D\x9B\x8Da_,a[h\x98\x9A\x9D\x9F\x84\x9D\x9F\x85_\x91\x8A\x933a\x97PV[a[TV[\x97\x93\x96\x92\x90\x94\x91a_H`\x02\x89\x01T\x88Q\x90ad\x8CV[\x95_[\x88Q\x81\x10\x15a_\xFFW3_\x90\x81R`\x1E` \x90\x81R`@\x80\x83 \x8DT`\x01`\x01`\xA0\x1B\x03\x16\x80\x85R\x92R\x90\x91 `\x01\x92\x91\x90`\x01`\x01`@\x1B\x03\x80a_\x90\x85\x8Fag\xC7V[Q\x16\x16_R` R`@_ T\x8A\x81\x81\x11_\x14a_\xF0WPP_\x90[3_R`\x1E` R`@_ \x90\x84\x80`\xA0\x1B\x03\x16_R` R\x8A`\x01`\x01`@\x1B\x03\x80a_\xDD\x85`@_ \x94ag\xC7V[Q\x16\x16_R` R`@_ U\x01a_KV[a_\xF9\x91adlV[\x90a_\xACV[P\x91\x93\x97\x94\x98\x90\x92\x95PaY\xF9V[P\x86Q\x15\x15aY\xF4V[`\xC0\x1C\x81R` \x01_a2\xBCV[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85`\x80\x1C\x16\x81R\x01\x93\x01aY\xDBV[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85`@\x1C\x16\x81R\x01\x93\x01aY\xD3V[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85\x16\x81R\x01\x93\x01aY\xCBV[\x92\x93`\x01`\x80`\x04\x92\x86T`\x01`\x01`@\x1B\x03\x81\x16\x82R`\x01`\x01`@\x1B\x03\x81`@\x1C\x16` \x83\x01R`\x01`\x01`@\x1B\x03\x81\x84\x1C\x16`@\x83\x01R`\xC0\x1C``\x82\x01R\x01\x94\x01\x92\x01\x91\x93\x92\x93aY\xACV[aY\xEE` `@Q\x90a`\xDD\x81\x83abNV[_\x82RP_6\x817\x98aa\x9CV[P\x85a`\xFCa\t>`\x02\x84\x01ag\x95V[\x14aYOV[\x91\x93\x90Pa[\xBE\x92\x94PafjV[\x91Paa\x1C\x90ag\x87V[aX\x8CV[`\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[`$5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[`\x045\x90`\x01`\x01`@\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[`$5\x90`\x01`\x01`@\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[`D5\x90`\x01`\x01`@\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[\x90`\x05\x82\x10\x15a\x14\x82WRV[`\x02\x11\x15a\x14\x82WV[` \x90\x80Qaa\xB4\x81aa\x9CV[\x83R\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x01RV[`\x80\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[``\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[`\xC0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[`\xE0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[`\x01`\x01`@\x1B\x03\x81\x11a\x08\xA1W`\x1F\x01`\x1F\x19\x16` \x01\x90V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWab\xA3aa!V[`\x01\x80`\xA0\x1B\x03\x16_R`\x18` R` `\x02`@_ \x01T`@Q\x90\x81R\xF3[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90_[\x81\x81\x10ab\xE1WPPP\x90V[\x82Q`\x01`\x01`@\x1B\x03\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01ab\xD4V[``\x90`\x03\x19\x01\x12a\x05\xDDW`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x90`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x90`D5\x90V[\x90`\xA0`\x03\x19\x83\x01\x12a\x05\xDDW`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x91`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x91`D5\x91`d5`\x02\x81\x10\x15a\x05\xDDW\x91`\x845`\x01`\x01`@\x1B\x03\x81\x11a\x05\xDDW\x82`#\x82\x01\x12\x15a\x05\xDDW\x80`\x04\x015\x92`\x01`\x01`@\x1B\x03\x84\x11a\x05\xDDW`$\x84`\x05\x1B\x83\x01\x01\x11a\x05\xDDW`$\x01\x91\x90V[`@Q\x90ac\xD2\x82aa\xC7V[_``\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x01RV[_R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` R`\x01`@_ \x01T\x90V[\x15ad\x0EWV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\n`$\x82\x01RiUse native`\xB0\x1B`D\x82\x01R`d\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x0F` R`@\x90 T\x80adiWPg\r\xE0\xB6\xB3\xA7d\0\0\x90V[\x90V[\x91\x90\x82\x03\x91\x82\x11a\t\x9EWV[\x81\x81\x02\x92\x91\x81\x15\x91\x84\x04\x14\x17\x15a\t\x9EWV[\x81\x15ad\x96W\x04\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[\x92\x91\x90\x92_\x93`\x01\x80`\xA0\x1B\x03\x82\x16_R`Q` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ \x90`@Q\x92ad\xE5\x84ab3V[\x82T`\x01`\x01`@\x1B\x03\x80\x82\x16\x91\x82\x87R\x81\x81`@\x1C\x16` \x88\x01R`\x80\x1C\x16`@\x86\x01R`\x01\x84\x01T``\x86\x01R`\x02\x84\x01T\x94`\x80\x81\x01\x95\x86R`\xC0`\x04`\x03\x87\x01T\x96`\xA0\x84\x01\x97\x88R\x01T\x91\x01R\x15ae\x89W\x90aeF\x91a|gV[\x91\x82\x15ae\x81WQ\x90Q\x90\x81\x81\x11ae]WPPPV[g\r\xE0\xB6\xB3\xA7d\0\0\x93\x94Pae}\x92\x91aew\x91adlV[\x90adyV[\x04\x90V[P_\x93PPPV[P_\x94PPPPV[`@Q\x90ae\x9F\x82aa\xE2V[_` \x83\x82\x81R\x01RV[\x90`@Qae\xB7\x81aa\xE2V[` `\x01\x82\x94\x80T\x84R\x01T\x91\x01RV[\x15ae\xCFWV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01Rn$\xB7;0\xB64\xB2\x100\xB20\xB8:2\xB9`\x89\x1B`D\x82\x01R`d\x90\xFD[\x90\x81` \x91\x03\x12a\x05\xDDWQ\x80\x15\x15\x81\x03a\x05\xDDW\x90V[\x15af%WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAdapter doesn't support token\0\0\0`D\x82\x01R`d\x90\xFD[\x91\x90\x82\x01\x80\x92\x11a\t\x9EWV[`\x01`\x01`@\x1B\x03\x81\x11a\x08\xA1W`\x05\x1B` \x01\x90V[\x92\x91af\x99\x82afwV[\x93af\xA7`@Q\x95\x86abNV[` \x85\x84\x81R\x01\x92`\x05\x1B\x81\x01\x91\x82\x11a\x05\xDDW\x91[\x81\x83\x10af\xC9WPPPV[\x825`\x01`\x01`@\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x81R` \x92\x83\x01\x92\x01af\xBDV[\x80T\x82\x10\x15ag\x02W_R` _ \x90`\x02\x1B\x01\x90_\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[`\x02_\x80Q` a\x9F\\\x839\x81Q\x91RT\x14ag?W`\x02_\x80Q` a\x9F\\\x839\x81Q\x91RUV[c>\xE5\xAE\xB5`\xE0\x1B_R`\x04_\xFD[\x80T\x82\x10\x15ag\x02W_R`\x05` _ \x91\x02\x01\x90_\x90V[\x90`\x01`\x01`@\x1B\x03\x80\x91\x16\x91\x16\x01\x90`\x01`\x01`@\x1B\x03\x82\x11a\t\x9EWV[_\x19\x81\x14a\t\x9EW`\x01\x01\x90V[\x90`@Qag\xA2\x81aa\xE2V[` \x81\x93T`\xFF\x81\x16ag\xB4\x81aa\x9CV[\x83R`\x08\x1C`\x01`\x01`\xA0\x1B\x03\x16\x91\x01RV[\x80Q\x82\x10\x15ag\x02W` \x91`\x05\x1B\x01\x01\x90V[\x90ag\xE5\x81aa\x9CV[`\xFF\x80\x19\x83T\x16\x91\x16\x17\x90UV[\x90ag\xFD\x81aa\x9CV[`\xFF`@\x1B\x82T\x91`@\x1B\x16\x90`\xFF`@\x1B\x19\x16\x17\x90UV[`\xFF_\x80Q` a\x9F<\x839\x81Q\x91RT\x16ah.WV[c\xD9<\x06e`\xE0\x1B_R`\x04_\xFD[`@Q\x91ahJ\x83aa\xE2V[_\x83R_` \x84\x01R` \x91`@Qahc\x84\x82abNV[_\x81R_6\x817\x82\x15a\t\xDAW\x80Qam\x0BW`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\t\x85R`@\x90 T\x15al\xEAW`\x01\x80`\xA0\x1B\x03\x82\x16_R`\n\x84R`\x01`@_ \x01\x94`\xFF\x86T\x86\x1C\x16`\x03\x81\x10\x15a\x14\x82Wal\xCCWah\xC6\x81argV[3_R`\x10\x86R`@_ \x81_R\x86R`@_ \x92\x83T\x93ah\xED`\x01\x82\x01T\x80\x96adlV[\x87\x81\x10al\xB5WPah\xFF\x87\x87a\x9B`V[\x94\x85\x15a\t\xDAW\x87ai\x10\x91afjV[`\x01\x82\x01U_\x98_\x80[3_R`\x13\x8BR`@_ T\x81\x10\x15al\xA5W3_R`\x13\x8BRaiA\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16\x91\x16\x14\x80al\x8EW[aieWP`\x01\x01ai\x1AV[\x91P\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9AP`\xFF`\x03\x82\x01T\x16`\x02_\x10\x15a\x14\x82Wai\x8C\x81aa\x9CV[al\x7FW`\x01\x01ai\x9E\x88\x82TafjV[\x90U`\x01[ak\x86WP3_R`\x13\x89R`@_ T3_R`\x13\x8AR`@_ `@Qai\xCB\x81aa\xC7V[`\x01`\x01`\xA0\x1B\x03\x8A\x16\x81R\x8B\x81\x01\x89\x81R`@\x82\x01\x89\x81R\x92``\x83\x01\x90_\x82R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Waj\n\x91`\x01\x82\x01\x81Uaf\xE9V[\x93\x90\x93a\x08\x8EWaj\x9C\x94\x8F`\x03\x94aj\x8B\x93`\x01\x80`\xA0\x1B\x03\x90`\x01\x80`\xA0\x1B\x03\x90Q\x16\x16k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x88T\x16\x17\x87UQ`\x01\x87\x01U`\x02\x86\x01\x91Q\x90ajg\x82Qaja\x81aa\x9CV[\x84ag\xDBV[\x01Q\x81Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x90UV[Q\x91aj\x96\x83aa\x9CV[\x01ag\xDBV[3_\x90\x81R`\x1D\x8BR`@\x80\x82 `\x01`\x01`\xA0\x1B\x03\x8B\x16\x83R\x8CR\x80\x82 \x92\x82R\x91\x8BR \x80T`\xFF\x19\x16`\x01\x17\x90U\x80Tc\xFF\xFF\xFF\xFF\x90\x81\x16\x94\x90\x85\x14a\t\x9EW`\x01ak%\x93\x8A\x93c\xFF\xFF\xFF\xFF\x83ak1\x99\x01\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90U\x81\x80`\xA0\x1B\x03\x8A\x16_R`\r\x8CRak\x1A3`@_ a\x8E\x16V[P[\x01T\x903a\x9B\xBBV[\x90_\x87\x86\x86\x893a\x8BeV[` \x01Q`@Q\x93\x84R\x93\x83\x01R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91_`@\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16\x903\x90\x7FO\xE2\xFD\xE61\xE9\x86\xEE&(9\x01\xB9\xCC\x8DmJ1\x1Bu\x0F\x9F\xA0\xD6YR\r\xEB\xA2\x99_\x1F\x90``\x90\xA4V[\x90P\x92\x91\x923_R`\x13\x89R`\x01`\xFF`\x03ak\xA5\x84`@_ af\xE9V[P\x01T\x16ak\xB2\x81aa\x9CV[\x14ak\xCAW[P\x86ak1\x93\x92`\x01ak%\x93ak\x1CV[\x97\x94\x91\x96\x92\x95\x93\x90\x973_R`\x14\x86R`@_ \x90_R\x85R`@_ \x95\x86T\x80\x15\x15_\x14alwWak\xFD\x90\x84ad\x8CV[\x97[_[\x88T\x81\x10\x15alcW3_\x90\x81R`\x1E\x89R`@\x80\x82 `\x01`\x01`\xA0\x1B\x03\x8A\x16\x83R\x8AR\x90 `\x01\x91\x90`\x01`\x01`@\x1B\x03\x80al?\x84\x8Ean\x93V[\x90T\x90`\x03\x1B\x1C\x16\x16_R\x89R`@_ al[\x8C\x82TafjV[\x90U\x01al\x01V[P\x95\x98\x93\x97P\x93\x95P\x90\x93\x90\x92\x91\x86ak\xB8V[P_\x97ak\xFFV[c\n\xBC\xE6\xAF`\xE4\x1B_R`\x04_\xFD[P\x86al\x9Fa\t>`\x02\x84\x01ag\x95V[\x14aiXV[P\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99ai\xA3V[\x87\x90c\x12\xE1\xFA7`\xE1\x1B_R`\x04R`$R`D_\xFD[cq\xABj\xD5`\xE1\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16`\x04R`$\x90\xFD[Pc\xBDb\x013`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[c\x10\xDB\x86\xDF`\xE2\x1B_R`\x04_\xFD[3_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 T`\xFF\x16\x15amRWV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u`$R`D_\xFD[3_\x90\x81R\x7F[\xC8A\xA6\xD9%\xA6 \x86i\"\xBA\xDA6\xD1m\xA3\xDC\xC9\xD5\"\x90Q\x9E\xA1\x12n\\\xA27!9` R`@\x90 T`\xFF\x16\x15am\xC1WV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7F\xB1\xFA\xDD1B\xAB*\xD7\xF13~\xA4\xD9q\x12\xBC\xC83\x7F\xC1\x1C\xE5\xB2\x0C\xB0J\xD08\xAD\xF9\x98\x19`$R`D_\xFD[3_\x90\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x90 T`\xFF\x16\x15an\x1DWV[c\xE2Q}?`\xE0\x1B_R3`\x04R_\x80Q` a\x9E\xFC\x839\x81Q\x91R`$R`D_\xFD[_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 T`\xFF\x16\x15anqWPV[c\xE2Q}?`\xE0\x1B_R3`\x04R`$R`D_\xFD[`\x05\x82\x10\x15a\x14\x82WRV[\x91\x90\x91\x80T\x83\x10\x15ag\x02W_R`\x18` _ \x83`\x02\x1C\x01\x92`\x03\x1B\x16\x90V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x81\x14a\t\x9EW`\x01\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x81R\x91\x16` \x82\x01R\x90T`\xA0\x82\x01\x93\x92`\x80\x91`\x01`\x01`@\x1B\x03\x91\x90`\xFF\x81\x16ao\x07\x81aa\x9CV[`@\x86\x01R`\x08\x1C`\x01`\x01`\xA0\x1B\x03\x16``\x85\x01R\x16\x91\x01RV[\x90`\x03\x81\x10\x15a\x14\x82Wd\xFF\0\0\0\0\x82T\x91` \x1B\x16\x90d\xFF\0\0\0\0\x19\x16\x17\x90UV[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x90 T`\xFF\x16ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90_\x80Q` a\x9E\xFC\x839\x81Q\x91R\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x90\x80\xA4`\x01\x90V[P_\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x81\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 T`\xFF\x16ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x90\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F[\xC8A\xA6\xD9%\xA6 \x86i\"\xBA\xDA6\xD1m\xA3\xDC\xC9\xD5\"\x90Q\x9E\xA1\x12n\\\xA27!9` R`@\x90 T`\xFF\x16ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F[\xC8A\xA6\xD9%\xA6 \x86i\"\xBA\xDA6\xD1m\xA3\xDC\xC9\xD5\"\x90Q\x9E\xA1\x12n\\\xA27!9` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F\xB1\xFA\xDD1B\xAB*\xD7\xF13~\xA4\xD9q\x12\xBC\xC83\x7F\xC1\x1C\xE5\xB2\x0C\xB0J\xD08\xAD\xF9\x98\x19\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x90\x80\xA4`\x01\x90V[_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\xFF\x16araW_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x95\x90\x95\x16\x80\x84R\x94\x90\x91R\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x92\x91\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x90\x80\xA4`\x01\x90V[PP_\x90V[\x80Q\x90ars\x82aa\x9CV[` `\x01\x80`\xA0\x1B\x03\x91\x01Q\x16`@Q\x90` \x82\x01\x92ar\x92\x81aa\x9CV[\x83R`@\x82\x01R`@\x81Rar\xA8``\x82abNV[Q\x90 \x90V[\x90\x93\x92\x91`\x01\x80`\xA0\x1B\x03\x82\x16\x91\x82_R`\n` R`@_ \x90ar\xDE\x84_R`\t` R`@_ T\x15\x15\x90V[\x15av\x08War\xEC\x81a\x8EcV[au\xF5W\x83_R`\x18` R`@_ \x96\x83\x97as\x0F`\x02\x85T\x92\x01T\x82afjV[\x94\x85\x15au\xE8W\x85\x10au\xDEW[\x84as+as0\x92\x8BadyV[ad\x8CV[\x91asWasQas@\x83a\x8E\xE6V[\x94asK\x81\x85a\x8FEV[\x9BadlV[\x82a\x8F~V[\x98asb\x8A\x82afjV[\x99asl\x83a\x8E\xE6V[\x95as|`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\x01`@_ \x01T\x81T\x10au\xC2W[P\x87_R`R` R\x8A`@_ \x99\x8AT`\x01`\x01`@\x1B\x03\x16\x9Aas\xB7\x8Can\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x87\x8A_T`\x01`\x01`@\x1B\x03\x16\x93`@Q\x94as\xEA\x86ab3V[\x85R\x8D` \x86\x01\x99`\x01`\x01`@\x1B\x03\x16\x99\x8A\x81R`@\x87\x01\x91_\x83R``\x88\x01\x93\x84R`\x80\x88\x01\x94\x8D\x86R`\xA0\x89\x01\x96\x87R`\xC0\x89\x01\x97\x88R_R`Q` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x96Q`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x88T\x16\x17\x87UQ`\x01`\x01`@\x1B\x03\x16at\x9C\x90\x87\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x82T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17\x90UV[Q\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x85UQ`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ\x90`\x04\x01U\x83_R`S` R`@_ \x88_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16au\x05\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90Ua'\x10\x8B\x02\x91\x8B\x83\x04a'\x10\x14\x8C\x15\x17\x15a\t\x9EWau\x89\x89\x94au\x83\x7F\x15\x08\xFB\xE2,\x98\x05w\x07@\xC8\xF3\x82ug\x95\0\"r\x9E\0\x96\xE3\x11\xDC\x08y\x90\xC1W\xFF\xFC\x9A\x7F\x91uK%AS\x86\x1C\x1E\x9B\xC9\x18d\x84\xA0\xBBw\x08#\xAC\xFA\0B0D\xBA\x17Y\xA0\x12\x10\xE7\x96ad\x8CV[\x90a\x8F\xC1V[`@\x80Q\x91\x82R` \x82\x01\x92\x90\x92R\x90\x81\x01\x86\x90R``\x90\xA3`@\x80Q\x88\x81R` \x81\x01\x92\x90\x92R\x81\x01\x91\x90\x91R\x80``\x81\x01[\x03\x90\xA3V[`\x01\x01\x80Td\xFF\0\0\0\0\x19\x16d\x01\0\0\0\0\x17\x90U_as\x93V[\x93\x97P\x87\x93as\x1DV[P_\x98PPPPPPPPV[\x83c\xB5\x16&\r`\xE0\x1B_R`\x04R`$_\xFD[\x83c\xBDb\x013`\xE0\x1B_R`\x04R`$_\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x90 T`\xFF\x16\x15ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x81 \x80T`\xFF\x19\x16\x90U3\x91\x90_\x80Q` a\x9E\xFC\x839\x81Q\x91R\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x90\x80\xA4`\x01\x90V[_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\xFF\x16\x15araW_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x95\x90\x95\x16\x80\x84R\x94\x90\x91R\x81 \x80T`\xFF\x19\x16\x90U3\x92\x91\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x90\x80\xA4`\x01\x90V[=\x15awrW=\x90awY\x82aboV[\x91awg`@Q\x93\x84abNV[\x82R=_` \x84\x01>V[``\x90V[aw\x96`@Qaw\x86\x81aa\xE2V[_\x81R_` \x82\x01R4\x90a\x90jV[V[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15ax\x1DW3_R`\x1A` R`@_ T\x91\x82\x15ax\x0EW_\x80\x80\x85\x81\x943\x83R`\x1A` R\x82`@\x81 UZ\xF1aw\xDAawHV[P\x15aB\xA6W`@Q\x82\x81R\x7F\x10o\x92?\x99<!I\xD4\x9BBU\xFFr:\xCA\xFA\x1F-\x949?V\x1D>\xDA2\xAE4\x8FrA` 3\x92\xA2V[cs8\r\x99`\xE0\x1B_R`\x04_\xFD[c\xD9.#=`\xE0\x1B_R`\x04_\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\n` \x90\x81R`@\x80\x83 `\t\x90\x92R\x90\x91 T\x94\x96\x94\x92\x93\x92\x90\x91\x90\x15a|GW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x18` \x90\x81R`@\x80\x83 `\x1B\x83R\x81\x84 `\x01`\x01`@\x1B\x03\x89\x16\x85R\x90\x92R\x90\x91 \x83T`\x02\x92\x83\x01T\x92\x90\x91\x01T\x90\x94\x91\x90ax\xAF\x90a\t~\x83\x88afjV[\x94\x85\x15a|9W\x89\x86ax\xF0\x92\x81as+\x9A\x9B\x9C\x9D\x11a|/W[\x81ax\xDFaN=\x93as+ax\xE8\x94\x87adyV[\x9A\x8B\x96\x85adyV[\x93\x84\x92adlV[ay\x18ay\x10ay\tay\x02\x87a\x8E\xE6V[\x99\x87a\x8FEV[\x93\x86a\x8F~V[\x91\x89\x86a\x95wV[\x95ay'\x87a\t~\x84\x86afjV[\x9A\x8B\x99ay3\x87a\x8E\xE6V[\x97ayC`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\x01`@_ \x01T\x81T\x10a|\x13W[P`\x01`\x01`\xA0\x1B\x03\x87\x16_\x90\x81R`R` R`@\x90 \x80T`\x01`\x01`@\x1B\x03\x16\x9B\x8C\x93\x91\x8A\x91\x8D\x91ay\x8E\x87an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U_T`\x01`\x01`@\x1B\x03\x16\x94`@Q\x95ay\xBF\x87ab3V[\x86R` \x86\x01\x9A`\x01`\x01`@\x1B\x03\x16\x9A\x8B\x81R`@\x87\x01\x91`\x01`\x01`@\x1B\x03\x16\x97\x88\x83R``\x88\x01\x93\x84R`\x80\x88\x01\x94\x85R`\xA0\x88\x01\x95\x86R`\xC0\x88\x01\x96\x87R\x8D`\x01`\xA0\x1B`\x01\x90\x03\x16_R`Q` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x96Q`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x88T\x16\x17\x87UQ`\x01`\x01`@\x1B\x03\x16az\x84\x90\x87\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x82T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17\x90UV[Q\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x85UQ`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ\x90`\x04\x01U\x84_R`S` R`@_ `\x01`\xA0\x1B`\x01\x90\x03\x87\x16_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16az\xF7\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U_R`T` R`@_ `\x01`\xA0\x1B`\x01\x90\x03\x86\x16_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16a{B\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90Ua'\x10\x8B\x02\x8B\x81\x04a'\x10\x14\x8C\x15\x17\x15a\t\x9EW\x7F\x15\x08\xFB\xE2,\x98\x05w\x07@\xC8\xF3\x82ug\x95\0\"r\x9E\0\x96\xE3\x11\xDC\x08y\x90\xC1W\xFF\xFC\x97\x7F\x91uK%AS\x86\x1C\x1E\x9B\xC9\x18d\x84\xA0\xBBw\x08#\xAC\xFA\0B0D\xBA\x17Y\xA0\x12\x10\xE7\x93a\t~a{\xC3\x8A\x95a{\xC9\x95ad\x8CV[\x89a\x8F\xC1V[`@\x80Q\x94\x85R` \x85\x01\x91\x90\x91R\x83\x01R`\x01`\x01`\xA0\x1B\x03\x84\x16\x91``\x90\xA3`@\x80Q\x88\x81R` \x81\x01\x95\x90\x95R\x84\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x16\x91\x80``\x81\x01au\xBDV[`\x01\x01\x80Td\xFF\0\0\0\0\x19\x16d\x01\0\0\0\0\x17\x90U_ayZV[\x90\x91P\x81\x90ax\xCAV[PPPPPPP\x91PP_\x90V[c\xBDb\x013`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[\x90\x91_\x92_[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\x13` R`@\x90 T\x82\x10\x15a|\xE3W\x80_R`\x13` Ra|\xA1\x82`@_ af\xE9V[PT`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x14a|\xBFW[P`\x01\x01a|mV[`\x01\x91\x95a|\xDC\x91_R`\x13` R\x82a\t\x12\x88`@_ af\xE9V[\x94\x90a|\xB6V[PPP\x90PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x90\x81\x15a\x19IWaw\x96\x92a}\x08\x91a\x95\xD0V[\x90`@Q\x90a}\x16\x82aa\xE2V[`\x01\x82R` \x82\x01Ra\x90jV[\x91\x90\x81\x10\x15ag\x02W``\x02\x01\x90V[5a\xFF\xFF\x81\x16\x81\x03a\x05\xDDW\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\n` \x90\x81R`@\x80\x83 `\t\x90\x92R\x90\x91 T\x95\x98\x97\x96\x94\x95\x90\x93\x91\x92\x91\x90\x15a\x82\xA9W\x88\x15a\x82\x99W`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x18` \x90\x81R`@\x80\x83 `\x1B\x83R\x81\x84 `\x01`\x01`@\x1B\x03\x87\x16\x85R\x90\x92R\x82 \x86T`\x02\x92\x83\x01T\x92\x90\x91\x01T\x98\x92\x97\x91\x92\x88[\x8D\x80\x82\x10a\x82\tWPP\x88\x15a\x81\xF9W\x88\x83\x11a\x81\xF1W[a}\xE4\x87a\x8E\xE6V[\x99a}\xF3\x81a\t~\x87\x86afjV[\x15a\x81\xE0W\x89\x92\x91\x8E\x91_\x93_\x97_\x93_\x94[\x86\x86\x10a\x81_WPPPPPPP\x92aOaa~_a~Xa~Q\x86aN=a~I\x88a~@a\t~\x9Aas+a~g\x9Eas+\x9EadyV[\x9A\x8B\x99\x85adyV[\x98\x89\x92adlV[\x93\x8Aa\x8FEV[\x94\x89a\x8F~V[\x91\x87\x89a\x95wV[\x98a~q\x84a\x8E\xE6V[\x94a~\x81`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\x01`@_ \x01T\x81T\x10a\x81CW[P`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`R` R`@\x90 \x80T`\x01`\x01`@\x1B\x03\x16\x98\x90a~\xC6\x8Aan\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U_T`\x01`\x01`@\x1B\x03\x16\x90`@Q\x91a~\xF7\x83ab3V[\x82R\x89` \x83\x01\x94`\x01`\x01`@\x1B\x03\x16\x94\x85\x81R\x8D`@\x85\x01\x97`\x01`\x01`@\x1B\x03\x16\x97\x88\x81R``\x86\x01\x91\x82R`\x80\x86\x01\x92\x8D\x84R`\xA0\x87\x01\x94\x8C\x86R`\xC0\x88\x01\x96\x87R`\x01`\xA0\x1B`\x01\x90\x03\x8C\x16_R`Q` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x96Q`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x88T\x16\x17\x87UQ`\x01`\x01`@\x1B\x03\x16a\x7F\xC0\x90\x87\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x82T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17\x90UV[Q\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x85UQ`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ\x90`\x04\x01U\x81_R`S` R`@_ `\x01`\xA0\x1B`\x01\x90\x03\x85\x16_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16a\x803\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x82_R`T` R`@_ `\x01`\xA0\x1B`\x01\x90\x03\x85\x16_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16a\x80\x7F\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90Ua'\x10\x8A\x02\x95\x8A\x87\x04a'\x10\x14\x8B\x15\x17\x15a\t\x9EWa\x80\xDAa\x80\xE0\x91\x7F\x15\x08\xFB\xE2,\x98\x05w\x07@\xC8\xF3\x82ug\x95\0\"r\x9E\0\x96\xE3\x11\xDC\x08y\x90\xC1W\xFF\xFC\x98ad\x8CV[\x85a\x8F\xC1V[`@Q\x90\x8A\x82R` \x82\x01R\x7F\xEB\r\x9B4\xEF\x07\x1B\x87\xDA\x85\x91\xDD\xD8,\xC6\x7F\x90\xC6\x80b\x01\xB5\xC9\xDD\xC9\x1F\x06$g}\xC8\x15`@`\x01\x80`\xA0\x1B\x03\x86\x16\x92\xA4`@\x80Q\x88\x81R` \x81\x01\x95\x90\x95R\x84\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x16\x91\x80``\x81\x01au\xBDV[`\x01\x01\x80Td\xFF\0\0\0\0\x19\x16d\x01\0\0\0\0\x17\x90U_a~\x98V[\x90\x91\x92\x93\x94\x95\x96\x99\x97Pa\x81t\x86\x88\x84a}$V[`@\x01a\x81\x80\x90a}4V[a\xFF\xFF\x16\x99a\x81\x8F\x8B\x86adyV[a'\x10\x90\x04a\x81\x9D\x91afjV[\x97a\x81\xA8\x8B\x85adyV[a'\x10\x90\x04a\x81\xB6\x91afjV[\x99a\x81\xC1\x90\x86adyV[a'\x10\x90\x04a\x81\xCF\x91afjV[\x94`\x01\x01\x93\x92\x91\x90\x8E\x97\x96\x95a~\x06V[P_\x9CPPPPPPPPPPPPV[\x88\x92Pa}\xDBV[P_\x9BPPPPPPPPPPPV[\x81a\x82\x17\x91\x84\x9C\x93\x9Ca}$V[\x805\x91`\x02\x83\x10\x15a\x05\xDDW\x8C\x87\x86`\x01\x95a\x822\x81aa\x9CV[a\x82sW\x93a\xFF\xFFa\x82]`@a\x82Va'\x10\x96a\t~a\x82d\x97a\x82k\x9BafjV[\x93\x01a}4V[\x16\x90adyV[\x04\x90afjV[\x99[\x01a}\xC3V[\x93a\xFF\xFFa\x82]`@a\x82Va'\x10\x96a\t~a\x82d\x97a\x82\x93\x9BafjV[\x99a\x82mV[\x93\x94P\x91Padi\x95\x96Pax,V[c\xBDb\x013`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16`\x04R`$\x90\xFD[\x15a\x82\xCEWV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01Rn\x15\x1C\x98[\x9C\xD9\x99\\\x88\x19\x98Z[\x19Y`\x8A\x1B`D\x82\x01R`d\x90\xFD[3_R`\x0B` R`@_ \x90\x81T\x91\x82\x15a\x83\xBEW_T`\x01`\x01`@\x1B\x03`\x01\x81\x83\x16\x93\x01T\x16\x90`\xC0\x1C\x90`\x01`\x01`@\x1B\x03a\x83E\x83\x83aggV[\x16\x83\x10a\x1D\xFEWPPP\x813_R`\n` R`@_ a\x83g\x82\x82TadlV[\x90U3_R`\x0B` R_`\x01`@\x82 \x82\x81U\x01Ua\x83\x90_\x80\x80\x80\x853Z\xF1a\x1D\xC0awHV[`@Q\x90\x81R\x7F\xDA+Q4\x10y\xF3\xDD\x8Egc\xA5\x0F2\x9B\xBC=\xC6\xCAjQ\xB9 \xFE\x99\xFB\xF8\x9AT\xEC\x0E'` 3\x92\xA2V[P_\x91PV[`@Qc\xA9\x05\x9C\xBB`\xE0\x1B` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16`$\x83\x01R`D\x80\x83\x01\x93\x90\x93R\x91\x81Raw\x96\x91a\x84\0`d\x83abNV[a\x96\xB4V[\x80T\x82\x10\x15ag\x02W_R`\x03` _ \x91\x02\x01\x90_\x90V[\x92\x93\x92\x91\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a\x8A\x9BWP`@Qa\x84>\x81aa\xE2V[_\x81R_` \x82\x01R\x93[\x81\x15a\t\xDAWa\x84X\x81aa\x9CV[\x80\x15\x94\x85\x15a\x8A\x86W\x84Qam\x0BW[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\t` R`@\x90 T\x90\x94\x90\x15a\x8AsW\x84_R`\n` R`\x01`@_ \x01\x90`\xFF\x82T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x8A`Wa\x84\xB6\x83argV[\x963_R`\x10` R`@_ \x88_R` R`@_ \x97`\x01\x89T\x99\x01\x93a\x84\xE1\x85T\x80\x9BadlV[\x88\x81\x10a\x8AIWPa\x84\xF3\x88\x85a\x9B`V[\x99\x8A\x15a\t\xDAW\x88a\x85\x04\x91afjV[\x85U_\x9A_\x80[3_R`\x13` R`@_ T\x81\x10\x15a\x8A7W3_R`\x13` Ra\x854\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x8D\x14\x80a\x8A W[a\x85UWP`\x01\x01a\x85\x0BV[\x91P\x91\x92\x93\x94\x95\x96\x97\x98\x80\x9A\x9B\x9C\x9DP`\xFF`\x03\x83\x01T\x16a\x85v\x82aa\x9CV[a\x85\x7F\x81aa\x9CV[\x03al\x7FW`\x01\x01a\x85\x92\x8D\x82TafjV[\x90U`\x01[a\x89!WP3_\x90\x81R`\x13` R`@\x90\x81\x90 \x80T\x91Q\x91\x92\x91a\x85\xBC\x81aa\xC7V[\x8C\x81R` \x81\x01\x8E\x81R`@\x82\x01\x8B\x81R\x92``\x83\x01\x90a\x85\xDC\x8Eaa\x9CV[\x8D\x82R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x85\xFC\x91`\x01\x82\x01\x81Uaf\xE9V[\x93\x90\x93a\x08\x8EWQ\x83T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x83U\x90Q`\x01\x83\x01U\x91Q\x80Qa\x86I\x93`\x03\x92\x90\x91aj\x8B\x91`\x02\x86\x01\x91a\x07\xBC\x90a\x07\xB6\x81aa\x9CV[a\x86R\x89aa\x9CV[\x15a\x870W3_R`\x1D` R`@_ \x8A_R` R`@_ \x90_R` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90U[c\xFF\xFF\xFF\xFF\x81T\x16\x91c\xFF\xFF\xFF\xFF\x83\x14a\t\x9EW\x86a\x86\xDA\x8A\x8D\x93a\x86\xE1\x99\x8E\x83\x97c\xFF\xFF\xFF\xFF\x8F\x9A`\x01\x01\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90U_R`\r` Ra\x86\xD03`@_ a\x8E\x16V[P[T\x903a\x9B\xBBV[\x953a\x8BeV[` `\x01\x80`\xA0\x1B\x03\x91\x01Q\x16\x93`@Q\x92\x83R` \x83\x01Ra\x87\x03\x81aa\x9CV[`@\x82\x01R\x7FO\xE2\xFD\xE61\xE9\x86\xEE&(9\x01\xB9\xCC\x8DmJ1\x1Bu\x0F\x9F\xA0\xD6YR\r\xEB\xA2\x99_\x1F``3\x92\xA4V[\x99\x95\x92\x97\x94\x91\x98\x96\x93\x90\x993_R`\x14` R`@_ \x90_R` R`@_ \x88Q`\x01`\x01`@\x1B\x03\x81\x11a\x08\xA1W`\x01`@\x1B\x81\x11a\x08\xA1W\x81T\x81\x83U\x80\x82\x10a\x88\xC7W[P` \x8A\x01\x91_R` _ \x81`\x02\x1C\x91_[\x83\x81\x10a\x88\x82WP`\x03\x19\x81\x16\x90\x03\x80a\x88*W[PP\x89Q\x91PP\x80\x15a\x88\"Wa\x87\xB8\x90\x87ad\x8CV[\x98[_[\x89Q\x81\x10\x15a\x88\x11W`\x01\x903_R`\x1E` R`@_ \x8A_R` R\x8A`\x01`\x01`@\x1B\x03\x80a\x87\xF2\x84`@_ \x94ag\xC7V[Q\x16\x16_R` R`@_ a\x88\t\x8D\x82TafjV[\x90U\x01a\x87\xBCV[P\x91\x94\x97\x92\x95\x99\x90\x93\x96\x98Pa\x86\x83V[P_\x98a\x87\xBAV[\x92_\x93_[\x81\x81\x10a\x88DWPPP\x01U_\x80\x80\x80a\x87\xA1V[\x90\x91\x94` a\x88x`\x01\x92`\x01`\x01`@\x1B\x03\x89Q\x16\x90\x85`\x03\x1B`\x01`\x01`@\x1B\x03\x80\x91`\x03\x1B\x93\x16\x83\x1B\x92\x1B\x19\x16\x17\x90V[\x96\x01\x92\x91\x01a\x88/V[_\x80[`\x04\x81\x10a\x88\x9AWP\x83\x82\x01U`\x01\x01a\x87\x8CV[\x86Q\x90\x96\x91`\x01\x91` \x91`\x01`\x01`@\x1B\x03`\x06\x8B\x90\x1B\x81\x81\x1B\x19\x90\x92\x16\x92\x16\x90\x1B\x17\x92\x01\x96\x01a\x88\x85V[\x82_R` _ `\x03\x80\x84\x01`\x02\x1C\x82\x01\x92\x01`\x02\x1C\x01\x90`\x18\x83`\x03\x1B\x16\x80a\x89\x06W[P[\x81\x81\x10a\x88\xFBWPa\x87yV[_\x81U`\x01\x01a\x88\xEEV[_\x19\x82\x01\x90\x81T\x90_\x19\x90` \x03`\x03\x1B\x1C\x16\x90U_a\x88\xECV[\x91PP\x93\x90\x91\x92\x933_R`\x13` R`\x01`\xFF`\x03a\x89D\x84`@_ af\xE9V[P\x01T\x16a\x89Q\x81aa\x9CV[\x14a\x89lW[P\x86\x89\x86a\x86\xDA\x83a\x86\xE1\x98\x97\x96\x8B\x96a\x86\xD2V[\x98\x94\x91\x97\x95\x92\x96\x93\x90\x983_R`\x14` R`@_ \x90_R` R`@_ \x96\x87T\x80\x15\x15_\x14a\x8A\x18Wa\x89\xA2\x90\x87ad\x8CV[\x98[_[\x89T\x81\x10\x15a\x8A\x01W`\x01\x903_R`\x1E` R`@_ \x8A_R` R\x8A`\x01`\x01`@\x1B\x03\x80a\x89\xDC\x84`@_ \x94an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x16_R` R`@_ a\x89\xF9\x8D\x82TafjV[\x90U\x01a\x89\xA6V[P\x95\x99\x96\x98P\x93\x96P\x91\x94\x90\x93\x91\x92\x91\x90\x86a\x89WV[P_\x98a\x89\xA4V[P\x85a\x8A1a\t>`\x02\x84\x01ag\x95V[\x14a\x85HV[P\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9Ba\x85\x97V[\x88\x90c\x12\xE1\xFA7`\xE1\x1B_R`\x04R`$R`D_\xFD[\x85cq\xABj\xD5`\xE1\x1B_R`\x04R`$_\xFD[\x84c\xBDb\x013`\xE0\x1B_R`\x04R`$_\xFD[\x84Qa\x84hWc\x1D\xB6\xD0\x8B`\xE1\x1B_R`\x04_\xFD[`@Q\x90a\x8A\xA8\x82aa\xE2V[`\x01\x82R` \x82\x01R\x93a\x84IV[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x18` R`@\x90 `\x01\x81\x01T\x90\x81\x15a\x8A\xEBWadi\x92`\x02as+\x92\x01T\x90adyV[PPP_\x90V[\x91\x81\x15\x80\x15a\x8B\x12W[a\x8B\rWas+\x90adi\x93adyV[PP\x90V[P\x81\x81\x10\x15a\x8A\xFCV[`\x05\x81\x10\x15a\x14\x82W`\x01\x81\x14a\x8B^W`\x02\x81\x14a\x8BWW`\x03\x81\x14a\x8BPW`\x04\x14a\x8BJWa'\x10\x90V[a>\x80\x90V[Pa2\xC8\x90V[Pa.\xE0\x90V[Pa*\xF8\x90V[\x93\x96\x92\x96\x95\x91\x95\x94\x90\x94a\x8Bx\x82aa\x9CV[\x81a\x8C\xE9Wa\x8B\x86\x86a\x90\x1BV[`\x01\x80`\xA0\x1B\x03\x86\x16\x96\x87_R`\x18` R`@_ \x96`\x01\x80`\xA0\x1B\x03\x87\x16\x96\x87_R`\x19` R`@_ \x8A_R` R`@_ _\x99_[\x8A_R`\x13` R`@_ T\x81\x10\x15a\x8C<W\x8A_R`\x13` Ra\x8B\xEA\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x8E\x14\x80a\x8C$W[a\x8C\x0CW[P`\x01\x01a\x8B\xC1V[`\x01\x91\x9C\x82a\x8C\x1D\x92\x01T\x90afjV[\x9B\x90a\x8C\x03V[P`\xFF`\x03\x82\x01T\x16a\x8C6\x81aa\x9CV[\x15a\x8B\xFEV[P`\x01\x98\x9BPg\r\xE0\xB6\xB3\xA7d\0\0\x92\x94\x96\x99Pa[H\x8Da\x8Chaw\x96\x9Fa\x8C\x94\x95\x97\x99\x9B\x9EadlV[\x80a\x8C\xABW[\x8B\x84\x01a\x8C|\x83\x82TafjV[\x90U`\x02\x84\x01a\x8C\x8D\x8C\x82TafjV[\x90UafjV[\x04\x90U[a\x8C\xA6\x88\x86\x86\x86\x86\x86a\x99pV[a\x9A\xAFV[\x85a\x8C\xB7\x82\x86TadyV[\x04\x87T\x80\x82\x11_\x14a\x8C\xE1Wa\x8C\xCC\x91adlV[a\x8C\xDA\x8D\x89\x01\x91\x82TafjV[\x90Ua\x8CnV[PP_a\x8C\xCCV[\x91\x94\x84a\x8D\x02\x87`\x01\x86aw\x96\x9C\x86\x83\x9A\x9D\x98\x9Ba\x97PV[a\x8C\x98V[`\x01\x80`\xA0\x1B\x03\x16_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ `\x01\x81\x01T\x90\x81\x15a\x8B\rWadi\x92`\x02as+\x92\x01T\x90adyV[\x80T\x82\x10\x15ag\x02W_R` _ \x01\x90_\x90V[\x80_R`\t` R`@_ T\x15_\x14ao\xC8W`\x08T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x8D\xAFa\x8D\x99\x82`\x01\x85\x94\x01`\x08U`\x08a\x8DKV[\x81\x93\x91T\x90`\x03\x1B\x91\x82\x1B\x91_\x19\x90\x1B\x19\x16\x17\x90V[\x90U`\x08T\x90_R`\t` R`@_ U`\x01\x90V[\x80_R`\x04` R`@_ T\x15_\x14ao\xC8W`\x03T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x8D\xFFa\x8D\x99\x82`\x01\x85\x94\x01`\x03U`\x03a\x8DKV[\x90U`\x03T\x90_R`\x04` R`@_ U`\x01\x90V[_\x82\x81R`\x01\x82\x01` R`@\x90 TaraW\x80T\x90`\x01`@\x1B\x82\x10\x15a\x08\xA1W\x82a\x8ENa\x8D\x99\x84`\x01\x80\x96\x01\x85U\x84a\x8DKV[\x90U\x80T\x92_R\x01` R`@_ U`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R`\x0C` R`@\x90 \x80T\x91\x90\x82\x15a\x8A\xEBW_[\x83\x81\x10a\x8E\x94WPPPP_\x90V[`\x01`\x01`@\x1B\x03a\x8E\xA6\x82\x84a\x8DKV[\x90T\x90`\x03\x1B\x1C\x16\x83_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`\x02`@_ \x01Ta\x8E\xDDW`\x01\x01a\x8E\x85V[PPPP`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x18` R`@\x90 `\x01\x81\x01T\x90\x81\x15a\x8F7W`\x02\x01T\x90g\r\xE0\xB6\xB3\xA7d\0\0\x82\x02\x91\x80\x83\x04g\r\xE0\xB6\xB3\xA7d\0\0\x14\x90\x15\x17\x15a\t\x9EWadi\x91ad\x8CV[PPg\r\xE0\xB6\xB3\xA7d\0\0\x90V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\n` R`@\x90 \x80T\x82\x81\x10a\x8FuWPa\x8Fp\x82\x82TadlV[\x90U\x90V[_\x91\x93\x92P\x92UV[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x18` R`@\x90 `\x02\x01\x80T\x80\x15\x80\x15a\x8F\xB9W[a\x8A\xEBW\x82\x81\x10a\x8FuWPa\x8Fp\x82\x82TadlV[P\x82\x15a\x8F\xA2V[\x90\x80\x15\x80\x15a\x90\x10W[a\x90\x0CWa\x8F\xD8\x82ad@V[\x90a'\x10\x03\x90a'\x10\x82\x11a\t\x9EWa'\x10\x91a\x8F\xF4\x91adyV[\x04\x90`\x01\x80`\xA0\x1B\x03\x16_R`\x0F` R`@_ UV[PPV[Pa'\x10\x81\x11a\x8F\xCBV[`\x01\x80`\xA0\x1B\x03\x16_R`\x18` R`@_ `\x01`\x01`@\x1B\x03`\x03\x81_T\x16\x92\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90UV[\x80T\x82\x10\x15ag\x02W_R` _ \x90`\x01\x1B\x01\x90_\x90V[\x81\x15a\t\xDAWa\x90y\x81argV[\x80_R`\x02` R`@_ `\xFF\x81T\x16\x15a\x91pW`\x02\x81\x01T\x80\x85\x10a\x91YWP`\x03\x81\x01T\x80\x15\x15\x80a\x91CW[a\x91$WP`\x04\x01a\x90\xBD\x84\x82TafjV[\x90U3_R`\x10` R`@_ \x90_R` R`@_ a\x90\xE0\x83\x82TafjV[\x90U` \x01Q`@Q\x91\x82R`\x01`\x01`\xA0\x1B\x03\x16\x90_` \x82\x01R\x7FuO\xFF\"\x05\xCA\x9F\x1A\x08\xAE\x1F8\xF4\x87\x83\x9B\xA7\xE1\x88\x95\xF0#\x89\x08\xEA\x8B\x88B\xD7BO\xBB`@3\x92\xA3V[`\x04\x85\x92\x01T\x90cK\x98PE`\xE0\x1B_R`\x04R`$R`DR`d_\xFD[P\x80a\x91S\x86`\x04\x85\x01TafjV[\x11a\x90\xAAV[\x84\x90c\x1E+\xE2\x11`\xE0\x1B_R`\x04R`$R`D_\xFD[` \x83\x01Qc\xF6\xF2K\x83`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04R`$\x90\xFD[\x81\x15a\t\xDAWa\x91\xA3\x81argV[\x90\x81_R`\x02` R`@_ `\xFF\x81T\x16\x15a\x93LW`\x02\x81\x01T\x80\x85\x10a\x91YWP`\x03\x81\x01T\x80\x15\x15\x80a\x936W[a\x91$WP`\x04\x01a\x91\xE8\x84\x82TafjV[\x90U3_R`\x10` R`@_ \x82_R` R`@_ a\x92\x0B\x84\x82TafjV[\x90U`\x05\x84\x10\x15a\x14\x82W\x83a\x92hW[` \x90\x81\x01Q`@Q\x93\x84R`\x01`\x01`\xA0\x1B\x03\x16\x93a\x92@\x92P\x90\x83\x01\x90aa\x8FV[\x7FuO\xFF\"\x05\xCA\x9F\x1A\x08\xAE\x1F8\xF4\x87\x83\x9B\xA7\xE1\x88\x95\xF0#\x89\x08\xEA\x8B\x88B\xD7BO\xBB`@3\x92\xA3V[a\x92q\x84a\x9C\xFFV[a\x92z\x84a\x9D\x8CV[\x913_R`\x11` R`@_ \x90_R` Ra\x92\xA4`@_ \x92`\x01`\x01`@\x1B\x03C\x16aggV[\x91`@Qa\x92\xB1\x81aa\xFDV[\x84\x81R` \x81\x01\x91a\x92\xC3\x87\x84an\x87V[`\x01`\x01`@\x1B\x03`@\x83\x01\x95\x16\x85R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x92\xF0\x91`\x01\x82\x01\x81Ua\x90QV[a\x08\x8EW`\x01\x91Q\x81U\x01\x90Q`\x05\x81\x10\x15a\x14\x82Wa\x92@\x93`\xFFh\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x84T\x92Q`\x08\x1B\x16\x92\x16\x90h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x17\x17\x90Ua\x92\x1CV[P\x80a\x93F\x86`\x04\x85\x01TafjV[\x11a\x91\xD5V[P` \x01Qc\xF6\xF2K\x83`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04R`$\x90\xFD[_\x81\x81R`\x04` R`@\x90 T\x80\x15araW_\x19\x81\x01\x81\x81\x11a\t\x9EW`\x03T_\x19\x81\x01\x91\x90\x82\x11a\t\x9EW\x81\x81\x03a\x93\xE3W[PPP`\x03T\x80\x15a\x0E\xD4W_\x19\x01a\x93\xC0\x81`\x03a\x8DKV[\x81T\x90_\x19\x90`\x03\x1B\x1B\x19\x16\x90U`\x03U_R`\x04` R_`@\x81 U`\x01\x90V[a\x94\x05a\x93\xF4a\x8D\x99\x93`\x03a\x8DKV[\x90T\x90`\x03\x1B\x1C\x92\x83\x92`\x03a\x8DKV[\x90U_R`\x04` R`@_ U_\x80\x80a\x93\xA6V[_\x81\x81R`\t` R`@\x90 T\x80\x15araW_\x19\x81\x01\x81\x81\x11a\t\x9EW`\x08T_\x19\x81\x01\x91\x90\x82\x11a\t\x9EW\x81\x81\x03a\x94\x8EW[PPP`\x08T\x80\x15a\x0E\xD4W_\x19\x01a\x94k\x81`\x08a\x8DKV[\x81T\x90_\x19\x90`\x03\x1B\x1B\x19\x16\x90U`\x08U_R`\t` R_`@\x81 U`\x01\x90V[a\x94\xB0a\x94\x9Fa\x8D\x99\x93`\x08a\x8DKV[\x90T\x90`\x03\x1B\x1C\x92\x83\x92`\x08a\x8DKV[\x90U_R`\t` R`@_ U_\x80\x80a\x94QV[\x90`\x01\x82\x01\x91\x81_R\x82` R`@_ T\x80\x15\x15_\x14a\x95oW_\x19\x81\x01\x81\x81\x11a\t\x9EW\x82T_\x19\x81\x01\x91\x90\x82\x11a\t\x9EW\x81\x81\x03a\x95:W[PPP\x80T\x80\x15a\x0E\xD4W_\x19\x01\x90a\x95\x1B\x82\x82a\x8DKV[\x81T\x90_\x19\x90`\x03\x1B\x1B\x19\x16\x90UU_R` R_`@\x81 U`\x01\x90V[a\x95Za\x95Ja\x8D\x99\x93\x86a\x8DKV[\x90T\x90`\x03\x1B\x1C\x92\x83\x92\x86a\x8DKV[\x90U_R\x83` R`@_ U_\x80\x80a\x95\x02V[PPPP_\x90V[`\x01\x80`\xA0\x1B\x03\x16_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`\x02`@_ \x01\x80T\x80\x15\x80\x15a\x8F\xB9Wa\x8A\xEBW\x82\x81\x10a\x8FuWPa\x8Fp\x82\x82TadlV[\x90\x81` \x91\x03\x12a\x05\xDDWQ\x90V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x81\x81R`\x06` R`@\x90 T\x90\x91\x16\x90\x81\x15a\x96]WP`@Qc\x11\xF9\xFB\xC9`\xE2\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x92\x90\x92R` \x90\x82\x90`D\x90\x82\x90_\x90Z\xF1\x90\x81\x15a\ruW_\x91a\x96.WP\x90V[\x90P` \x81=` \x11a\x96UW[\x81a\x96I` \x93\x83abNV[\x81\x01\x03\x12a\x05\xDDWQ\x90V[=\x91Pa\x96<V[\x90P`\xFF`\x07T\x16a\x96wW\x81adi\x910\x903\x90a\x97\x0CV[c\xF6\xF2K\x83`\xE0\x1B_R`\x04R`$_\xFD[`\xFF_\x80Q` a\x9F|\x839\x81Q\x91RT`@\x1C\x16\x15a\x96\xA5WV[c\x1A\xFC\xD7\x9F`\xE3\x1B_R`\x04_\xFD[\x90_` \x91\x82\x81Q\x91\x01\x82\x85Z\xF1\x15a\ruW_Q=a\x97\x03WP`\x01`\x01`\xA0\x1B\x03\x81\x16;\x15[a\x96\xE3WPV[cRt\xAF\xE7`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[`\x01\x14\x15a\x96\xDCV[`@Qc#\xB8r\xDD`\xE0\x1B` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x92\x83\x16`$\x82\x01R\x92\x90\x91\x16`D\x83\x01R`d\x80\x83\x01\x93\x90\x93R\x91\x81Raw\x96\x91a\x84\0`\x84\x83abNV[\x95\x94\x90\x93\x92\x91\x81Q\x90\x81\x15a\x99fWa\x97u\x91a\x97l\x91ad\x8CV[\x92\x82Q\x90ad\x8CV[\x90_[\x81Q\x81\x10\x15a\x99fW\x80`\x01`\x01`@\x1B\x03a\x97\x96`\x01\x93\x85ag\xC7V[Q\x16\x82\x80`\xA0\x1B\x03\x88\x16_R`\x1B` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` Rg\r\xE0\xB6\xB3\xA7d\0\0a\x98\xA3`@_ \x85\x80`\xA0\x1B\x03\x8D\x16\x93\x84_R`\x1C` R`@_ \x87\x80`\xA0\x1B\x03\x8D\x16_R` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` R`@_ \x94`\x01`\x01`@\x1B\x03_T\x16`\x01`\x01`@\x1B\x03`\x03\x85\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U_R`\x1E` R`@_ \x87\x80`\xA0\x1B\x03\x8D\x16_R` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R\x89\x89`@_ T\x91a\x99WW[P\x80a\x99\x19W[\x8A\x15a\x98\xCDW\x86\x82\x01a\x98\x7F\x8B\x82TafjV[\x90U`\x02\x82\x01a\x98\x90\x8A\x82TafjV[\x90U[\x89\x8B\x15a\x98\xACWa[H\x91afjV[\x04\x90U\x01a\x97xV[P\x89\x80\x82\x11\x15a\x98\xC5Wa\x98\xBF\x91adlV[\x90a[JV[PP_a\x98\xBFV[\x81\x87\x01\x80T\x8B\x81\x81\x11\x15a\x99\nWPP_\x90[U`\x02\x82\x01\x80T\x8A\x81\x81\x11\x15a\x98\xFBWPP_\x90[Ua\x98\x93V[a\x99\x04\x91adlV[\x90a\x98\xF5V[a\x99\x13\x91adlV[\x90a\x98\xE0V[\x83a\x99%\x82\x84TadyV[\x04\x85T\x80\x82\x11_\x14a\x99OWa\x99:\x91adlV[a\x99H\x88\x87\x01\x91\x82TafjV[\x90Ua\x98kV[PP_a\x99:V[a\x99`\x91adlV[\x89a\x98dV[PPPPPP\x90PV[`\x1FT_\x96\x92\x94\x91\x93\x91\x92\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x81\x15a\x9A\xA5W\x80Qa\x99\x99\x81aa\x9CV[a\x99\xA2\x81aa\x9CV[a\x9A\x92WP_\x95[\x15a\x9A2WP`\x1FT`\x01`\x01`\xA0\x1B\x03\x16\x91\x82;\x15a\x9A.W`@Qc\x16\xF6\x0E\xC5`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x94\x85\x16`\x04\x82\x01R\x94\x84\x16`$\x86\x01R\x94\x90\x92\x16`D\x84\x01R`d\x83\x01\x93\x90\x93Ra\xFF\xFF\x16`\x84\x82\x01R\x90\x82\x90\x82\x90`\xA4\x90\x82\x90\x84\x90Z\xF1a\x9A\x19WPPV[a\x9A$\x82\x80\x92abNV[a\x9A+WPV[\x80\xFD[\x86\x80\xFD[\x92\x91\x94\x95PP\x81;\x15a\x05\xDDW`@Qb\xF7K\xBF`\xE7\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x91\x82\x16`\x04\x82\x01R\x92\x81\x16`$\x84\x01R\x90\x93\x16`D\x82\x01R`d\x81\x01\x91\x90\x91R\x90_\x90\x82\x90`\x84\x90\x82\x90\x84\x90Z\xF1a\x9A\x88WPV[_aw\x96\x91abNV[` \x01Q`\x01`\x01`\xA0\x1B\x03\x16\x95a\x99\xAAV[PPPPPPPPV[\x90\x92\x96\x94\x91\x94` T`\x01\x80`\xA0\x1B\x03\x16\x94\x85\x15a\x9BUW\x85;\x15a\x05\xDDWa\x9BB_\x98\x89\x95a\xFF\xFF\x93a\x9B\x15\x9C`@Q\x9D\x8E\x9C\x8D\x9B\x8C\x9Ac\x08\xAE\xC5-`\xE3\x1B\x8CR`\x01\x80`\xA0\x1B\x03\x16`\x04\x8C\x01R`\x01\x80`\xA0\x1B\x03\x16`$\x8B\x01R`D\x8A\x01\x90aa\xA6V[`\x84\x88\x01R\x15\x15`\xA4\x87\x01Ra\x9B*\x81aa\x9CV[`\xC4\x86\x01Ra\x01 `\xE4\x86\x01Ra\x01$\x85\x01\x90ab\xC4V[\x91\x16a\x01\x04\x83\x01R\x03\x92Z\xF1a\x9A\x88WPV[PPPPPPPPPV[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x18` R`@\x90 `\x01\x81\x01T\x80\x15\x80\x15a\x9B\xAFW[a\x8B\rWa\x9B\x97`\x02\x91a\x9B\xA0\x94adyV[\x91\x01T\x90ad\x8CV[\x90\x81\x15a\x9B\xA9WV[`\x01\x91PV[P`\x02\x82\x01T\x15a\x9B\x84V[\x92\x90\x91\x81\x15a\x9CtW_\x92_\x94`\x01\x80`\xA0\x1B\x03\x16_R`\x11` R`@_ \x90_R` R`@_ _\x90\x80T\x91[\x82\x81\x10a\x9C\x9AWPPP\x82\x15a\x9CtW\x81\x80\x82\x10a\x9C\x92Wa\x9C\x0C\x91adlV[\x82\x81\x10\x15a\x9C\x8BW[\x80\x83\x11\x15a\x9C\x84Wa\x9C'\x90\x83adlV[\x80\x82\x10\x15a\x9C~WP\x80\x92[\x83\x15a\x9CtWa\xFF\xFF\x93a\nUa\x9CPa\x9Cp\x95as+\x94ad\x8CV[\x91a\x9Ck\x87a\x9Cba'\x10\x95\x84adyV[\x94\x16\x91\x86adlV[adyV[\x16\x90V[PPPPa'\x10\x90V[\x92a\x9C3V[P_a\x9C'V[P\x81a\x9C\x15V[PP_a\x9C\x0CV[a\x9C\xA4\x81\x83a\x90QV[P`\x01\x81\x01TC`\x01`\x01`@\x1B\x03\x82`\x08\x1C\x16\x11a\x9C\xC8W[PP`\x01\x01a\x9B\xEBV[\x97a\nUa\x9C\xF7\x92\x98a\xFF\xFFa\x9C\xEFa\x9C\xE6`\xFF`\x01\x98\x9E\x16a\x8B\x1CV[\x9BT\x80\x93afjV[\x9A\x16\x90a\x9E5V[\x96\x90_a\x9C\xBEV[\x90`\x05\x82\x10\x15\x90\x81a\x14\x82W\x82\x15\x80\x15a\x9D\x7FW[\x82\x81\x15a\x9DoW[\x81\x15a\x9D_W[\x81\x15a\x9DOW[Pa\x9DJWPa\x14\x82W`\xFF\x90c\xAA\xE7X\xA1`\xE0\x1B_R\x16`\x04R`$_\xFD[\x91PPV[\x90Pa\x14\x82W`\x04\x83\x14\x82a\x9D*V[\x90Pa\x14\x82W`\x03\x83\x14\x82a\x9D#V[\x90Pa\x14\x82W`\x02\x83\x14\x82a\x9D\x1CV[P_\x91P`\x01\x83\x14a\x9D\x14V[`\x05\x81\x10\x15a\x14\x82W`\x01\x81\x14a\x9D\xCFW`\x02\x81\x14a\x9D\xC7W`\x03\x81\x14a\x9D\xBFW`\x04\x14a\x9D\xB8W_\x90V[b\xEDN\0\x90V[Pbv\xA7\0\x90V[PbO\x1A\0\x90V[Pb'\x8D\0\x90V[\x90a\x9D\xFBWP\x80Q\x15a\x9D\xECW\x80Q\x90` \x01\xFD[c\xD6\xBD\xA2u`\xE0\x1B_R`\x04_\xFD[\x81Q\x15\x80a\x9E,W[a\x9E\x0CWP\x90V[c\x99\x96\xB3\x15`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[P\x80;\x15a\x9E\x04V[\x81\x81\x02\x91\x90__\x19\x83\x83\t\x84\x80\x82\x10\x91\x03\x81\x81\x14a\x9EsW\x03`\x01\x11\x15a\x9EaWP\x90`\x01\x91\t\x90\x03\x90V[cNH{q\x90R`\x11` R`$`\x1C\xFD[PPPPP\x90V\xFE/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\xE3I\x18\xFF\x1Cp\x84\x97\0h\xB5?\xD7\x1A\xD6\xD8\xB0N\x9F\x15\xD3\x88l\xBF\0dC\xE6\xCD\xC5.\xA6i\x89!\x94\xD2\xF1\xEBMH\xBD\t\xF1f\xBF\xCE\x17T\xA6\x81\xE8\xE1p\x11\xB3\xE1+q\x0C\xCEV\xA8{\x12\xB4.\x8A\x16\x0F`d\xDC\x95\x9Co%\x1E:\xF0u\n\xD2\x13\xDB\xEC\xF5s\xB4q\rg\xD6\xC2\x8E9\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x9Bw\x9B\x17B-\r\xF9\"#\x01\x8B2\xB4\xD1\xFAF\xE0qr=h\x17\xE2Hm\0;\xEC\xC5_\0\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\xA1dsolcC\0\x08\x1A\0\n",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c80627910d01461586457806301ffc9a71461580e578063026e402b146157d957806303587c1d1461573e57806303780211146156b157806305d64e38146156895780630a8ddc5e146156465780630aa8b110146155a85780630c8833ce1461543457806315049a5a146152e0578063168f6865146150f457806318056dc2146150d85780631ba9998b14614fee57806323cc270014614c2c578063248a9ca314614c0e5780632614233514614bd557806328e70ecc14614b745780632acde09814614a445780632e40f7fb14614a1e5780632ee663b81461495b5780632f2ff15d1461492a57806330224fc8146148f257806331cc13ba146147bb57806332273f6114614797578063354ebef9146146b8578063356924ea1461467c57806336568abe146146385780633dcad9db146144755780633f4ba83a146143f757806344aff252146142b557806344d1480b14614018578063453eccea14613ffc578063461cc23b14613fc6578063486398c314613f8e5780634962f88f146117845780634c4ede2d14613f6d5780634d99dd1614613c605780634de8addc14613c375780634e9c929a146124ab5780634f1ef28614613a2e5780635095af6414613a0757806352d1902d146139a157806354de2320146139855780635722d5121461381657806357601c5d146137c8578063585cd34b146137085780635c975abb146136da5780635fdc8f2d14613684578063615d24de1461366157806366c3687514612c1b57806368a9f19c14613638578063697d08f914612d365780636d70f7ae146135f65780636ec3ab67146134e4578063708075281461344457806372b5032d14612bbf57806375b238fc1461340a57806377ab2cf3146133e85780637b76fe5e146133865780637b9996c5146132345780637c6f3158146132175780637d6941c6146131e25780637df92ada146131c55780638456cb5914613154578063859caa1814612e7b5780638770355014612da05780638a19c8bc14612d7b5780638a7fe60f14612d3b5780638c5b4ae714612d365780638d795d5014612cf257806391d1485414612c9d5780639494f42614612c5c5780639608567314612c1b5780639722f4b914612bbf57806397feb92614612b8a5780639e87058514612b6d5780639e8c49d414612ae5578063a217fddf14612acb578063a299e298146129de578063a3b9c5c2146128ca578063a457af3d146127a1578063a4b32de814612767578063a7fa6f981461274b578063aac6aa9c14612722578063aaf5eb6814612700578063ad3cb1cc146126a2578063b0dfce061461266e578063b39bcf3f14611b5b578063b54b2b9e1461264c578063ba05bbf51461262d578063c07449e2146125d1578063c35082a914612507578063c550d938146124ab578063c735302514612427578063cadd550c14612357578063cb15038b146122e6578063cbb6d6bd1461200d578063cea9d26f14611e5e578063d0e30db014611e3b578063d1736ba714611d0f578063d27a6f0614611cf2578063d547741f14611cbc578063d655b92a14611b93578063d673e0b914611b5b578063d775cb6114611b15578063d9e257ef14611a71578063db8a173a14611a4b578063dc972ccc14611997578063defe20531461196f578063e0a5825b146117a0578063e1a4521814611784578063e1ee4bcc146114e6578063e4e88de814611496578063eb47353314611416578063f0b52bb414611221578063f340c0d01461110f578063f38c7c4e146110c7578063f3c4d8a014611042578063f3c9b31114611025578063f46913bb14610fe8578063f7cb789a14610fc0578063f8fd979514610afc578063fbcc7b3d14610ab9578063fbec486114610a6e578063fc5e7e09146109e9578063fc8a91af146105e15763fd7d3dbc0361000e57346105dd576105ca6105c46105a63661633a565b6105b596929596949394616816565b6105bd616716565b369161668e565b9361841e565b60015f80516020619f5c83398151915255005b5f80fd5b346105dd576105ef36616300565b906105f8616816565b81156109da576001600160a01b031690816109be57604051610619816161e2565b5f81525f6020820152915b61062d83617267565b9260018060a01b03851694855f52601860205260405f20600281015490811580156109b2575b1561096c57505083905b5f955f5b335f52601360205260405f205481101561096057335f52601360205261068a8160405f206166e9565b5080546001600160a01b03168a1480610949575b6106ab5750600101610661565b92939495969750505f90335f52601560205260405f205f918154925b8381106108d557505050506106e090600183015461646c565b8381106108b55750335f52601560205260405f209361071160ff60036001600160401b035f54169401541693616440565b906040519261071f84616218565b8984526020840191825260408401968688526060850191825260808501956107468161619c565b865260a085019384528054600160401b8110156108a15761076c9160018201815561674e565b95909561088e57935185546001600160a01b0319166001600160a01b0391909116178555905180518a97600495610818949390926107e29160018a01916107bc906107b68161619c565b836167db565b602001518154610100600160a81b03191660089190911b610100600160a81b0316179055565b5160028701556001600160401b038060038801935116166001600160401b031983541617825551906108138261619c565b6167f3565b519101556001600160401b036001946108385f54838160c01c9116616767565b9060405193845260208401521660408201527f06325d83435da87657b063c6142a5b91a66a7e811827d082d624287a9953c4ba60603392a45b1561087857005b6309078cff60e21b5f523360045260245260445ffd5b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b6108c0879184618ab7565b6388c4fe8f60e01b5f5260045260245260445ffd5b8b6108e0828561674e565b50546001600160a01b03161480610923575b6108ff575b6001016106c7565b9361091b6001916002610912888761674e565b5001549061666a565b9490506108f7565b508161094361093e6001610937858861674e565b5001616795565b617267565b146108f2565b508261095a61093e60028401616795565b1461069e565b50505050505050610871565b8161097e600161098393015488616479565b61666a565b5f1981019190821161099e576109989161648c565b9061065d565b634e487b7160e01b5f52601160045260245ffd5b50600181015415610653565b6040516109ca816161e2565b6001815282602082015291610624565b631f2a200560e01b5f5260045ffd5b346105dd5760203660031901126105dd57610a02616121565b5f906001600160a01b0316815b815f52601360205260405f2054831015610a6357610a5b600191835f526013602052610a55610a418660405f206166e9565b5084808060a01b0382541691015490618ab7565b9061666a565b920191610a0f565b602090604051908152f35b6105ca6105c4610a7d3661633a565b610a8c96929596949394616816565b610a94616716565b6001600160a01b038416610aaa576105bd617777565b610ab48585617cea565b6105bd565b346105dd5760203660031901126105dd57610ad2616121565b610ada616d1a565b602080546001600160a01b0319166001600160a01b0392909216919091179055005b346105dd575f3660031901126105dd57610b14616716565b5f335f52601260205260405f20905f90825492610b3084616677565b610b3d604051918261624e565b848152601f19610b4c86616677565b01366020830137610b5c85616677565b94610b6a604051968761624e565b808652601f19610b7982616677565b015f5b818110610f9d575050610b8e81616677565b93610b9c604051958661624e565b818552601f19610bab83616677565b013660208701375f6001600160401b035f5416906001600160401b0360015416905b8987868310610ef557898b918983610d9f575b50505f5b828110610bfe5760015f80516020619f5c83398151915255005b610c0881856167c7565b5190610c1481846167c7565b51918051610c218161619c565b610c2a8161619c565b610cdb5750905f80808093335af1610c40617748565b5015610c9d576001905b818060a01b036020610c5c83886167c7565b51015116610c6a82856167c7565b516040519081527fd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb60203392a301610be4565b60405162461bcd60e51b815260206004820152601660248201527513985d1a5d99481d1c985b9cd9995c8819985a5b195960521b6044820152606490fd5b602090810180516001600160a01b039081165f908152600690935260409092205490911692908315610d80575060405163f3fef3a360e01b8152336004820152602481019190915291602090839060449082905f905af1918215610d7557600192610d47575b50610c4a565b610d679060203d8111610d6e575b610d5f818361624e565b8101906195c1565b5085610d41565b503d610d55565b6040513d5f823e3d90fd5b5160019350610d9a919033906001600160a01b03166183c4565b610c4a565b909192935f945f5b8454811015610e9657610dba81856167c7565b5115610dc9575b600101610da7565b95868103610de5575b610ddd600191616787565b969050610dc1565b610def8786618405565b50610dfa8287618405565b92909261088e578282610ddd93600195141580610e1d575b505050915050610dd2565b6001600160401b03600281938193610e56575b8881015489870155015416920191166001600160401b0319825416179055898080610e12565b610e6460ff825416876167db565b80548654610100600160a81b031916600891821c60a08c901b8c90031690911b610100600160a81b0316178655610e30565b5091509193925b845484811115610ee8578015610ed4575f1901610eba8187618405565b61088e576002815f80935582600182015501558555610e9d565b634e487b7160e01b5f52603160045260245ffd5b5091935091508380610be0565b610f17846001600160401b036002610f0e878396618405565b50015416616767565b16841015610f29575b50600101610bcd565b610f8e8a95610f69849c610f9494610f59610f53888f8f610f4d60019c8d926167c7565b52618405565b50616795565b610f6383836167c7565b526167c7565b5083610f758d8c618405565b500154610f82888d6167c7565b52836109128d8c618405565b94616787565b98905089610f20565b602090604051610fac816161e2565b5f81525f8382015282828b01015201610b7c565b346105dd575f3660031901126105dd5760206001600160401b035f5460401c16604051908152f35b346105dd5760403660031901126105dd576001600160a01b03611009616121565b165f52600a602052602060243560405f20541015604051908152f35b346105dd575f3660031901126105dd57602060405162ed4e008152f35b346105dd5760203660031901126105dd5760043561ffff81168082036105dd576127109061106e616d1a565b11611094576001805461ffff60801b191660809290921b61ffff60801b16919091179055005b60405162461bcd60e51b815260206004820152600b60248201526a496e76616c69642042505360a81b6044820152606490fd5b60203660031901126105dd5760043560058110156105dd576105ca906110eb616816565b6110f3616716565b6040516110ff816161e2565b5f81525f60208201523490619194565b346105dd5760203660031901126105dd576001600160a01b03611130616121565b165f52601260205260405f2080549061114882616677565b91611156604051938461624e565b8083526020830180925f5260205f205f915b8383106111da578486604051918291602083019060208452518091526040830191905f5b81811061119a575050500390f35b91935091602060806001926001600160401b03604088516111bc8482516161a6565b8581015182850152015116606082015201940191019184939261118c565b600360206001926040516111ed816161fd565b6111f686616795565b815284860154838201526001600160401b036002870154166040820152815201920192019190611168565b346105dd5760c03660031901126105dd5761123a616121565b611242616137565b906044356064359060a4359261ffff84168094036105dd57611262616d89565b6001600160a01b031693611277851515616407565b6001600160a01b03169161128c8315156165c8565b60405163551c457b60e11b81526004810186905293602085602481875afa938415610d7557600561135161ffff926112ef6040987f9a4c59c56153245e23dcb8000e301b9a5e35b8e6693c5cdbf3b6a2aa0f8a37ea9a5f916113e7575b5061661e565b895f526006602052875f20816bffffffffffffffffffffffff60a01b8254161790558751908a7fc47df14ad9309b59073546f93dbe3115ed09c8b206d940f8441ddb07f745b10b5f80a3611342816161e2565b60018152896020820152617267565b86519061135d82616218565b60018252602082018781528883018781526060840191608435835260808501935f855260a086019889525f5260026020526113aa8b5f2095511515869060ff801983541691151516179055565b5160018501555160028401555160038301555160048201550191511661ffff198254161790556113d985618dc6565b5082519182526020820152a2005b611409915060203d60201161140f575b611401818361624e565b810190616606565b8c6112e9565b503d6113f7565b346105dd5760203660031901126105dd576001600160a01b03611437616121565b16805f52600960205260405f205415158061145a575b6020906040519015158152f35b505f52600a60205260ff600160405f20015460201c166003811015611482576020901561144d565b634e487b7160e01b5f52602160045260245ffd5b346105dd5760203660031901126105dd5760206114de6001600160a01b036114bc616121565b16805f52600a835260405f2054905f5260188352600260405f2001549061666a565b604051908152f35b346105dd5760403660031901126105dd576114ff616121565b6024359061150b616816565b81156109da576001600160a01b031690816117695760405161152c816161e2565b5f81525f60208201525b61153f81617267565b335f52601060205260405f20815f5260205260405f209081549061156760018401548361646c565b905f90335f52601160205260405f20905f5260205260405f205f908054915b82811061171d575050508083111561171657856115a3828561646c565b106116ff57508481106116e85750836115bb9161646c565b9055335f52601260205260405f206001600160401b035f541690604051926115e2846161fd565b83526020830190848252604084019283528054600160401b8110156108a15761161091600182018155618405565b93909361088e576001600160401b039260029261166385935161163d81516116378161619c565b896167db565b602001518754610100600160a81b03191660089190911b610100600160a81b0316178755565b5160018601555116920191166001600160401b03198254161790557f91eff7d39d2499d76ac21a1903a95a88f31589cb07b1ffdfb61db9f7cd8a39786116e36116c26001600160401b035f54166001600160401b036001541690616767565b604080519485526001600160401b0390911660208501523393918291820190565b0390a3005b849063adb9e04360e01b5f5260045260245260445ffd5b8590638ec3321160e01b5f5260045260245260445ffd5b855f6115a3565b6117278183619051565b506001600160401b0360014392015460081c1611611748575b600101611586565b926117616001916117598685619051565b50549061666a565b939050611740565b604051611775816161e2565b60018152826020820152611536565b346105dd575f3660031901126105dd5760206040516127108152f35b346105dd5760403660031901126105dd576117b9616121565b602435906117c5616816565b6117cd616716565b335f52600960205260405f205461195c576001600160a01b031680156119495761180b6040516117fc816161e2565b60018152826020820152617267565b5f52600260205260405f2060ff81541615611936576001839101549182821061191f5761183c92503090339061970c565b61184533618d60565b50604051611852816161c7565b818152602081015f8152604082015f815263ffffffff80600160608601955f8752335f52600a60205260405f2090518155019351161663ffffffff19835416178255516003811015611482576118e0926118b46001600160401b039284616f23565b5182546cffffffffffffffff00000000001916911660281b6cffffffffffffffff000000000016179055565b6040519081527fbc11617e575d658c74e921c8df22f8e48566072fa78145a6cfe18420bf8d0c4e60203392a260015f80516020619f5c83398151915255005b50506322df051360e11b5f5260045260245260445ffd5b5063f6f24b8360e01b5f5260045260245ffd5b63f6f24b8360e01b5f525f60045260245ffd5b63866b0dcf60e01b5f523360045260245ffd5b346105dd575f3660031901126105dd57601f546040516001600160a01b039091168152602090f35b346105dd5760203660031901126105dd576001600160a01b036119b8616121565b165f52600c60205260405f20604051806020835491828152019081935f5260205f20905f5b818110611a3557505050816119f391038261624e565b604051918291602083019060208452518091526040830191905f5b818110611a1c575050500390f35b8251845285945060209384019390920191600101611a0e565b82548452602090930192600192830192016119dd565b346105dd575f3660031901126105dd5760206001600160401b0360015416604051908152f35b5f3660031901126105dd57611a84616816565b611a8c616716565b335f52600a60205260405f2060ff600182015460201c16600381101561148257611b025734156109da57611ac134825461666a565b90556040513481527f614a3fa8467eb54cb60af3aab440279837c9fcd75c5a2617fe0af9c6e5e60e8360203392a260015f80516020619f5c83398151915255005b6371ab6ad560e11b5f523360045260245ffd5b346105dd575f3660031901126105dd57611b42604051611b34816161e2565b5f81525f6020820152617267565b5f5260026020526020600160405f200154604051908152f35b346105dd5760203660031901126105dd5760206114de611b79616121565b6001600160a01b03165f908152600a602052604090205490565b346105dd5760403660031901126105dd57611bac616121565b611bb4616137565b90611bbd616d89565b6001600160a01b0316908115611c77576001600160a01b031690611be28215156165c8565b60405163551c457b60e11b815260048101829052602081602481865afa8015610d7557611c15915f91611c58575061661e565b5f81815260066020526040812080546001600160a01b031916841790557fc47df14ad9309b59073546f93dbe3115ed09c8b206d940f8441ddb07f745b10b9080a3005b611c71915060203d60201161140f57611401818361624e565b846112e9565b60405162461bcd60e51b815260206004820152601d60248201527f43616e6e6f7420736574206164617074657220666f72206e61746976650000006044820152606490fd5b346105dd5760403660031901126105dd57610018600435611cdb616137565b90611ced611ce8826163e9565b616e41565b6176ac565b346105dd575f3660031901126105dd5760206040516276a7008152f35b346105dd575f3660031901126105dd57611d27616716565b335f52600a60205260405f2060018101805460ff8160201c16600381101561148257600203611e28576001600160401b03805f54169160281c166001600160401b0360015460401c16906001600160401b03611d838383616767565b168310611dfe57611dc65f8080808989828254925564010000000064ff0000000019825416179055611db43361941b565b50335af1611dc0617748565b506182c7565b337f120599f8830115ed973189f8f4947cc793fcd90a15d47c4d6ad8d1a3f15af7345f80a260015f80516020619f5c83398151915255005b6001600160401b039291611e1191616767565b90631b04d91d60e21b5f526004521660245260445ffd5b639923c53960e01b5f523360045260245ffd5b5f3660031901126105dd57611e4e616816565b611e56616716565b6105ca617777565b346105dd57611e6c36616300565b335f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260409020549192909160ff1615611ff6576001600160a01b03831615611fbd578115611f87576001600160a01b03165f81815260046020526040902054909290611f42575f838152600660205260409020546001600160a01b0316611efd57610018926183c4565b60405162461bcd60e51b815260206004820152601b60248201527f43616e6e6f7420726573637565206164617074656420617373657400000000006044820152606490fd5b60405162461bcd60e51b815260206004820152601e60248201527f43616e6e6f7420726573637565207265676973746572656420617373657400006044820152606490fd5b60405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b6044820152606490fd5b60405162461bcd60e51b8152602060048201526011602482015270125b9d985b1a59081c9958da5c1a595b9d607a1b6044820152606490fd5b63e2517d3f60e01b5f52336004525f60245260445ffd5b346105dd5760803660031901126105dd57612026616121565b6064359061ffff821682036105dd575f80516020619f7c833981519152549160ff8360401c1615926001600160401b038116801590816122de575b60011490816122d4575b1590816122cb575b506122bc5767ffffffffffffffff1981166001175f80516020619f7c8339815191525568380000000000000000926121289185612290575b506120b4619689565b6120bc619689565b6120c4619689565b6120cc619689565b60ff195f80516020619f3c83398151915254165f80516020619f3c833981519152556120f6619689565b6120fe619689565b60015f80516020619f5c8339815191525561211881616fcd565b5061212281617064565b5061711d565b50612138604051611b34816161e2565b61ffff600560405161214981616218565b6001815260208101602435815260408201604435815260608301905f825260808401925f845260a085019761271089525f52600260205261219d60405f2095511515869060ff801983541691151516179055565b5160018501555160028401555160038301555160048201550191511661ffff19825416179055600160ff196005541617600555601c600154781c0000000000000000000000000000546000000000000000016001600160401b0360801b4260801b16175f5567ffffffffffffffff60401b199261ffff60801b9060801b169071ffff0000000000000000ffffffffffffffff19161717161760015561223e57005b60ff60401b195f80516020619f7c83398151915254165f80516020619f7c833981519152557fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2602060405160018152a1005b68ffffffffffffffffff191668010000000000000001175f80516020619f7c83398151915255856120ab565b63f92ee8a960e01b5f5260045ffd5b90501585612073565b303b15915061206b565b859150612061565b346105dd5760603660031901126105dd576122ff616121565b60443560058110156105dd57612313616816565b61231b616716565b6001600160a01b03821680156119495761233b6105ca93602435906195d0565b9060405190612349826161e2565b600182526020820152619194565b346105dd5760203660031901126105dd576001600160a01b03612378616121565b16805f52600a60205260405f2060ff600182015460201c166003811015611482576123f5576001905491805f526018602052600260405f20015490604051936123c0856161e2565b8452602084019182526001600160401b035f54165f52600e60205260405f20905f5260205260405f2092518355519101555f80f35b60405162461bcd60e51b815260206004820152600a6024820152694e6f742061637469766560b01b6044820152606490fd5b346105dd5760203660031901126105dd5761244061614d565b335f52600a60205260ff600160405f20015460201c16600381101561148257611b0257335f52600c6020526124836001600160401b0360405f2092168092618e16565b50337fb6d5e45d77b8967cff525b375be6e07f99ca5af91d88724ac1237aafe295d50e5f80a3005b346105dd5760403660031901126105dd576124c461614d565b6001600160401b036124d4616137565b91165f52605460205260405f209060018060a01b03165f5260205260206001600160401b0360405f205416604051908152f35b346105dd5760403660031901126105dd57612520616121565b612528616137565b612530616592565b50612539616592565b506001600160a01b0316806125b55750604051612555816161e2565b5f81525f6020820152905b6001600160a01b03165f9081526010602052604090209061258090617267565b5f526020526125b161259460405f206165aa565b604051918291829190916020806040830194805184520151910152565b0390f35b604051906125c2826161e2565b60018252602082015290612560565b346105dd5760403660031901126105dd576125ea61614d565b6001600160401b036125fa616137565b91612603616592565b50165f52600e60205260405f209060018060a01b03165f526020526125b161259460405f206165aa565b346105dd575f3660031901126105dd5760205f5460c01c604051908152f35b346105dd575f3660031901126105dd57602060ff600754166040519015158152f35b346105dd575f3660031901126105dd57612686616716565b61268e618305565b5060015f80516020619f5c83398151915255005b346105dd575f3660031901126105dd5760408051906126c1818361624e565b600582526020820191640352e302e360dc1b83528151928391602083525180918160208501528484015e5f828201840152601f01601f19168101030190f35b346105dd575f3660031901126105dd576020604051670de0b6b3a76400008152f35b346105dd5760203660031901126105dd5761001861273e616121565b612746616d1a565b61761b565b346105dd575f3660031901126105dd5760206040516132c88152f35b346105dd575f3660031901126105dd5760206040517fb1fadd3142ab2ad7f1337ea4d97112bcc8337fc11ce5b20cb04ad038adf998198152f35b346105dd5760403660031901126105dd576127ba616121565b6127c2616163565b905f60c06040516127d281616233565b8281528260208201528260408201528260608201528260808201528260a0820152015260018060a01b03165f5260516020526001600160401b0360405f2091165f5260205260e060405f2060405161282981616233565b8154916001600160401b0383169283835260208301906001600160401b038160401c1682526001600160401b03604085019160801c1681526001600160401b0360018401549160608601928352816002860154946080880195865260c0600460038901549860a08b01998a520154980197885260405198895251166020880152511660408601525160608501525160808401525160a08301525160c0820152f35b346105dd5760603660031901126105dd576128e3616121565b6128eb616163565b506044359061271061290661ffff60015460801c1684616479565b049161293e612915848361646c565b9260018060a01b03811694855f52601a60205261293760405f2091825461666a565b905561901b565b825f52601860205260405f20906001820191825415155f146129ad57670de0b6b3a7640000840293808504670de0b6b3a7640000149015171561099e576129a161299a5f80516020619ebc83398151915295602095549061648c565b825461666a565b90555b604051908152a2005b50602091505f80516020619ebc83398151915292845f52601a83526129d760405f2091825461666a565b90556129a4565b346105dd5760203660031901126105dd576001600160a01b036129ff616121565b16805f52600d60205260405f205490612a1782616677565b91612a25604051938461624e565b808352612a3181616677565b602084019290601f19013684375f5b828110612a94578385604051918291602083019060208452518091526040830191905f5b818110612a72575050500390f35b82516001600160a01b0316845285945060209384019390920191600101612a64565b600190825f52600d602052612aac8160405f20618d4b565b838060a01b0391549060031b1c16612ac482886167c7565b5201612a40565b346105dd575f3660031901126105dd5760206040515f8152f35b346105dd5760c03660031901126105dd57612afe616121565b612b06616163565b612b0e616179565b906064356001600160401b0381116105dd57366023820112156105dd5780600401356001600160401b0381116105dd5736602460608302840101116105dd576020946114de94612b5c616df8565b60a435946024608435950192617d43565b346105dd575f3660031901126105dd57602060405162278d008152f35b346105dd5760403660031901126105dd576105ca612ba6616121565b612bae616816565b612bb6616716565b60243590617cea565b346105dd5760403660031901126105dd57612bd861614d565b6001600160401b03612be8616137565b91165f52605360205260405f209060018060a01b03165f5260205260206001600160401b0360405f205416604051908152f35b346105dd5760203660031901126105dd576001600160a01b03612c3c616121565b165f52605260205260206001600160401b0360405f205416604051908152f35b346105dd5760603660031901126105dd57612c75616121565b612c7d616163565b906044356001600160a01b03811681036105dd576020926114de926164aa565b346105dd5760403660031901126105dd57612cb6616137565b6004355f525f80516020619f1c83398151915260205260405f209060018060a01b03165f52602052602060ff60405f2054166040519015158152f35b346105dd5760a03660031901126105dd5760206114de612d10616121565b612d18616163565b90612d21616179565b612d29616df8565b608435926064359261782c565b61628a565b346105dd5760203660031901126105dd576001600160a01b03612d5c616121565b165f526006602052602060018060a01b0360405f205416604051908152f35b346105dd575f3660031901126105dd5760206001600160401b035f5416604051908152f35b346105dd575f3660031901126105dd57335f52600a602052600160405f200160ff815460201c16600381101561148257611b0257612e219064020000000064ff00000000198254161781556001600160401b035f54166cffffffffffffffff000000000082549160281b16906cffffffffffffffff00000000001916179055565b612e446001600160401b035f54166001600160401b0360015460401c1690616767565b6001600160401b03604051911681527ffd47ed8e653fba5e6e9fcaa947419ca2334b3972ce196132ec69708574d6d35a60203392a2005b346105dd5760403660031901126105dd57600435612e97616163565b90612ea0616816565b335f52601360205260405f205481101561314257335f526013602052612ec98160405f206166e9565b5090600160ff600384015416612ede8161619c565b0361313357335f52601460205260405f20815f5260205260405f208054926001841115613124576001600160401b038516935f1993905f5b8181106130f1575b50505f1984146130de57335f908152601e6020908152604080832085546001600160a01b0316845282528083208884529091528120805491905583545f198101959190861161099e57612f986001600160401b03612f89612f8289612fb69561648c565b9888616e93565b90549060031b1c169286616e93565b81939154906001600160401b03809160031b9316831b921b19161790565b905582548015610ed4575f1901612fcd8185616e93565b6001600160401b0382549160031b1b1916905583555f5b835481101561304c57335f908152601e6020908152604080832086546001600160a01b031684529091529020600191906001600160401b03806130278489616e93565b90549060031b1c16165f5260205260405f2061304487825461666a565b905501612fe4565b868383886040519081527fc38cef0d003bc8a9982db0d994b2ea048946028e9255cc061a56abcbb7d548a160203392a36020546001600160a01b03168061308f57005b81546001600160a01b031690803b156105dd5760025f80946130ca60405197889687958694632d01c5cb60e01b865201903360048601616ed1565b03925af16130d457005b5f6100189161624e565b84633062236b60e11b5f5260045260245ffd5b866001600160401b036131048388616e93565b90549060031b1c161461311957600101612f16565b945087905080612f1e565b63301ac92560e21b5f5260045ffd5b63138dfed560e11b5f5260045ffd5b630b21815d60e11b5f5260045260245ffd5b346105dd575f3660031901126105dd5761316c616d1a565b613174616816565b600160ff195f80516020619f3c8339815191525416175f80516020619f3c833981519152557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b346105dd575f3660031901126105dd576020604051624f1a008152f35b346105dd5760203660031901126105dd576004356001600160a01b03811681036105dd5761268e90613212616716565b617798565b346105dd575f3660031901126105dd576020600854604051908152f35b346105dd5760403660031901126105dd576001600160a01b03613255616121565b165f52601460205260405f206024355f5260205260405f20604051908190602081549384815201905f5260205f20925f935b81600386011061333a57916125b19484926132c4945491818110613320575b818110613303575b8181106132e6575b106132d8575b50038261624e565b6040519182916020835260208301906162c4565b60c01c8152602001856132bc565b9260206001916001600160401b038560801c1681520193016132b6565b9260206001916001600160401b038560401c1681520193016132ae565b9260206001916001600160401b03851681520193016132a6565b916001608060049285546001600160401b03811682526001600160401b038160401c1660208301526001600160401b0381841c16604083015260c01c6060820152019301940193613287565b346105dd5760203660031901126105dd576004358015158091036105dd5760207fe2c375ae70efa82f7f1d8e9555f83f2df5c692d66834ebabba9d897fca46f3df916133d0616d89565b60ff196007541660ff821617600755604051908152a1005b346105dd575f3660031901126105dd57602060ff600554166040519015158152f35b346105dd575f3660031901126105dd5760206040517fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c217758152f35b346105dd5760203660031901126105dd5761345d616121565b613465616d89565b6001600160a01b0316806134c657613482604051611b34816161e2565b60ff19600554166005555b5f52600260205260405f2060ff1981541690557ffc9274ad64ab0a7d8dedd8c9297fb4e25d7a17eb057457c6bcf2a8f13dc8859c5f80a2005b6134d56040516117fc816161e2565b6134de82619370565b5061348d565b346105dd5760203660031901126105dd576134fd616121565b5f60a060405161350c81616218565b8281526020810183905260408101839052606081018390526080810183905201526001600160a01b0316806135d8575061354b604051611b34816161e2565b5f52600260205260c060405f2061ffff60405161356781616218565b60ff8354161515928382526001810154602083019081526002820154604084019081526003830154916060850192835260a0866005600487015496608089019788520154169501948552604051968752516020870152516040860152516060850152516080840152511660a0820152f35b60405161354b916135e8826161e2565b600182526020820152617267565b346105dd5760203660031901126105dd57602061362e6001600160a01b0361361c616121565b165f52600960205260405f2054151590565b6040519015158152f35b346105dd5760203660031901126105dd57610018613654616121565b61365c616d1a565b616f48565b346105dd5760203660031901126105dd5760206114de61367f616121565b616440565b346105dd5760403660031901126105dd5761369d616121565b6136a5616163565b9060018060a01b03165f52601b6020526001600160401b0360405f2091165f526020526020600260405f200154604051908152f35b346105dd575f3660031901126105dd57602060ff5f80516020619f3c83398151915254166040519015158152f35b346105dd5760203660031901126105dd57613721616121565b613729616d89565b6001600160a01b039081165f818152600660205260409020549091161561378b575f81815260066020526040812080546001600160a01b03191690557fdf980d21d8c7bb34800e668dbe003299093bac8e693614151d3c57f73f98a93d9080a2005b60405162461bcd60e51b8152602060048201526015602482015274139bc81859185c1d195c881c9959da5cdd195c9959605a1b6044820152606490fd5b346105dd5760203660031901126105dd576137e1616121565b6001600160a01b03165f9081525f80516020619edc833981519152602090815260409182902054915160ff9092161515825290f35b346105dd5760203660031901126105dd576001600160a01b03613837616121565b165f52601560205260405f2080549061384f82616677565b9161385d604051938461624e565b8083526020830180925f5260205f205f915b83831061390e578486604051918291602083019060208452518091526040830191905f5b8181106138a1575050500390f35b91935091602060e060019260a087518580831b0381511683526138ca85820151868501906161a6565b604081015160608401526001600160401b03606082015116608084015260808101516138f58161619c565b82840152015160c0820152019401910191849392613893565b6005602060019260405161392181616218565b848060a01b038654168152613937858701616795565b838201526002860154604082015260ff60038701546001600160401b038116606084015260401c166139688161619c565b6080820152600486015460a082015281520192019201919061386f565b346105dd575f3660031901126105dd576020604051612ee08152f35b346105dd575f3660031901126105dd577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036139f85760206040515f80516020619e9c8339815191528152f35b63703e46dd60e11b5f5260045ffd5b346105dd575f3660031901126105dd5760206040515f80516020619efc8339815191528152f35b60403660031901126105dd57613a42616121565b602435906001600160401b0382116105dd57366023830112156105dd57816004013590613a6e8261626f565b91613a7c604051938461624e565b808352602083019336602483830101116105dd57815f926024602093018737840101526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016308114908115613c15575b506139f857613ae1616d1a565b6040516352d1902d60e01b81526001600160a01b0382169390602081600481885afa5f9181613be1575b50613b235784634c9c8ce360e01b5f5260045260245ffd5b805f80516020619e9c833981519152869203613bcf5750823b15613bbd575f80516020619e9c83398151915280546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a2825115613ba4575f8091610018945190845af4613b9e617748565b91619dd7565b50505034613bae57005b63b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b632a87526960e21b5f5260045260245ffd5b9091506020813d602011613c0d575b81613bfd6020938361624e565b810103126105dd57519086613b0b565b3d9150613bf0565b5f80516020619e9c833981519152546001600160a01b03161415905084613ad4565b346105dd575f3660031901126105dd5760206001600160401b0360015460401c16604051908152f35b346105dd5760403660031901126105dd57613c79616121565b60243590613c85616816565b613c8d616716565b81156109da5760405191613ca0836161e2565b5f83525f6020840152613cb283617267565b9160018060a01b03811693845f52601860205260405f2060028101549081158015613f61575b15613f35575050825b5f945f5b335f52601360205260405f2054811015613f2a57335f526013602052613d0e8160405f206166e9565b5080546001600160a01b0316891480613f13575b613d2f5750600101613ce5565b929394959650505f90335f52601560205260405f205f918154925b838110613eb45750505050613d6390600183015461646c565b828110613ea95750335f52601560205260405f2092613d9460ff60036001600160401b035f54169401541695616440565b60405191613da183616218565b888352602083019081526040830195858752606084019485526080840197613dc88161619c565b885260a084019283528054600160401b8110156108a157613dee9160018201815561674e565b94909461088e57925184546001600160a01b0319166001600160a01b03919091161784555180515f978a97600495613e389490936107e29160018a01916107bc906107b68161619c565b519101556001600160401b03600194613e588554838160c01c9116616767565b9060405193845260208401521660408201527f06325d83435da87657b063c6142a5b91a66a7e811827d082d624287a9953c4ba60603392a45b156108785760015f80516020619f5c83398151915255005b6108c0869186618ab7565b8a613ebf828561674e565b50546001600160a01b03161480613ef9575b613ede575b600101613d4a565b93613ef16001916002610912888761674e565b949050613ed6565b5081613f0d61093e6001610937858861674e565b14613ed1565b5082613f2461093e60028401616795565b14613d22565b505050505050613e91565b8161097e6001613f4793015487616479565b5f1981019190821161099e57613f5c9161648c565b613ce1565b50600181015415613cd8565b346105dd575f3660031901126105dd57613f85616716565b61268e33617798565b346105dd5760203660031901126105dd576001600160a01b03613faf616121565b165f52600d602052602060405f2054604051908152f35b60203660031901126105dd576105ca613fdd616121565b613fe5616816565b613fed616716565b613ff5617777565b349061683d565b346105dd575f3660031901126105dd576020604051613e808152f35b346105dd575f3660031901126105dd57614030616716565b5f805b335f52601360205260405f205482101561423957335f52601360205261405c8260405f206166e9565b5060ff60038201541661406e8161619c565b614104576140f390600192670de0b6b3a76400006140c385808060a01b03855416940154845f52601860205260405f2094335f52601960205260405f2090888060a01b03165f5260205260405f209454616479565b0482548082115f146140fc576140d9908261646c565b925b5f6140eb8783019586549061666a565b94555561666a565b915b0190614033565b505f926140db565b335f9081526014602090815260408083208684529091528120915490916001600160a01b03909116908190835b815481101561422357956001876001600160401b03614151839a86616e93565b90549060031b1c16855f52601b60205260405f206001600160401b0382165f52602052670de0b6b3a76400006141df60405f20335f52601c60205260405f208a5f5260205260405f206001600160401b0385165f5260205260405f2093335f52601e60205260405f208b5f526020526001600160401b0360405f2091165f5260205260405f20549054616479565b049080548083115f146142175761420b6141fa5f928561646c565b9a5b610a558785019c8d549061666a565b99555501909650614131565b505f61420b819a6141fc565b505050506142339060019261666a565b916140f5565b8061425b575b60209060015f80516020619f5c83398151915255604051908152f35b5f80808084335af161426b617748565b50156142a6576020906040518181527f106f923f993c2149d49b4255ff723acafa1f2d94393f561d3eda32ae348f7241833392a2905061423f565b6312171d8360e31b5f5260045ffd5b346105dd5760203660031901126105dd576004356142d1616816565b335f52600a60205260405f2060ff600182015460201c16600381101561148257611b025781156109da5761430a604051611b34816161e2565b5f526002602052600160405f200154335f52600b60205261433160405f205480935461646c565b8161433c858361646c565b106143d7578361434c818561666a565b6001600160401b03600181805f541660405194614368866161e2565b855260208501908152335f52600b60205260405f20945185555116920191166001600160401b03198254161790557ff7e874d9fd42838b0f06a44c7bbe45417b991e6b000e8ca4c5c1f086084a9cd36143d26116c25f546001600160401b038160c01c9116616767565b0390a2005b836143e19161646c565b906322df051360e11b5f5260045260245260445ffd5b346105dd575f3660031901126105dd5761440f616d1a565b5f80516020619f3c8339815191525460ff8116156144665760ff19165f80516020619f3c833981519152557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b638dfc202b60e01b5f5260045ffd5b346105dd5760803660031901126105dd5761448e616121565b614496616163565b9061449f616179565b506064356127106144b961ffff60015460801c1683616479565b04926144ea6144c8858461646c565b9360018060a01b03811695865f52601a60205261293760405f2091825461666a565b835f52601860205260405f20906001820191825480614602575b5050845f52601b6020526001600160401b0360405f2091165f5260205260405f20906001600160401b035f54166001600160401b036003840191166001600160401b0319825416179055600182015480159283156145b2575b505092602092915f80516020619ebc83398151915294541590816145aa575b5061458c575b50604051908152a2005b845f52601a83526145a260405f2091825461666a565b905584614582565b90508661457c565b9392909491670de0b6b3a7640000830294838604670de0b6b3a7640000148415171561099e576145f561299a5f80516020619ebc8339815191529860209861648c565b905591948193945061455d565b670de0b6b3a76400008602868104670de0b6b3a7640000148715171561099e5761462f9161299a9161648c565b90558580614504565b346105dd5760403660031901126105dd57614651616137565b336001600160a01b0382160361466d57610018906004356176ac565b63334bd91960e11b5f5260045ffd5b346105dd5760803660031901126105dd5760206114de61469a616121565b6146a2616163565b906146ab616df8565b60643591604435916172ae565b346105dd5760a03660031901126105dd576146d1616121565b60243590604435906084359261ffff84168094036105dd577f9a4c59c56153245e23dcb8000e301b9a5e35b8e6693c5cdbf3b6a2aa0f8a37ea92604092614716616d89565b6001600160a01b03169461472b861515616407565b61ffff600561473e8651611342816161e2565b86519061474a82616218565b60018252602082018781528883018781526060840191606435835260808501935f855260a086019889525f5260026020526113aa8b5f2095511515869060ff801983541691151516179055565b346105dd575f3660031901126105dd57602061ffff60015460801c16604051908152f35b346105dd5760203660031901126105dd576001600160a01b036147dc616121565b165f52601360205260405f208054906147f482616677565b91614802604051938461624e565b8083526020830180925f5260205f205f915b838310614897578486604051918291602083019060208452518091526040830191905f5b818110614846575050500390f35b91935091602060a0600192606087518580851b0381511683528481015185840152614879604082015160408501906161a6565b01516148848161619c565b6080820152019401910191849392614838565b600460206001926040516148aa816161c7565b848060a01b03865416815284860154838201526148c960028701616795565b604082015260ff6003870154166148df8161619c565b6060820152815201920192019190614814565b346105dd5760203660031901126105dd576001600160a01b03614913616121565b165f52601a602052602060405f2054604051908152f35b346105dd5760403660031901126105dd57610018600435614949616137565b90614956611ce8826163e9565b6171d6565b346105dd5760203660031901126105dd57614974616121565b61497c6163c5565b506149856163c5565b5060018060a01b03165f52600a60205260405f206001604051916149a8836161c7565b805483520154906020810163ffffffff8316815260ff8360201c16604083019160038210156114825763ffffffff9183526001600160401b03606085019560281c1685526040519351845251166020830152516003811015611482576080926001600160401b0391604084015251166060820152f35b346105dd575f3660031901126105dd57602080546040516001600160a01b039091168152f35b5f3660031901126105dd57614a57616816565b614a5f616716565b614a74335f52600960205260405f2054151590565b61195c57614a87604051611b34816161e2565b5f52600260205260405f2060ff815416156119495760010154803410614b5e57614ab033618d60565b50604051614abd816161c7565b348152602081015f8152604082015f815263ffffffff80600160608601955f8752335f52600a60205260405f2090518155019351161663ffffffff1983541617825551600381101561148257614b1f926118b46001600160401b039284616f23565b6040513481527fbc11617e575d658c74e921c8df22f8e48566072fa78145a6cfe18420bf8d0c4e60203392a260015f80516020619f5c83398151915255005b6322df051360e11b5f526004523460245260445ffd5b346105dd5760203660031901126105dd57614b8d61614d565b335f52600c602052614bad6001600160401b0360405f20921680926194c6565b50337f4b9bbf2ebc79e9fb39a64920934b3f458a486552d3df95395aa750ece9e970935f80a3005b346105dd5760203660031901126105dd576020614bf56004356008618d4b565b905460405160039290921b1c6001600160a01b03168152f35b346105dd5760203660031901126105dd5760206114de6004356163e9565b346105dd5760403660031901126105dd57600435614c48616163565b90614c51616816565b335f52601360205260405f205481101561314257335f526013602052614c7a8160405f206166e9565b5090600160ff600384015416614c8f8161619c565b0361313357335f52601460205260405f20815f5260205260405f205f9080546001600160401b038616925b818110614fb457506001850154906001810180821161099e57614cdd908361648c565b9181614e2b575b5050335f52601e60205260405f2060018060a01b0386541660018060a01b03165f5260205260405f20835f526020528060405f205560018060a01b038554165f52601b60205260405f20835f52602052614d65600260405f209260018401614d4d82825461666a565b8091558181145f14614e055750925b0191825461666a565b90558054600160401b8110156108a157612f988184936001614d8994018155616e93565b90556040519081527fa7b81e017abeb50ecf2c121cb0db7087dfc4b3cc85cd8d857f9a5f1e81f6484560203392a36020546001600160a01b031680614dca57005b81546001600160a01b031690803b156105dd5760025f80946130ca604051978896879586946367b2734d60e01b865201903360048601616ed1565b614e1f614e2592614e198588015482616479565b9261646c565b9061648c565b92614d5c565b91614e3d614e4292829896979461648c565b61646c565b935f5b8354811015614fa757806001600160401b03614e6360019387616e93565b90549060031b1c16335f52601e60205260405f2090838060a01b0388541691848060a01b0383165f5260205260405f206001600160401b0382165f5260205260405f205491828a115f14614f9c57614ebb838061646c565b90335f52601e60205260405f2090868060a01b03165f5260205260405f206001600160401b0383165f5260205260405f2055838060a01b038854165f52601b6020526001600160401b0360405f2091165f5260205260405f208381019081549083821015614f2e575b5050505001614e45565b614f3a8460029361646c565b809355019182549182151580614f93575b15614f8d57614e1f82614f6185614f6795616479565b9261666a565b81811115614f7e5750505f905b5589808080614f24565b614f879161646c565b90614f74565b50614f67565b50801515614f4b565b614ebb8a809461646c565b5092949093508680614ce4565b836001600160401b03614fc78386616e93565b90549060031b1c1614614fdc57600101614cba565b8362d00d2f60e11b5f5260045260245ffd5b346105dd575f3660031901126105dd575f546001600160401b038160801c166150236001600160401b038360401c1682616767565b901515806150c6575b61509d57506001600160401b03615044818316616eb4565b1680916001600160401b0360801b4260801b169077ffffffffffffffff0000000000000000ffffffffffffffff191617175f557f7cee7087baafdfa8f9d1bd39c560782e2eedf861e2648b232a805033537c56955f80a2005b6001600160401b039063274928d560e01b5f52166004526001600160401b03421660245260445ffd5b506001600160401b038116421061502c565b346105dd575f3660031901126105dd576020604051612af88152f35b346105dd5760203660031901126105dd5761510d616121565b5f906001600160a01b0316815b815f52601360205260405f2054831015610a6357815f5260136020526151438360405f206166e9565b5060ff6003820154166151558161619c565b6151e457600191610a556151d192670de0b6b3a76400006151af868060a01b0383541692835f52601860205260405f2093895f52601960205260405f2090898060a01b03165f526020528760405f20945491015490616479565b048154908181115f146151da5786916151c79161646c565b915b01549061666a565b925b019161511a565b5050845f916151c9565b5f8381526014602090815260408083208784529091528120805492549395936001600160a01b03169081905b8484106152245750505050506001906151d3565b60016152d38199610a556001600160401b0361524589879d9a9b9c9d616e93565b90549060031b1c16865f52601b60205260405f206001600160401b0382165f52602052670de0b6b3a76400006151af60405f208b5f52601c60205260405f208b5f5260205260405f206001600160401b0385165f5260205260405f20938c5f52601e60205260405f208c5f526020526001600160401b0360405f2091165f5260205260405f20549054616479565b9501939695949750615210565b346105dd5760403660031901126105dd576152f9616121565b615301616137565b6001600160a01b039182169181165f805b845f52601360205260405f2054821015610a6357845f52601360205261533b8260405f206166e9565b5080546001600160a01b031684900361542a5760ff60038201541661535f8161619c565b61537f57600191610a558361537693015487618ab7565b915b0190615312565b5090845f52601460205260405f20815f5260205260405f205f8154915b8282106153ae57505050600190615378565b919394600161541b8998939597829a5f52601e60205260405f20845f5260205260405f206001600160401b03806153e58a8a616e93565b90549060031b1c16165f52602052610a5560405f20546001600160401b0361540d8a8a616e93565b90549060031b1c1687618d07565b9401919697509492939161539c565b5090600190615378565b346105dd5760403660031901126105dd5761544d616121565b6001600160a01b0361545d616137565b168061558c5750604051615470816161e2565b5f81525f6020820152905b6001600160a01b03165f9081526011602052604090209061549b90617267565b5f5260205260405f208054906154b082616677565b916154be604051938461624e565b8083526020830180925f5260205f205f915b838310615543578486604051918291602083019060208452518091526040830191905f5b818110615502575050500390f35b91935091602060606001926001600160401b03604088518051845261552d868201518786019061618f565b01511660408201520194019101918493926154f4565b60026020600192604051615556816161fd565b855481526001600160401b038587015461557560ff8216868501616e87565b60081c1660408201528152019201920191906154d0565b60405190615599826161e2565b6001825260208201529061547b565b346105dd5760403660031901126105dd576155c1616121565b6155c9616163565b9060018060a01b03165f5260516020526001600160401b0360405f2091165f5260205260e060405f20805490600181015490600281015460046003830154920154926001600160401b03604051958181168752818160401c16602088015260801c1660408601526060850152608084015260a083015260c0820152f35b346105dd5760203660031901126105dd5761565f616121565b615667616d1a565b601f80546001600160a01b0319166001600160a01b0392909216919091179055005b346105dd575f3660031901126105dd5760206001600160401b035f5460801c16604051908152f35b346105dd5760603660031901126105dd576156ca61614d565b6156d2616163565b906156db616179565b906156e4616d1a565b5f54906001600160401b0360c01b9060c01b169060018060c01b0316175f556001600160401b0367ffffffffffffffff60401b6001549260401b169216906fffffffffffffffffffffffffffffffff191617176001555f80f35b346105dd5760203660031901126105dd57615757616121565b61575f6163c5565b506157686163c5565b5060018060a01b03165f526018602052608060405f206001600160401b03604051615792816161c7565b825492838252600181015460208301908152606084600360028501549460408701958652015416930192835260405194855251602085015251604084015251166060820152f35b346105dd5760403660031901126105dd576105ca6157f5616121565b6157fd616816565b615805616716565b6024359061683d565b346105dd5760203660031901126105dd5760043563ffffffff60e01b81168091036105dd57602090637965db0b60e01b8114908115615853575b506040519015158152f35b6301ffc9a760e01b14905082615848565b346105dd575f3660031901126105dd5761587c616716565b5f335f52601560205260405f20905f5b82548110156105ca5761589f818461674e565b50915f546001600160401b03806158c0816003880154168460c01c90616767565b16911610616111576158d761093e60018501616795565b9161590860018060a01b038554166158f3600287015482618ab7565b90615902600488015491616440565b91618af2565b935f5b335f5260136020528560405f20548210156161025750335f5260136020526159368160405f206166e9565b50805483546001600160a01b03908116911614806160eb575b61595c575060010161590b565b93600385979297019660ff885416956159748761619c565b6001871480156160ca57335f52601460205260405f20835f5260205260405f2060405180602083549182815201925f5260205f20905f915b81600384011061607a57936159e89284926159ee965491818110616060575b818110616043575b818110616026575b106160185750038261624e565b9861619c565b8061600e575b615f31575b60018060a01b038554169760ff60028701549a54169761271090615a1f60018901616795565b995f615a2a8261619c565b81615f0a5750615a398c61901b565b8b5f52601860205260405f209c335f52601960205260405f208d60018060a01b03165f5260205260405f209b5f9c5f5b335f52601360205260405f2054811015615ae4578f335f526013602052615a938260405f206166e9565b509060018060a01b038254161480615acc575b615ab4575b50600101615a69565b6001919f82615ac59201549061666a565b9e90615aab565b5060ff600382015416615ade8161619c565b15615aa6565b509d8a9f9e615b68989a9d9f8c9d9f670de0b6b3a764000091615b50919e969798999a9c9e80615ecb575b5f9860018301615b2082825461646c565b90556002830180548a81811115615ebc5750505f905b5580821115615eb357615b489161646c565b905b54616479565b0490555b615b62878585858533619970565b33619aaf565b615b7c60016002880154930192835461646c565b8255335f52601060205260405f20905f52602052600160405f2001615bab81548086115f14615eac578061646c565b90555415615d35575b50615bbe9161666a565b9260018060a01b0382541690600260018060a01b03600185015460081c169301549060405191825260208201527fe4183514c7483039538cd1f9ca20e489b3c411f3af1211cf6b5ad0a00ca4e22860403392a482545f19810190811161099e57615c28908461674e565b50615c33828561674e565b91909161088e57808203615c7f575b505082548015610ed4575f1901615c59818561674e565b61088e576004815f8093558260018201558260028201558260038201550155835561588c565b805482546001600160a01b0319166001600160a01b039190911617825560049081906001808201908501828603615cfd575b505060028101546002850155615cf16003850160ff600384016001600160401b0380825416166001600160401b03198454161783555460401c16906167f3565b01549101558380615c42565b81615d0f60ff615d2e945416836167db565b548154610100600160a81b031916610100600160a81b03909116179055565b8780615cb1565b905060018060a01b038354165f52600a602052600160405f200163ffffffff815416801561099e57815463ffffffff19165f1991820163ffffffff1617909155335f908152601360205260409020805491820191821161099e57615daf91615d9c916166e9565b5091335f52601360205260405f206166e9565b61088e57818103615e3e575b5050335f52601360205260405f209081548015610ed4575f190190615de082846166e9565b92909261088e57615bbe935f600385828b975582600182015582600282015501555560018060a01b03845416615e168133617c67565b15615e23575b5091615bb4565b5f52600d602052615e373360405f206194c6565b5087615e1c565b815481546001600160a01b0319166001600160a01b039190911617815560018083015490820155615e8d9160039060ff9082906002808201908601828703615e94575b505001541691016167db565b8580615dbb565b81615d0f86615ea5945416836167db565b8b80615e81565b859061646c565b50505f90615b4a565b615ec59161646c565b90615b36565b83615ed7828454616479565b0485548082115f14615f0257615eec9161646c565b615efb6001870191825461666a565b9055615b0f565b50505f615eec565b909192939597809d9b8d615f2c615b68989a9d9f849d9f855f918a9333619750565b615b54565b97939692909491615f48600289015488519061648c565b955f5b8851811015615fff57335f908152601e602090815260408083208d546001600160a01b0316808552925290912060019291906001600160401b0380615f90858f6167c7565b5116165f5260205260405f20548a8181115f14615ff05750505f905b335f52601e60205260405f2090848060a01b03165f526020528a6001600160401b0380615fdd8560405f20946167c7565b5116165f5260205260405f205501615f4b565b615ff99161646c565b90615fac565b509193979498909295506159f9565b50865115156159f4565b60c01c81526020015f6132bc565b9260206001916001600160401b038560801c1681520193016159db565b9260206001916001600160401b038560401c1681520193016159d3565b9260206001916001600160401b03851681520193016159cb565b92936001608060049286546001600160401b03811682526001600160401b038160401c1660208301526001600160401b0381841c16604083015260c01c60608201520194019201919392936159ac565b6159ee6020604051906160dd818361624e565b5f8252505f3681379861619c565b50856160fc61093e60028401616795565b1461594f565b91939050615bbe92945061666a565b915061611c90616787565b61588c565b600435906001600160a01b03821682036105dd57565b602435906001600160a01b03821682036105dd57565b600435906001600160401b03821682036105dd57565b602435906001600160401b03821682036105dd57565b604435906001600160401b03821682036105dd57565b9060058210156114825752565b6002111561148257565b60209080516161b48161619c565b83528101516001600160a01b0316910152565b608081019081106001600160401b038211176108a157604052565b604081019081106001600160401b038211176108a157604052565b606081019081106001600160401b038211176108a157604052565b60c081019081106001600160401b038211176108a157604052565b60e081019081106001600160401b038211176108a157604052565b90601f801991011681019081106001600160401b038211176108a157604052565b6001600160401b0381116108a157601f01601f191660200190565b346105dd5760203660031901126105dd576162a3616121565b60018060a01b03165f5260186020526020600260405f200154604051908152f35b90602080835192838152019201905f5b8181106162e15750505090565b82516001600160401b03168452602093840193909201916001016162d4565b60609060031901126105dd576004356001600160a01b03811681036105dd57906024356001600160a01b03811681036105dd579060443590565b9060a06003198301126105dd576004356001600160a01b03811681036105dd57916024356001600160a01b03811681036105dd57916044359160643560028110156105dd57916084356001600160401b0381116105dd57826023820112156105dd578060040135926001600160401b0384116105dd5760248460051b830101116105dd576024019190565b604051906163d2826161c7565b5f6060838281528260208201528260408201520152565b5f525f80516020619f1c833981519152602052600160405f20015490565b1561640e57565b60405162461bcd60e51b815260206004820152600a602482015269557365206e617469766560b01b6044820152606490fd5b6001600160a01b03165f908152600f6020526040902054806164695750670de0b6b3a764000090565b90565b9190820391821161099e57565b8181029291811591840414171561099e57565b8115616496570490565b634e487b7160e01b5f52601260045260245ffd5b929190925f9360018060a01b0382165f5260516020526001600160401b0360405f2091165f5260205260405f2090604051926164e584616233565b82546001600160401b0380821691828752818160401c16602088015260801c166040860152600184015460608601526002840154946080810195865260c0600460038701549660a08401978852015491015215616589579061654691617c67565b918215616581575190519081811161655d57505050565b670de0b6b3a764000093945061657d92916165779161646c565b90616479565b0490565b505f93505050565b505f9450505050565b6040519061659f826161e2565b5f6020838281520152565b906040516165b7816161e2565b602060018294805484520154910152565b156165cf57565b60405162461bcd60e51b815260206004820152600f60248201526e24b73b30b634b21030b230b83a32b960891b6044820152606490fd5b908160209103126105dd575180151581036105dd5790565b1561662557565b60405162461bcd60e51b815260206004820152601d60248201527f4164617074657220646f65736e277420737570706f727420746f6b656e0000006044820152606490fd5b9190820180921161099e57565b6001600160401b0381116108a15760051b60200190565b929161669982616677565b936166a7604051958661624e565b602085848152019260051b81019182116105dd57915b8183106166c957505050565b82356001600160401b03811681036105dd578152602092830192016166bd565b8054821015616702575f5260205f209060021b01905f90565b634e487b7160e01b5f52603260045260245ffd5b60025f80516020619f5c833981519152541461673f5760025f80516020619f5c83398151915255565b633ee5aeb560e01b5f5260045ffd5b8054821015616702575f52600560205f20910201905f90565b906001600160401b03809116911601906001600160401b03821161099e57565b5f19811461099e5760010190565b906040516167a2816161e2565b602081935460ff81166167b48161619c565b835260081c6001600160a01b0316910152565b80518210156167025760209160051b010190565b906167e58161619c565b60ff80198354169116179055565b906167fd8161619c565b60ff60401b82549160401b169060ff60401b1916179055565b60ff5f80516020619f3c833981519152541661682e57565b63d93c066560e01b5f5260045ffd5b6040519161684a836161e2565b5f83525f6020840152602091604051616863848261624e565b5f81525f36813782156109da578051616d0b576001600160a01b0382165f90815260098552604090205415616cea5760018060a01b0382165f52600a8452600160405f20019460ff8654861c16600381101561148257616ccc576168c681617267565b335f526010865260405f20815f52865260405f20928354936168ed6001820154809661646c565b878110616cb557506168ff8787619b60565b9485156109da57876169109161666a565b60018201555f985f805b335f5260138b5260405f2054811015616ca557335f5260138b526169418160405f206166e9565b5080546001600160a01b038b811691161480616c8e575b616965575060010161691a565b91509192939495969798999a5060ff60038201541660025f10156114825761698c8161619c565b616c7f5760010161699e88825461666a565b905560015b616b865750335f526013895260405f2054335f5260138a5260405f206040516169cb816161c7565b6001600160a01b038a1681528b8101898152604082018981529260608301905f82528054600160401b8110156108a157616a0a916001820181556166e9565b93909361088e57616a9c948f600394616a8b9360018060a01b039060018060a01b03905116166bffffffffffffffffffffffff60a01b88541617875551600187015560028601915190616a678251616a618161619c565b846167db565b01518154610100600160a81b03191660089190911b610100600160a81b0316179055565b5191616a968361619c565b016167db565b335f908152601d8b5260408082206001600160a01b038b1683528c52808220928252918b5220805460ff19166001179055805463ffffffff9081169490851461099e576001616b25938a9363ffffffff83616b3199011663ffffffff19825416179055818060a01b038a165f52600d8c52616b1a3360405f20618e16565b505b01549033619bbb565b905f8786868933618b65565b60200151604051938452938301526001600160a01b0392909216915f60408301526001600160a01b03169033907f4fe2fde631e986ee26283901b9cc8d6d4a311b750f9fa0d659520deba2995f1f90606090a4565b9050929192335f5260138952600160ff6003616ba58460405f206166e9565b50015416616bb28161619c565b14616bca575b5086616b3193926001616b2593616b1c565b979491969295939097335f526014865260405f20905f52855260405f209586548015155f14616c7757616bfd908461648c565b975b5f5b8854811015616c6357335f908152601e895260408082206001600160a01b038a1683528a529020600191906001600160401b0380616c3f848e616e93565b90549060031b1c16165f52895260405f20616c5b8c825461666a565b905501616c01565b509598939750939550909390929186616bb8565b505f97616bff565b630abce6af60e41b5f5260045ffd5b5086616c9f61093e60028401616795565b14616958565b50909192939495969798996169a3565b87906312e1fa3760e11b5f5260045260245260445ffd5b6371ab6ad560e11b5f9081526001600160a01b038416600452602490fd5b5063bd62013360e01b5f9081526001600160a01b0391909116600452602490fd5b6310db86df60e21b5f5260045ffd5b335f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c602052604090205460ff1615616d5257565b63e2517d3f60e01b5f52336004527fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c2177560245260445ffd5b335f9081527f5bc841a6d925a620866922bada36d16da3dcc9d52290519ea1126e5ca2372139602052604090205460ff1615616dc157565b63e2517d3f60e01b5f52336004527fb1fadd3142ab2ad7f1337ea4d97112bcc8337fc11ce5b20cb04ad038adf9981960245260445ffd5b335f9081525f80516020619edc833981519152602052604090205460ff1615616e1d57565b63e2517d3f60e01b5f52336004525f80516020619efc83398151915260245260445ffd5b5f8181525f80516020619f1c8339815191526020908152604080832033845290915290205460ff1615616e715750565b63e2517d3f60e01b5f523360045260245260445ffd5b60058210156114825752565b9190918054831015616702575f52601860205f208360021c019260031b1690565b6001600160401b03166001600160401b03811461099e5760010190565b6001600160a01b03918216815291166020820152905460a0820193926080916001600160401b03919060ff8116616f078161619c565b604086015260081c6001600160a01b0316606085015216910152565b9060038110156114825764ff0000000082549160201b169064ff000000001916179055565b6001600160a01b0381165f9081525f80516020619edc833981519152602052604090205460ff16616fc8576001600160a01b03165f8181525f80516020619edc83398151915260205260408120805460ff191660011790553391905f80516020619efc833981519152905f80516020619e7c8339815191529080a4600190565b505f90565b6001600160a01b0381165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff16616fc8576001600160a01b03165f8181527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260408120805460ff191660011790553391905f80516020619e7c8339815191528180a4600190565b6001600160a01b0381165f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c602052604090205460ff16616fc8576001600160a01b03165f8181527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c60205260408120805460ff191660011790553391907fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775905f80516020619e7c8339815191529080a4600190565b6001600160a01b0381165f9081527f5bc841a6d925a620866922bada36d16da3dcc9d52290519ea1126e5ca2372139602052604090205460ff16616fc8576001600160a01b03165f8181527f5bc841a6d925a620866922bada36d16da3dcc9d52290519ea1126e5ca237213960205260408120805460ff191660011790553391907fb1fadd3142ab2ad7f1337ea4d97112bcc8337fc11ce5b20cb04ad038adf99819905f80516020619e7c8339815191529080a4600190565b5f8181525f80516020619f1c833981519152602090815260408083206001600160a01b038616845290915290205460ff16617261575f8181525f80516020619f1c833981519152602090815260408083206001600160a01b0395909516808452949091528120805460ff19166001179055339291905f80516020619e7c8339815191529080a4600190565b50505f90565b8051906172738261619c565b602060018060a01b03910151166040519060208201926172928161619c565b83526040820152604081526172a860608261624e565b51902090565b9093929160018060a01b03821691825f52600a60205260405f20906172de845f52600960205260405f2054151590565b15617608576172ec81618e63565b6175f557835f52601860205260405f2096839761730f600285549201548261666a565b9485156175e85785106175de575b8461732b617330928b616479565b61648c565b9161735761735161734083618ee6565b9461734b8185618f45565b9b61646c565b82618f7e565b986173628a8261666a565b9961736c83618ee6565b9561737c604051611b34816161e2565b5f526002602052600160405f2001548154106175c2575b50875f5260526020528a60405f20998a546001600160401b03169a6173b78c616eb4565b6001600160401b03166001600160401b0319825416179055878a5f546001600160401b031693604051946173ea86616233565b85528d60208601996001600160401b0316998a815260408701915f83526060880193845260808801948d865260a0890196875260c089019788525f52605160205260405f20906001600160401b03165f5260205260405f2096516001600160401b03166001600160401b03166001600160401b0319885416178755516001600160401b031661749c90879067ffffffffffffffff60401b82549160401b169067ffffffffffffffff60401b1916179055565b51855467ffffffffffffffff60801b191660809190911b67ffffffffffffffff60801b16178555516001850155516002840155516003830155519060040155835f52605360205260405f20885f5260205260405f2080546001600160401b031661750590616eb4565b6001600160401b03166001600160401b03198254161790556127108b02918b8304612710148c15171561099e5761758989946175837f1508fbe22c9805770740c8f3827567950022729e0096e311dc087990c157fffc9a7f91754b254153861c1e9bc9186484a0bb770823acfa00423044ba1759a01210e79661648c565b90618fc1565b604080519182526020820192909252908101869052606090a360408051888152602081019290925281019190915280606081015b0390a3565b600101805464ff0000000019166401000000001790555f617393565b939750879361731d565b505f985050505050505050565b8363b516260d60e01b5f5260045260245ffd5b8363bd62013360e01b5f5260045260245ffd5b6001600160a01b0381165f9081525f80516020619edc833981519152602052604090205460ff1615616fc8576001600160a01b03165f8181525f80516020619edc83398151915260205260408120805460ff191690553391905f80516020619efc833981519152907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9080a4600190565b5f8181525f80516020619f1c833981519152602090815260408083206001600160a01b038616845290915290205460ff1615617261575f8181525f80516020619f1c833981519152602090815260408083206001600160a01b0395909516808452949091528120805460ff19169055339291907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9080a4600190565b3d15617772573d906177598261626f565b91617767604051938461624e565b82523d5f602084013e565b606090565b617796604051617786816161e2565b5f81525f6020820152349061906a565b565b6001600160a01b031690811561781d57335f52601a60205260405f205491821561780e575f8080858194338352601a6020528260408120555af16177da617748565b50156142a6576040518281527f106f923f993c2149d49b4255ff723acafa1f2d94393f561d3eda32ae348f724160203392a2565b6373380d9960e01b5f5260045ffd5b63d92e233d60e01b5f5260045ffd5b6001600160a01b0381165f908152600a6020908152604080832060099092529091205494969492939290919015617c47576001600160a01b0381165f908152601860209081526040808320601b83528184206001600160401b038916855290925290912083546002928301549290910154909491906178af9061097e838861666a565b948515617c395789866178f0928161732b9a9b9c9d11617c2f575b816178df614e3d9361732b6178e89487616479565b9a8b9685616479565b93849261646c565b61791861791061790961790287618ee6565b9987618f45565b9386618f7e565b918986619577565b956179278761097e848661666a565b9a8b9961793387618ee6565b97617943604051611b34816161e2565b5f526002602052600160405f200154815410617c13575b506001600160a01b0387165f90815260526020526040902080546001600160401b03169b8c93918a918d9161798e87616eb4565b6001600160401b03166001600160401b03198254161790555f546001600160401b031694604051956179bf87616233565b8652602086019a6001600160401b03169a8b815260408701916001600160401b031697888352606088019384526080880194855260a0880195865260c088019687528d600160a01b60019003165f52605160205260405f20906001600160401b03165f5260205260405f2096516001600160401b03166001600160401b03166001600160401b0319885416178755516001600160401b0316617a8490879067ffffffffffffffff60401b82549160401b169067ffffffffffffffff60401b1916179055565b51855467ffffffffffffffff60801b191660809190911b67ffffffffffffffff60801b16178555516001850155516002840155516003830155519060040155845f52605360205260405f20600160a01b6001900387165f5260205260405f2080546001600160401b0316617af790616eb4565b6001600160401b03166001600160401b03198254161790555f52605460205260405f20600160a01b6001900386165f5260205260405f2080546001600160401b0316617b4290616eb4565b6001600160401b03166001600160401b03198254161790556127108b028b8104612710148c15171561099e577f1508fbe22c9805770740c8f3827567950022729e0096e311dc087990c157fffc977f91754b254153861c1e9bc9186484a0bb770823acfa00423044ba1759a01210e79361097e617bc38a95617bc99561648c565b89618fc1565b6040805194855260208501919091528301526001600160a01b03841691606090a36040805188815260208101959095528401919091526001600160a01b03169180606081016175bd565b600101805464ff0000000019166401000000001790555f61795a565b90915081906178ca565b505050505050509150505f90565b63bd62013360e01b5f9081526001600160a01b0391909116600452602490fd5b90915f925f5b6001600160a01b0384165f81815260136020526040902054821015617ce357805f526013602052617ca18260405f206166e9565b50546001600160a01b03848116911614617cbf575b50600101617c6d565b60019195617cdc915f526013602052826109128860405f206166e9565b9490617cb6565b5050509050565b6001600160a01b0381169081156119495761779692617d08916195d0565b9060405190617d16826161e2565b60018252602082015261906a565b9190811015616702576060020190565b3561ffff811681036105dd5790565b6001600160a01b0381165f908152600a60209081526040808320600990925290912054959897969495909391929190156182a9578815618299576001600160a01b0383165f908152601860209081526040808320601b83528184206001600160401b03871685529092528220865460029283015492909101549892979192885b8d80821061820957505088156181f9578883116181f1575b617de487618ee6565b99617df38161097e878661666a565b156181e0578992918e915f935f975f935f945b86861061815f575050505050505092614f61617e5f617e58617e5186614e3d617e4988617e4061097e9a61732b617e679e61732b9e616479565b9a8b9985616479565b98899261646c565b938a618f45565b9489618f7e565b918789619577565b98617e7184618ee6565b94617e81604051611b34816161e2565b5f526002602052600160405f200154815410618143575b506001600160a01b0384165f90815260526020526040902080546001600160401b03169890617ec68a616eb4565b6001600160401b03166001600160401b03198254161790555f546001600160401b03169060405191617ef783616233565b82528960208301946001600160401b0316948581528d60408501976001600160401b0316978881526060860191825260808601928d845260a08701948c865260c08801968752600160a01b600190038c165f52605160205260405f20906001600160401b03165f5260205260405f2096516001600160401b03166001600160401b03166001600160401b0319885416178755516001600160401b0316617fc090879067ffffffffffffffff60401b82549160401b169067ffffffffffffffff60401b1916179055565b51855467ffffffffffffffff60801b191660809190911b67ffffffffffffffff60801b16178555516001850155516002840155516003830155519060040155815f52605360205260405f20600160a01b6001900385165f5260205260405f2080546001600160401b031661803390616eb4565b6001600160401b03166001600160401b0319825416179055825f52605460205260405f20600160a01b6001900385165f5260205260405f2080546001600160401b031661807f90616eb4565b6001600160401b03166001600160401b03198254161790556127108a02958a8704612710148b15171561099e576180da6180e0917f1508fbe22c9805770740c8f3827567950022729e0096e311dc087990c157fffc9861648c565b85618fc1565b604051908a825260208201527feb0d9b34ef071b87da8591ddd82cc67f90c6806201b5c9ddc91f0624677dc815604060018060a01b03861692a46040805188815260208101959095528401919091526001600160a01b03169180606081016175bd565b600101805464ff0000000019166401000000001790555f617e98565b90919293949596999750618174868884617d24565b60400161818090617d34565b61ffff169961818f8b86616479565b612710900461819d9161666a565b976181a88b85616479565b61271090046181b69161666a565b996181c19086616479565b61271090046181cf9161666a565b94600101939291908e979695617e06565b505f9c505050505050505050505050565b889250617ddb565b505f9b5050505050505050505050565b8161821791849c939c617d24565b80359160028310156105dd578c87866001956182328161619c565b618273579361ffff61825d60406182566127109661097e6182649761826b9b61666a565b9301617d34565b1690616479565b049061666a565b995b01617dc3565b9361ffff61825d60406182566127109661097e618264976182939b61666a565b9961826d565b939450915061646995965061782c565b63bd62013360e01b5f9081526001600160a01b038416600452602490fd5b156182ce57565b60405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b6044820152606490fd5b335f52600b60205260405f209081549182156183be575f546001600160401b036001818316930154169060c01c906001600160401b036183458383616767565b168310611dfe5750505081335f52600a60205260405f2061836782825461646c565b9055335f52600b6020525f60016040822082815501556183905f80808085335af1611dc0617748565b6040519081527fda2b51341079f3dd8e6763a50f329bbc3dc6ca6a51b920fe99fbf89a54ec0e2760203392a2565b505f9150565b60405163a9059cbb60e01b60208201526001600160a01b039290921660248301526044808301939093529181526177969161840060648361624e565b6196b4565b8054821015616702575f52600360205f20910201905f90565b92939291906001600160a01b031680618a9b575060405161843e816161e2565b5f81525f6020820152935b81156109da576184588161619c565b8015948515618a86578451616d0b575b6001600160a01b0384165f8181526009602052604090205490949015618a7357845f52600a602052600160405f20019060ff825460201c16600381101561148257618a60576184b683617267565b96335f52601060205260405f20885f5260205260405f2097600189549901936184e18554809b61646c565b888110618a4957506184f38885619b60565b998a156109da57886185049161666a565b85555f9a5f805b335f52601360205260405f2054811015618a3757335f5260136020526185348160405f206166e9565b5080546001600160a01b03168d1480618a20575b618555575060010161850b565b91509192939495969798809a9b9c9d5060ff6003830154166185768261619c565b61857f8161619c565b03616c7f576001016185928d825461666a565b905560015b6189215750335f9081526013602052604090819020805491519192916185bc816161c7565b8c8152602081018e8152604082018b81529260608301906185dc8e61619c565b8d82528054600160401b8110156108a1576185fc916001820181556166e9565b93909361088e575183546001600160a01b0319166001600160a01b03919091161783559051600183015591518051618649936003929091616a8b9160028601916107bc906107b68161619c565b6186528961619c565b1561873057335f52601d60205260405f208a5f5260205260405f20905f5260205260405f20600160ff198254161790555b63ffffffff8154169163ffffffff831461099e57866186da8a8d936186e1998e839763ffffffff8f9a6001011663ffffffff198254161790555f52600d6020526186d03360405f20618e16565b505b549033619bbb565b9533618b65565b602060018060a01b03910151169360405192835260208301526187038161619c565b60408201527f4fe2fde631e986ee26283901b9cc8d6d4a311b750f9fa0d659520deba2995f1f60603392a4565b9995929794919896939099335f52601460205260405f20905f5260205260405f2088516001600160401b0381116108a157600160401b81116108a15781548183558082106188c7575b5060208a01915f5260205f208160021c915f5b8381106188825750600319811690038061882a575b505089519150508015618822576187b8908761648c565b985b5f5b895181101561881157600190335f52601e60205260405f208a5f526020528a6001600160401b03806187f28460405f20946167c7565b5116165f5260205260405f206188098d825461666a565b9055016187bc565b509194979295999093969850618683565b505f986187ba565b925f935f5b8181106188445750505001555f8080806187a1565b90919460206188786001926001600160401b03895116908560031b6001600160401b03809160031b9316831b921b19161790565b960192910161882f565b5f805b6004811061889a57508382015560010161878c565b86519096916001916020916001600160401b0360068b901b81811b199092169216901b1792019601618885565b825f5260205f20600380840160021c8201920160021c019060188360031b1680618906575b505b8181106188fb5750618779565b5f81556001016188ee565b5f198201908154905f199060200360031b1c1690555f6188ec565b9150509390919293335f526013602052600160ff60036189448460405f206166e9565b500154166189518161619c565b1461896c575b508689866186da836186e19897968b966186d2565b98949197959296939098335f52601460205260405f20905f5260205260405f209687548015155f14618a18576189a2908761648c565b985b5f5b8954811015618a0157600190335f52601e60205260405f208a5f526020528a6001600160401b03806189dc8460405f2094616e93565b90549060031b1c16165f5260205260405f206189f98d825461666a565b9055016189a6565b509599969850939650919490939192919086618957565b505f986189a4565b5085618a3161093e60028401616795565b14618548565b50909192939495969798999a9b618597565b88906312e1fa3760e11b5f5260045260245260445ffd5b856371ab6ad560e11b5f5260045260245ffd5b8463bd62013360e01b5f5260045260245ffd5b845161846857631db6d08b60e11b5f5260045ffd5b60405190618aa8826161e2565b60018252602082015293618449565b6001600160a01b03165f9081526018602052604090206001810154908115618aeb5761646992600261732b92015490616479565b5050505f90565b9181158015618b12575b618b0d5761732b9061646993616479565b505090565b5081811015618afc565b60058110156114825760018114618b5e5760028114618b575760038114618b5057600414618b4a5761271090565b613e8090565b506132c890565b50612ee090565b50612af890565b93969296959195949094618b788261619c565b81618ce957618b868661901b565b60018060a01b03861696875f52601860205260405f209660018060a01b03871696875f52601960205260405f208a5f5260205260405f205f995f5b8a5f52601360205260405f2054811015618c3c578a5f526013602052618bea8160405f206166e9565b5080546001600160a01b03168e1480618c24575b618c0c575b50600101618bc1565b6001919c82618c1d9201549061666a565b9b90618c03565b5060ff600382015416618c368161619c565b15618bfe565b506001989b50670de0b6b3a76400009294969950615b488d618c686177969f618c949597999b9e61646c565b80618cab575b8b8401618c7c83825461666a565b905560028401618c8d8c825461666a565b905561666a565b0490555b618ca6888686868686619970565b619aaf565b85618cb7828654616479565b0487548082115f14618ce157618ccc9161646c565b618cda8d890191825461666a565b9055618c6e565b50505f618ccc565b919484618d02876001866177969c86839a9d989b619750565b618c98565b60018060a01b03165f52601b6020526001600160401b0360405f2091165f5260205260405f206001810154908115618b0d5761646992600261732b92015490616479565b8054821015616702575f5260205f2001905f90565b805f52600960205260405f2054155f14616fc857600854600160401b8110156108a157618daf618d998260018594016008556008618d4b565b819391549060031b91821b915f19901b19161790565b9055600854905f52600960205260405f2055600190565b805f52600460205260405f2054155f14616fc857600354600160401b8110156108a157618dff618d998260018594016003556003618d4b565b9055600354905f52600460205260405f2055600190565b5f82815260018201602052604090205461726157805490600160401b8210156108a15782618e4e618d99846001809601855584618d4b565b90558054925f520160205260405f2055600190565b6001600160a01b03165f818152600c60205260409020805491908215618aeb575f5b838110618e9457505050505f90565b6001600160401b03618ea68284618d4b565b90549060031b1c16835f52601b6020526001600160401b0360405f2091165f52602052600260405f200154618edd57600101618e85565b50505050600190565b6001600160a01b03165f9081526018602052604090206001810154908115618f37576002015490670de0b6b3a7640000820291808304670de0b6b3a7640000149015171561099e576164699161648c565b5050670de0b6b3a764000090565b6001600160a01b03165f908152600a602052604090208054828110618f755750618f7082825461646c565b905590565b5f919392509255565b6001600160a01b03165f908152601860205260409020600201805480158015618fb9575b618aeb57828110618f755750618f7082825461646c565b508215618fa2565b9080158015619010575b61900c57618fd882616440565b906127100390612710821161099e5761271091618ff491616479565b049060018060a01b03165f52600f60205260405f2055565b5050565b506127108111618fcb565b60018060a01b03165f52601860205260405f206001600160401b036003815f5416920191166001600160401b0319825416179055565b8054821015616702575f5260205f209060011b01905f90565b81156109da5761907981617267565b805f52600260205260405f2060ff815416156191705760028101548085106191595750600381015480151580619143575b61912457506004016190bd84825461666a565b9055335f52601060205260405f20905f5260205260405f206190e083825461666a565b9055602001516040519182526001600160a01b0316905f60208201527f754fff2205ca9f1a08ae1f38f487839ba7e18895f0238908ea8b8842d7424fbb60403392a3565b60048592015490634b98504560e01b5f5260045260245260445260645ffd5b508061915386600485015461666a565b116190aa565b8490631e2be21160e01b5f5260045260245260445ffd5b602083015163f6f24b8360e01b5f9081526001600160a01b03909116600452602490fd5b81156109da576191a381617267565b90815f52600260205260405f2060ff8154161561934c5760028101548085106191595750600381015480151580619336575b61912457506004016191e884825461666a565b9055335f52601060205260405f20825f5260205260405f2061920b84825461666a565b905560058410156114825783619268575b6020908101516040519384526001600160a01b03169361924092509083019061618f565b7f754fff2205ca9f1a08ae1f38f487839ba7e18895f0238908ea8b8842d7424fbb60403392a3565b61927184619cff565b61927a84619d8c565b91335f52601160205260405f20905f526020526192a460405f20926001600160401b034316616767565b916040516192b1816161fd565b84815260208101916192c38784616e87565b6001600160401b0360408301951685528054600160401b8110156108a1576192f091600182018155619051565b61088e576001915181550190516005811015611482576192409360ff68ffffffffffffffff008454925160081b1692169068ffffffffffffffffff19161717905561921c565b508061934686600485015461666a565b116191d5565b506020015163f6f24b8360e01b5f9081526001600160a01b03909116600452602490fd5b5f818152600460205260409020548015617261575f19810181811161099e576003545f1981019190821161099e578181036193e3575b5050506003548015610ed4575f19016193c0816003618d4b565b8154905f199060031b1b191690556003555f5260046020525f6040812055600190565b6194056193f4618d99936003618d4b565b90549060031b1c9283926003618d4b565b90555f52600460205260405f20555f80806193a6565b5f818152600960205260409020548015617261575f19810181811161099e576008545f1981019190821161099e5781810361948e575b5050506008548015610ed4575f190161946b816008618d4b565b8154905f199060031b1b191690556008555f5260096020525f6040812055600190565b6194b061949f618d99936008618d4b565b90549060031b1c9283926008618d4b565b90555f52600960205260405f20555f8080619451565b906001820191815f528260205260405f20548015155f1461956f575f19810181811161099e5782545f1981019190821161099e5781810361953a575b50505080548015610ed4575f19019061951b8282618d4b565b8154905f199060031b1b19169055555f526020525f6040812055600190565b61955a61954a618d999386618d4b565b90549060031b1c92839286618d4b565b90555f528360205260405f20555f8080619502565b505050505f90565b60018060a01b03165f52601b6020526001600160401b0360405f2091165f52602052600260405f2001805480158015618fb957618aeb57828110618f755750618f7082825461646c565b908160209103126105dd575190565b6001600160a01b039081165f8181526006602052604090205490911690811561965d57506040516311f9fbc960e21b81523360048201526024810192909252602090829060449082905f905af1908115610d75575f9161962e575090565b90506020813d602011619655575b816196496020938361624e565b810103126105dd575190565b3d915061963c565b905060ff600754166196775781616469913090339061970c565b63f6f24b8360e01b5f5260045260245ffd5b60ff5f80516020619f7c8339815191525460401c16156196a557565b631afcd79f60e31b5f5260045ffd5b905f602091828151910182855af115610d75575f513d61970357506001600160a01b0381163b155b6196e35750565b635274afe760e01b5f9081526001600160a01b0391909116600452602490fd5b600114156196dc565b6040516323b872dd60e01b60208201526001600160a01b0392831660248201529290911660448301526064808301939093529181526177969161840060848361624e565b9594909392918151908115619966576197759161976c9161648c565b9282519061648c565b905f5b815181101561996657806001600160401b03619796600193856167c7565b5116828060a01b0388165f52601b60205260405f206001600160401b0382165f52602052670de0b6b3a76400006198a360405f20858060a01b038d1693845f52601c60205260405f20878060a01b038d165f5260205260405f206001600160401b0382165f5260205260405f20946001600160401b035f54166001600160401b036003850191166001600160401b03198254161790555f52601e60205260405f20878060a01b038d165f526020526001600160401b0360405f2091165f52602052898960405f205491619957575b5080619919575b8a156198cd5786820161987f8b825461666a565b9055600282016198908a825461666a565b90555b898b156198ac57615b489161666a565b04905501619778565b5089808211156198c5576198bf9161646c565b90615b4a565b50505f6198bf565b81870180548b8181111561990a5750505f905b556002820180548a818111156198fb5750505f905b55619893565b6199049161646c565b906198f5565b6199139161646c565b906198e0565b83619925828454616479565b0485548082115f1461994f5761993a9161646c565b61994888870191825461666a565b905561986b565b50505f61993a565b6199609161646c565b89619864565b5050505050509050565b601f545f96929491939192916001600160a01b03909116908115619aa55780516199998161619c565b6199a28161619c565b619a9257505f955b15619a325750601f546001600160a01b031691823b15619a2e576040516316f60ec560e11b81526001600160a01b0394851660048201529484166024860152949092166044840152606483019390935261ffff166084820152908290829060a490829084905af1619a19575050565b619a2482809261624e565b619a2b5750565b80fd5b8680fd5b929194955050813b156105dd5760405162f74bbf60e71b81526001600160a01b039182166004820152928116602484015290931660448201526064810191909152905f908290608490829084905af1619a885750565b5f6177969161624e565b602001516001600160a01b0316956199aa565b5050505050505050565b90929694919460205460018060a01b0316948515619b5557853b156105dd57619b425f98899561ffff93619b159c6040519d8e9c8d9b8c9a6308aec52d60e31b8c5260018060a01b031660048c015260018060a01b031660248b015260448a01906161a6565b6084880152151560a4870152619b2a8161619c565b60c486015261012060e48601526101248501906162c4565b911661010483015203925af1619a885750565b505050505050505050565b6001600160a01b03165f908152601860205260409020600181015480158015619baf575b618b0d57619b97600291619ba094616479565b9101549061648c565b908115619ba957565b60019150565b50600282015415619b84565b9290918115619c74575f925f9460018060a01b03165f52601160205260405f20905f5260205260405f205f908054915b828110619c9a575050508215619c745781808210619c9257619c0c9161646c565b82811015619c8b575b80831115619c8457619c27908361646c565b80821015619c7e575080925b8315619c745761ffff93610a55619c50619c709561732b9461648c565b91619c6b87619c626127109584616479565b9416918661646c565b616479565b1690565b5050505061271090565b92619c33565b505f619c27565b5081619c15565b50505f619c0c565b619ca48183619051565b506001810154436001600160401b038260081c1611619cc8575b5050600101619beb565b97610a55619cf7929861ffff619cef619ce660ff6001989e16618b1c565b9b54809361666a565b9a1690619e35565b96905f619cbe565b90600582101590816114825782158015619d7f575b828115619d6f575b8115619d5f575b8115619d4f575b50619d4a57506114825760ff9063aae758a160e01b5f521660045260245ffd5b915050565b9050611482576004831482619d2a565b9050611482576003831482619d23565b9050611482576002831482619d1c565b505f915060018314619d14565b60058110156114825760018114619dcf5760028114619dc75760038114619dbf57600414619db8575f90565b62ed4e0090565b506276a70090565b50624f1a0090565b5062278d0090565b90619dfb5750805115619dec57805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580619e2c575b619e0c575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b15619e04565b81810291905f5f19838309848082109103818114619e73570360011115619e6157509060019109900390565b634e487b71905260116020526024601cfd5b50505050509056fe2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbce34918ff1c7084970068b53fd71ad6d8b04e9f15d3886cbf006443e6cdc52ea669892194d2f1eb4d48bd09f166bfce1754a681e8e17011b3e12b710cce56a87b12b42e8a160f6064dc959c6f251e3af0750ad213dbecf573b4710d67d6c28e3902dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800cd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033009b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00a164736f6c634300081a000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x1AW[6\x15a\0\x18W_\x80\xFD[\0[_5`\xE0\x1C\x80by\x10\xD0\x14aXdW\x80c\x01\xFF\xC9\xA7\x14aX\x0EW\x80c\x02n@+\x14aW\xD9W\x80c\x03X|\x1D\x14aW>W\x80c\x03x\x02\x11\x14aV\xB1W\x80c\x05\xD6N8\x14aV\x89W\x80c\n\x8D\xDC^\x14aVFW\x80c\n\xA8\xB1\x10\x14aU\xA8W\x80c\x0C\x883\xCE\x14aT4W\x80c\x15\x04\x9AZ\x14aR\xE0W\x80c\x16\x8Fhe\x14aP\xF4W\x80c\x18\x05m\xC2\x14aP\xD8W\x80c\x1B\xA9\x99\x8B\x14aO\xEEW\x80c#\xCC'\0\x14aL,W\x80c$\x8A\x9C\xA3\x14aL\x0EW\x80c&\x14#5\x14aK\xD5W\x80c(\xE7\x0E\xCC\x14aKtW\x80c*\xCD\xE0\x98\x14aJDW\x80c.@\xF7\xFB\x14aJ\x1EW\x80c.\xE6c\xB8\x14aI[W\x80c//\xF1]\x14aI*W\x80c0\"O\xC8\x14aH\xF2W\x80c1\xCC\x13\xBA\x14aG\xBBW\x80c2'?a\x14aG\x97W\x80c5N\xBE\xF9\x14aF\xB8W\x80c5i$\xEA\x14aF|W\x80c6V\x8A\xBE\x14aF8W\x80c=\xCA\xD9\xDB\x14aDuW\x80c?K\xA8:\x14aC\xF7W\x80cD\xAF\xF2R\x14aB\xB5W\x80cD\xD1H\x0B\x14a@\x18W\x80cE>\xCC\xEA\x14a?\xFCW\x80cF\x1C\xC2;\x14a?\xC6W\x80cHc\x98\xC3\x14a?\x8EW\x80cIb\xF8\x8F\x14a\x17\x84W\x80cLN\xDE-\x14a?mW\x80cM\x99\xDD\x16\x14a<`W\x80cM\xE8\xAD\xDC\x14a<7W\x80cN\x9C\x92\x9A\x14a$\xABW\x80cO\x1E\xF2\x86\x14a:.W\x80cP\x95\xAFd\x14a:\x07W\x80cR\xD1\x90-\x14a9\xA1W\x80cT\xDE# \x14a9\x85W\x80cW\"\xD5\x12\x14a8\x16W\x80cW`\x1C]\x14a7\xC8W\x80cX\\\xD3K\x14a7\x08W\x80c\\\x97Z\xBB\x14a6\xDAW\x80c_\xDC\x8F-\x14a6\x84W\x80ca]$\xDE\x14a6aW\x80cf\xC3hu\x14a,\x1BW\x80ch\xA9\xF1\x9C\x14a68W\x80ci}\x08\xF9\x14a-6W\x80cmp\xF7\xAE\x14a5\xF6W\x80cn\xC3\xABg\x14a4\xE4W\x80cp\x80u(\x14a4DW\x80cr\xB5\x03-\x14a+\xBFW\x80cu\xB28\xFC\x14a4\nW\x80cw\xAB,\xF3\x14a3\xE8W\x80c{v\xFE^\x14a3\x86W\x80c{\x99\x96\xC5\x14a24W\x80c|o1X\x14a2\x17W\x80c}iA\xC6\x14a1\xE2W\x80c}\xF9*\xDA\x14a1\xC5W\x80c\x84V\xCBY\x14a1TW\x80c\x85\x9C\xAA\x18\x14a.{W\x80c\x87p5P\x14a-\xA0W\x80c\x8A\x19\xC8\xBC\x14a-{W\x80c\x8A\x7F\xE6\x0F\x14a-;W\x80c\x8C[J\xE7\x14a-6W\x80c\x8Dy]P\x14a,\xF2W\x80c\x91\xD1HT\x14a,\x9DW\x80c\x94\x94\xF4&\x14a,\\W\x80c\x96\x08Vs\x14a,\x1BW\x80c\x97\"\xF4\xB9\x14a+\xBFW\x80c\x97\xFE\xB9&\x14a+\x8AW\x80c\x9E\x87\x05\x85\x14a+mW\x80c\x9E\x8CI\xD4\x14a*\xE5W\x80c\xA2\x17\xFD\xDF\x14a*\xCBW\x80c\xA2\x99\xE2\x98\x14a)\xDEW\x80c\xA3\xB9\xC5\xC2\x14a(\xCAW\x80c\xA4W\xAF=\x14a'\xA1W\x80c\xA4\xB3-\xE8\x14a'gW\x80c\xA7\xFAo\x98\x14a'KW\x80c\xAA\xC6\xAA\x9C\x14a'\"W\x80c\xAA\xF5\xEBh\x14a'\0W\x80c\xAD<\xB1\xCC\x14a&\xA2W\x80c\xB0\xDF\xCE\x06\x14a&nW\x80c\xB3\x9B\xCF?\x14a\x1B[W\x80c\xB5K+\x9E\x14a&LW\x80c\xBA\x05\xBB\xF5\x14a&-W\x80c\xC0tI\xE2\x14a%\xD1W\x80c\xC3P\x82\xA9\x14a%\x07W\x80c\xC5P\xD98\x14a$\xABW\x80c\xC750%\x14a$'W\x80c\xCA\xDDU\x0C\x14a#WW\x80c\xCB\x15\x03\x8B\x14a\"\xE6W\x80c\xCB\xB6\xD6\xBD\x14a \rW\x80c\xCE\xA9\xD2o\x14a\x1E^W\x80c\xD0\xE3\r\xB0\x14a\x1E;W\x80c\xD1sk\xA7\x14a\x1D\x0FW\x80c\xD2zo\x06\x14a\x1C\xF2W\x80c\xD5Gt\x1F\x14a\x1C\xBCW\x80c\xD6U\xB9*\x14a\x1B\x93W\x80c\xD6s\xE0\xB9\x14a\x1B[W\x80c\xD7u\xCBa\x14a\x1B\x15W\x80c\xD9\xE2W\xEF\x14a\x1AqW\x80c\xDB\x8A\x17:\x14a\x1AKW\x80c\xDC\x97,\xCC\x14a\x19\x97W\x80c\xDE\xFE S\x14a\x19oW\x80c\xE0\xA5\x82[\x14a\x17\xA0W\x80c\xE1\xA4R\x18\x14a\x17\x84W\x80c\xE1\xEEK\xCC\x14a\x14\xE6W\x80c\xE4\xE8\x8D\xE8\x14a\x14\x96W\x80c\xEBG53\x14a\x14\x16W\x80c\xF0\xB5+\xB4\x14a\x12!W\x80c\xF3@\xC0\xD0\x14a\x11\x0FW\x80c\xF3\x8C|N\x14a\x10\xC7W\x80c\xF3\xC4\xD8\xA0\x14a\x10BW\x80c\xF3\xC9\xB3\x11\x14a\x10%W\x80c\xF4i\x13\xBB\x14a\x0F\xE8W\x80c\xF7\xCBx\x9A\x14a\x0F\xC0W\x80c\xF8\xFD\x97\x95\x14a\n\xFCW\x80c\xFB\xCC{=\x14a\n\xB9W\x80c\xFB\xECHa\x14a\nnW\x80c\xFC^~\t\x14a\t\xE9W\x80c\xFC\x8A\x91\xAF\x14a\x05\xE1Wc\xFD}=\xBC\x03a\0\x0EW4a\x05\xDDWa\x05\xCAa\x05\xC4a\x05\xA66ac:V[a\x05\xB5\x96\x92\x95\x96\x94\x93\x94ah\x16V[a\x05\xBDag\x16V[6\x91af\x8EV[\x93a\x84\x1EV[`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[_\x80\xFD[4a\x05\xDDWa\x05\xEF6ac\0V[\x90a\x05\xF8ah\x16V[\x81\x15a\t\xDAW`\x01`\x01`\xA0\x1B\x03\x16\x90\x81a\t\xBEW`@Qa\x06\x19\x81aa\xE2V[_\x81R_` \x82\x01R\x91[a\x06-\x83argV[\x92`\x01\x80`\xA0\x1B\x03\x85\x16\x94\x85_R`\x18` R`@_ `\x02\x81\x01T\x90\x81\x15\x80\x15a\t\xB2W[\x15a\tlWPP\x83\x90[_\x95_[3_R`\x13` R`@_ T\x81\x10\x15a\t`W3_R`\x13` Ra\x06\x8A\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x8A\x14\x80a\tIW[a\x06\xABWP`\x01\x01a\x06aV[\x92\x93\x94\x95\x96\x97PP_\x903_R`\x15` R`@_ _\x91\x81T\x92[\x83\x81\x10a\x08\xD5WPPPPa\x06\xE0\x90`\x01\x83\x01TadlV[\x83\x81\x10a\x08\xB5WP3_R`\x15` R`@_ \x93a\x07\x11`\xFF`\x03`\x01`\x01`@\x1B\x03_T\x16\x94\x01T\x16\x93ad@V[\x90`@Q\x92a\x07\x1F\x84ab\x18V[\x89\x84R` \x84\x01\x91\x82R`@\x84\x01\x96\x86\x88R``\x85\x01\x91\x82R`\x80\x85\x01\x95a\x07F\x81aa\x9CV[\x86R`\xA0\x85\x01\x93\x84R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x07l\x91`\x01\x82\x01\x81UagNV[\x95\x90\x95a\x08\x8EW\x93Q\x85T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x85U\x90Q\x80Q\x8A\x97`\x04\x95a\x08\x18\x94\x93\x90\x92a\x07\xE2\x91`\x01\x8A\x01\x91a\x07\xBC\x90a\x07\xB6\x81aa\x9CV[\x83ag\xDBV[` \x01Q\x81Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x90UV[Q`\x02\x87\x01U`\x01`\x01`@\x1B\x03\x80`\x03\x88\x01\x93Q\x16\x16`\x01`\x01`@\x1B\x03\x19\x83T\x16\x17\x82UQ\x90a\x08\x13\x82aa\x9CV[ag\xF3V[Q\x91\x01U`\x01`\x01`@\x1B\x03`\x01\x94a\x088_T\x83\x81`\xC0\x1C\x91\x16aggV[\x90`@Q\x93\x84R` \x84\x01R\x16`@\x82\x01R\x7F\x062]\x83C]\xA8vW\xB0c\xC6\x14*[\x91\xA6j~\x81\x18'\xD0\x82\xD6$(z\x99S\xC4\xBA``3\x92\xA4[\x15a\x08xW\0[c\t\x07\x8C\xFF`\xE2\x1B_R3`\x04R`$R`D_\xFD[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[a\x08\xC0\x87\x91\x84a\x8A\xB7V[c\x88\xC4\xFE\x8F`\xE0\x1B_R`\x04R`$R`D_\xFD[\x8Ba\x08\xE0\x82\x85agNV[PT`\x01`\x01`\xA0\x1B\x03\x16\x14\x80a\t#W[a\x08\xFFW[`\x01\x01a\x06\xC7V[\x93a\t\x1B`\x01\x91`\x02a\t\x12\x88\x87agNV[P\x01T\x90afjV[\x94\x90Pa\x08\xF7V[P\x81a\tCa\t>`\x01a\t7\x85\x88agNV[P\x01ag\x95V[argV[\x14a\x08\xF2V[P\x82a\tZa\t>`\x02\x84\x01ag\x95V[\x14a\x06\x9EV[PPPPPPPa\x08qV[\x81a\t~`\x01a\t\x83\x93\x01T\x88adyV[afjV[_\x19\x81\x01\x91\x90\x82\x11a\t\x9EWa\t\x98\x91ad\x8CV[\x90a\x06]V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[P`\x01\x81\x01T\x15a\x06SV[`@Qa\t\xCA\x81aa\xE2V[`\x01\x81R\x82` \x82\x01R\x91a\x06$V[c\x1F* \x05`\xE0\x1B_R`\x04_\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa\n\x02aa!V[_\x90`\x01`\x01`\xA0\x1B\x03\x16\x81[\x81_R`\x13` R`@_ T\x83\x10\x15a\ncWa\n[`\x01\x91\x83_R`\x13` Ra\nUa\nA\x86`@_ af\xE9V[P\x84\x80\x80`\xA0\x1B\x03\x82T\x16\x91\x01T\x90a\x8A\xB7V[\x90afjV[\x92\x01\x91a\n\x0FV[` \x90`@Q\x90\x81R\xF3[a\x05\xCAa\x05\xC4a\n}6ac:V[a\n\x8C\x96\x92\x95\x96\x94\x93\x94ah\x16V[a\n\x94ag\x16V[`\x01`\x01`\xA0\x1B\x03\x84\x16a\n\xAAWa\x05\xBDawwV[a\n\xB4\x85\x85a|\xEAV[a\x05\xBDV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa\n\xD2aa!V[a\n\xDAam\x1AV[` \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa\x0B\x14ag\x16V[_3_R`\x12` R`@_ \x90_\x90\x82T\x92a\x0B0\x84afwV[a\x0B=`@Q\x91\x82abNV[\x84\x81R`\x1F\x19a\x0BL\x86afwV[\x016` \x83\x017a\x0B\\\x85afwV[\x94a\x0Bj`@Q\x96\x87abNV[\x80\x86R`\x1F\x19a\x0By\x82afwV[\x01_[\x81\x81\x10a\x0F\x9DWPPa\x0B\x8E\x81afwV[\x93a\x0B\x9C`@Q\x95\x86abNV[\x81\x85R`\x1F\x19a\x0B\xAB\x83afwV[\x016` \x87\x017_`\x01`\x01`@\x1B\x03_T\x16\x90`\x01`\x01`@\x1B\x03`\x01T\x16\x90[\x89\x87\x86\x83\x10a\x0E\xF5W\x89\x8B\x91\x89\x83a\r\x9FW[PP_[\x82\x81\x10a\x0B\xFEW`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[a\x0C\x08\x81\x85ag\xC7V[Q\x90a\x0C\x14\x81\x84ag\xC7V[Q\x91\x80Qa\x0C!\x81aa\x9CV[a\x0C*\x81aa\x9CV[a\x0C\xDBWP\x90_\x80\x80\x80\x933Z\xF1a\x0C@awHV[P\x15a\x0C\x9DW`\x01\x90[\x81\x80`\xA0\x1B\x03` a\x0C\\\x83\x88ag\xC7V[Q\x01Q\x16a\x0Cj\x82\x85ag\xC7V[Q`@Q\x90\x81R\x7F\xD1\xC1\x9F\xBC\xD4U\x1A^\xDF\xB6mC\xD2\xE37\xC0H7\xAF\xDA4\x82\xB4+\xDFV\x9A\x8F\xCC\xDA\xE5\xFB` 3\x92\xA3\x01a\x0B\xE4V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x16`$\x82\x01Ru\x13\x98]\x1A]\x99H\x1D\x1C\x98[\x9C\xD9\x99\\\x88\x19\x98Z[\x19Y`R\x1B`D\x82\x01R`d\x90\xFD[` \x90\x81\x01\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x90\x81R`\x06\x90\x93R`@\x90\x92 T\x90\x91\x16\x92\x90\x83\x15a\r\x80WP`@Qc\xF3\xFE\xF3\xA3`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x91\x90\x91R\x91` \x90\x83\x90`D\x90\x82\x90_\x90Z\xF1\x91\x82\x15a\ruW`\x01\x92a\rGW[Pa\x0CJV[a\rg\x90` =\x81\x11a\rnW[a\r_\x81\x83abNV[\x81\x01\x90a\x95\xC1V[P\x85a\rAV[P=a\rUV[`@Q=_\x82>=\x90\xFD[Q`\x01\x93Pa\r\x9A\x91\x903\x90`\x01`\x01`\xA0\x1B\x03\x16a\x83\xC4V[a\x0CJV[\x90\x91\x92\x93_\x94_[\x84T\x81\x10\x15a\x0E\x96Wa\r\xBA\x81\x85ag\xC7V[Q\x15a\r\xC9W[`\x01\x01a\r\xA7V[\x95\x86\x81\x03a\r\xE5W[a\r\xDD`\x01\x91ag\x87V[\x96\x90Pa\r\xC1V[a\r\xEF\x87\x86a\x84\x05V[Pa\r\xFA\x82\x87a\x84\x05V[\x92\x90\x92a\x08\x8EW\x82\x82a\r\xDD\x93`\x01\x95\x14\x15\x80a\x0E\x1DW[PPP\x91PPa\r\xD2V[`\x01`\x01`@\x1B\x03`\x02\x81\x93\x81\x93a\x0EVW[\x88\x81\x01T\x89\x87\x01U\x01T\x16\x92\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x89\x80\x80a\x0E\x12V[a\x0Ed`\xFF\x82T\x16\x87ag\xDBV[\x80T\x86Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x82\x1C`\xA0\x8C\x90\x1B\x8C\x90\x03\x16\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x86Ua\x0E0V[P\x91P\x91\x93\x92[\x84T\x84\x81\x11\x15a\x0E\xE8W\x80\x15a\x0E\xD4W_\x19\x01a\x0E\xBA\x81\x87a\x84\x05V[a\x08\x8EW`\x02\x81_\x80\x93U\x82`\x01\x82\x01U\x01U\x85Ua\x0E\x9DV[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[P\x91\x93P\x91P\x83\x80a\x0B\xE0V[a\x0F\x17\x84`\x01`\x01`@\x1B\x03`\x02a\x0F\x0E\x87\x83\x96a\x84\x05V[P\x01T\x16aggV[\x16\x84\x10\x15a\x0F)W[P`\x01\x01a\x0B\xCDV[a\x0F\x8E\x8A\x95a\x0Fi\x84\x9Ca\x0F\x94\x94a\x0FYa\x0FS\x88\x8F\x8Fa\x0FM`\x01\x9C\x8D\x92ag\xC7V[Ra\x84\x05V[Pag\x95V[a\x0Fc\x83\x83ag\xC7V[Rag\xC7V[P\x83a\x0Fu\x8D\x8Ca\x84\x05V[P\x01Ta\x0F\x82\x88\x8Dag\xC7V[R\x83a\t\x12\x8D\x8Ca\x84\x05V[\x94ag\x87V[\x98\x90P\x89a\x0F V[` \x90`@Qa\x0F\xAC\x81aa\xE2V[_\x81R_\x83\x82\x01R\x82\x82\x8B\x01\x01R\x01a\x0B|V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03_T`@\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a\x10\taa!V[\x16_R`\n` R` `$5`@_ T\x10\x15`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qb\xEDN\0\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045a\xFF\xFF\x81\x16\x80\x82\x03a\x05\xDDWa'\x10\x90a\x10nam\x1AV[\x11a\x10\x94W`\x01\x80Ta\xFF\xFF`\x80\x1B\x19\x16`\x80\x92\x90\x92\x1Ba\xFF\xFF`\x80\x1B\x16\x91\x90\x91\x17\x90U\0[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0B`$\x82\x01RjInvalid BPS`\xA8\x1B`D\x82\x01R`d\x90\xFD[` 6`\x03\x19\x01\x12a\x05\xDDW`\x045`\x05\x81\x10\x15a\x05\xDDWa\x05\xCA\x90a\x10\xEBah\x16V[a\x10\xF3ag\x16V[`@Qa\x10\xFF\x81aa\xE2V[_\x81R_` \x82\x01R4\x90a\x91\x94V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a\x110aa!V[\x16_R`\x12` R`@_ \x80T\x90a\x11H\x82afwV[\x91a\x11V`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x80\x92_R` _ _\x91[\x83\x83\x10a\x11\xDAW\x84\x86`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10a\x11\x9AWPPP\x03\x90\xF3[\x91\x93P\x91` `\x80`\x01\x92`\x01`\x01`@\x1B\x03`@\x88Qa\x11\xBC\x84\x82Qaa\xA6V[\x85\x81\x01Q\x82\x85\x01R\x01Q\x16``\x82\x01R\x01\x94\x01\x91\x01\x91\x84\x93\x92a\x11\x8CV[`\x03` `\x01\x92`@Qa\x11\xED\x81aa\xFDV[a\x11\xF6\x86ag\x95V[\x81R\x84\x86\x01T\x83\x82\x01R`\x01`\x01`@\x1B\x03`\x02\x87\x01T\x16`@\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90a\x11hV[4a\x05\xDDW`\xC06`\x03\x19\x01\x12a\x05\xDDWa\x12:aa!V[a\x12Baa7V[\x90`D5`d5\x90`\xA45\x92a\xFF\xFF\x84\x16\x80\x94\x03a\x05\xDDWa\x12bam\x89V[`\x01`\x01`\xA0\x1B\x03\x16\x93a\x12w\x85\x15\x15ad\x07V[`\x01`\x01`\xA0\x1B\x03\x16\x91a\x12\x8C\x83\x15\x15ae\xC8V[`@QcU\x1CE{`\xE1\x1B\x81R`\x04\x81\x01\x86\x90R\x93` \x85`$\x81\x87Z\xFA\x93\x84\x15a\ruW`\x05a\x13Qa\xFF\xFF\x92a\x12\xEF`@\x98\x7F\x9ALY\xC5aS$^#\xDC\xB8\0\x0E0\x1B\x9A^5\xB8\xE6i<\\\xDB\xF3\xB6\xA2\xAA\x0F\x8A7\xEA\x9A_\x91a\x13\xE7W[Paf\x1EV[\x89_R`\x06` R\x87_ \x81k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x82T\x16\x17\x90U\x87Q\x90\x8A\x7F\xC4}\xF1J\xD90\x9BY\x075F\xF9=\xBE1\x15\xED\t\xC8\xB2\x06\xD9@\xF8D\x1D\xDB\x07\xF7E\xB1\x0B_\x80\xA3a\x13B\x81aa\xE2V[`\x01\x81R\x89` \x82\x01RargV[\x86Q\x90a\x13]\x82ab\x18V[`\x01\x82R` \x82\x01\x87\x81R\x88\x83\x01\x87\x81R``\x84\x01\x91`\x845\x83R`\x80\x85\x01\x93_\x85R`\xA0\x86\x01\x98\x89R_R`\x02` Ra\x13\xAA\x8B_ \x95Q\x15\x15\x86\x90`\xFF\x80\x19\x83T\x16\x91\x15\x15\x16\x17\x90UV[Q`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ`\x04\x82\x01U\x01\x91Q\x16a\xFF\xFF\x19\x82T\x16\x17\x90Ua\x13\xD9\x85a\x8D\xC6V[P\x82Q\x91\x82R` \x82\x01R\xA2\0[a\x14\t\x91P` =` \x11a\x14\x0FW[a\x14\x01\x81\x83abNV[\x81\x01\x90af\x06V[\x8Ca\x12\xE9V[P=a\x13\xF7V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a\x147aa!V[\x16\x80_R`\t` R`@_ T\x15\x15\x80a\x14ZW[` \x90`@Q\x90\x15\x15\x81R\xF3[P_R`\n` R`\xFF`\x01`@_ \x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82W` \x90\x15a\x14MV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDE`\x01`\x01`\xA0\x1B\x03a\x14\xBCaa!V[\x16\x80_R`\n\x83R`@_ T\x90_R`\x18\x83R`\x02`@_ \x01T\x90afjV[`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x14\xFFaa!V[`$5\x90a\x15\x0Bah\x16V[\x81\x15a\t\xDAW`\x01`\x01`\xA0\x1B\x03\x16\x90\x81a\x17iW`@Qa\x15,\x81aa\xE2V[_\x81R_` \x82\x01R[a\x15?\x81argV[3_R`\x10` R`@_ \x81_R` R`@_ \x90\x81T\x90a\x15g`\x01\x84\x01T\x83adlV[\x90_\x903_R`\x11` R`@_ \x90_R` R`@_ _\x90\x80T\x91[\x82\x81\x10a\x17\x1DWPPP\x80\x83\x11\x15a\x17\x16W\x85a\x15\xA3\x82\x85adlV[\x10a\x16\xFFWP\x84\x81\x10a\x16\xE8WP\x83a\x15\xBB\x91adlV[\x90U3_R`\x12` R`@_ `\x01`\x01`@\x1B\x03_T\x16\x90`@Q\x92a\x15\xE2\x84aa\xFDV[\x83R` \x83\x01\x90\x84\x82R`@\x84\x01\x92\x83R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x16\x10\x91`\x01\x82\x01\x81Ua\x84\x05V[\x93\x90\x93a\x08\x8EW`\x01`\x01`@\x1B\x03\x92`\x02\x92a\x16c\x85\x93Qa\x16=\x81Qa\x167\x81aa\x9CV[\x89ag\xDBV[` \x01Q\x87Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x87UV[Q`\x01\x86\x01UQ\x16\x92\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x7F\x91\xEF\xF7\xD3\x9D$\x99\xD7j\xC2\x1A\x19\x03\xA9Z\x88\xF3\x15\x89\xCB\x07\xB1\xFF\xDF\xB6\x1D\xB9\xF7\xCD\x8A9xa\x16\xE3a\x16\xC2`\x01`\x01`@\x1B\x03_T\x16`\x01`\x01`@\x1B\x03`\x01T\x16\x90aggV[`@\x80Q\x94\x85R`\x01`\x01`@\x1B\x03\x90\x91\x16` \x85\x01R3\x93\x91\x82\x91\x82\x01\x90V[\x03\x90\xA3\0[\x84\x90c\xAD\xB9\xE0C`\xE0\x1B_R`\x04R`$R`D_\xFD[\x85\x90c\x8E\xC32\x11`\xE0\x1B_R`\x04R`$R`D_\xFD[\x85_a\x15\xA3V[a\x17'\x81\x83a\x90QV[P`\x01`\x01`@\x1B\x03`\x01C\x92\x01T`\x08\x1C\x16\x11a\x17HW[`\x01\x01a\x15\x86V[\x92a\x17a`\x01\x91a\x17Y\x86\x85a\x90QV[PT\x90afjV[\x93\x90Pa\x17@V[`@Qa\x17u\x81aa\xE2V[`\x01\x81R\x82` \x82\x01Ra\x156V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa'\x10\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x17\xB9aa!V[`$5\x90a\x17\xC5ah\x16V[a\x17\xCDag\x16V[3_R`\t` R`@_ Ta\x19\\W`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\x19IWa\x18\x0B`@Qa\x17\xFC\x81aa\xE2V[`\x01\x81R\x82` \x82\x01RargV[_R`\x02` R`@_ `\xFF\x81T\x16\x15a\x196W`\x01\x83\x91\x01T\x91\x82\x82\x10a\x19\x1FWa\x18<\x92P0\x903\x90a\x97\x0CV[a\x18E3a\x8D`V[P`@Qa\x18R\x81aa\xC7V[\x81\x81R` \x81\x01_\x81R`@\x82\x01_\x81Rc\xFF\xFF\xFF\xFF\x80`\x01``\x86\x01\x95_\x87R3_R`\n` R`@_ \x90Q\x81U\x01\x93Q\x16\x16c\xFF\xFF\xFF\xFF\x19\x83T\x16\x17\x82UQ`\x03\x81\x10\x15a\x14\x82Wa\x18\xE0\x92a\x18\xB4`\x01`\x01`@\x1B\x03\x92\x84ao#V[Q\x82Tl\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x19\x16\x91\x16`(\x1Bl\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x16\x17\x90UV[`@Q\x90\x81R\x7F\xBC\x11a~W]e\x8Ct\xE9!\xC8\xDF\"\xF8\xE4\x85f\x07/\xA7\x81E\xA6\xCF\xE1\x84 \xBF\x8D\x0CN` 3\x92\xA2`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[PPc\"\xDF\x05\x13`\xE1\x1B_R`\x04R`$R`D_\xFD[Pc\xF6\xF2K\x83`\xE0\x1B_R`\x04R`$_\xFD[c\xF6\xF2K\x83`\xE0\x1B_R_`\x04R`$_\xFD[c\x86k\r\xCF`\xE0\x1B_R3`\x04R`$_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW`\x1FT`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a\x19\xB8aa!V[\x16_R`\x0C` R`@_ `@Q\x80` \x83T\x91\x82\x81R\x01\x90\x81\x93_R` _ \x90_[\x81\x81\x10a\x1A5WPPP\x81a\x19\xF3\x91\x03\x82abNV[`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10a\x1A\x1CWPPP\x03\x90\xF3[\x82Q\x84R\x85\x94P` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x1A\x0EV[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01a\x19\xDDV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03`\x01T\x16`@Q\x90\x81R\xF3[_6`\x03\x19\x01\x12a\x05\xDDWa\x1A\x84ah\x16V[a\x1A\x8Cag\x16V[3_R`\n` R`@_ `\xFF`\x01\x82\x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x1B\x02W4\x15a\t\xDAWa\x1A\xC14\x82TafjV[\x90U`@Q4\x81R\x7FaJ?\xA8F~\xB5L\xB6\n\xF3\xAA\xB4@'\x987\xC9\xFC\xD7\\Z&\x17\xFE\n\xF9\xC6\xE5\xE6\x0E\x83` 3\x92\xA2`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[cq\xABj\xD5`\xE1\x1B_R3`\x04R`$_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa\x1BB`@Qa\x1B4\x81aa\xE2V[_\x81R_` \x82\x01RargV[_R`\x02` R` `\x01`@_ \x01T`@Q\x90\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDEa\x1Byaa!V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\n` R`@\x90 T\x90V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x1B\xACaa!V[a\x1B\xB4aa7V[\x90a\x1B\xBDam\x89V[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15a\x1CwW`\x01`\x01`\xA0\x1B\x03\x16\x90a\x1B\xE2\x82\x15\x15ae\xC8V[`@QcU\x1CE{`\xE1\x1B\x81R`\x04\x81\x01\x82\x90R` \x81`$\x81\x86Z\xFA\x80\x15a\ruWa\x1C\x15\x91_\x91a\x1CXWPaf\x1EV[_\x81\x81R`\x06` R`@\x81 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x84\x17\x90U\x7F\xC4}\xF1J\xD90\x9BY\x075F\xF9=\xBE1\x15\xED\t\xC8\xB2\x06\xD9@\xF8D\x1D\xDB\x07\xF7E\xB1\x0B\x90\x80\xA3\0[a\x1Cq\x91P` =` \x11a\x14\x0FWa\x14\x01\x81\x83abNV[\x84a\x12\xE9V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FCannot set adapter for native\0\0\0`D\x82\x01R`d\x90\xFD[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\0\x18`\x045a\x1C\xDBaa7V[\x90a\x1C\xEDa\x1C\xE8\x82ac\xE9V[anAV[av\xACV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qbv\xA7\0\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa\x1D'ag\x16V[3_R`\n` R`@_ `\x01\x81\x01\x80T`\xFF\x81` \x1C\x16`\x03\x81\x10\x15a\x14\x82W`\x02\x03a\x1E(W`\x01`\x01`@\x1B\x03\x80_T\x16\x91`(\x1C\x16`\x01`\x01`@\x1B\x03`\x01T`@\x1C\x16\x90`\x01`\x01`@\x1B\x03a\x1D\x83\x83\x83aggV[\x16\x83\x10a\x1D\xFEWa\x1D\xC6_\x80\x80\x80\x89\x89\x82\x82T\x92Ud\x01\0\0\0\0d\xFF\0\0\0\0\x19\x82T\x16\x17\x90Ua\x1D\xB43a\x94\x1BV[P3Z\xF1a\x1D\xC0awHV[Pa\x82\xC7V[3\x7F\x12\x05\x99\xF8\x83\x01\x15\xED\x971\x89\xF8\xF4\x94|\xC7\x93\xFC\xD9\n\x15\xD4|Mj\xD8\xD1\xA3\xF1Z\xF74_\x80\xA2`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[`\x01`\x01`@\x1B\x03\x92\x91a\x1E\x11\x91aggV[\x90c\x1B\x04\xD9\x1D`\xE2\x1B_R`\x04R\x16`$R`D_\xFD[c\x99#\xC59`\xE0\x1B_R3`\x04R`$_\xFD[_6`\x03\x19\x01\x12a\x05\xDDWa\x1ENah\x16V[a\x1EVag\x16V[a\x05\xCAawwV[4a\x05\xDDWa\x1El6ac\0V[3_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T\x91\x92\x90\x91`\xFF\x16\x15a\x1F\xF6W`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x1F\xBDW\x81\x15a\x1F\x87W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R`\x04` R`@\x90 T\x90\x92\x90a\x1FBW_\x83\x81R`\x06` R`@\x90 T`\x01`\x01`\xA0\x1B\x03\x16a\x1E\xFDWa\0\x18\x92a\x83\xC4V[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1B`$\x82\x01R\x7FCannot rescue adapted asset\0\0\0\0\0`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FCannot rescue registered asset\0\0`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0E`$\x82\x01Rm\x12[\x9D\x98[\x1AY\x08\x18[[\xDD[\x9D`\x92\x1B`D\x82\x01R`d\x90\xFD[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x11`$\x82\x01Rp\x12[\x9D\x98[\x1AY\x08\x1C\x99X\xDA\\\x1AY[\x9D`z\x1B`D\x82\x01R`d\x90\xFD[c\xE2Q}?`\xE0\x1B_R3`\x04R_`$R`D_\xFD[4a\x05\xDDW`\x806`\x03\x19\x01\x12a\x05\xDDWa &aa!V[`d5\x90a\xFF\xFF\x82\x16\x82\x03a\x05\xDDW_\x80Q` a\x9F|\x839\x81Q\x91RT\x91`\xFF\x83`@\x1C\x16\x15\x92`\x01`\x01`@\x1B\x03\x81\x16\x80\x15\x90\x81a\"\xDEW[`\x01\x14\x90\x81a\"\xD4W[\x15\x90\x81a\"\xCBW[Pa\"\xBCWg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x81\x16`\x01\x17_\x80Q` a\x9F|\x839\x81Q\x91RUh8\0\0\0\0\0\0\0\0\x92a!(\x91\x85a\"\x90W[Pa \xB4a\x96\x89V[a \xBCa\x96\x89V[a \xC4a\x96\x89V[a \xCCa\x96\x89V[`\xFF\x19_\x80Q` a\x9F<\x839\x81Q\x91RT\x16_\x80Q` a\x9F<\x839\x81Q\x91RUa \xF6a\x96\x89V[a \xFEa\x96\x89V[`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RUa!\x18\x81ao\xCDV[Pa!\"\x81apdV[Paq\x1DV[Pa!8`@Qa\x1B4\x81aa\xE2V[a\xFF\xFF`\x05`@Qa!I\x81ab\x18V[`\x01\x81R` \x81\x01`$5\x81R`@\x82\x01`D5\x81R``\x83\x01\x90_\x82R`\x80\x84\x01\x92_\x84R`\xA0\x85\x01\x97a'\x10\x89R_R`\x02` Ra!\x9D`@_ \x95Q\x15\x15\x86\x90`\xFF\x80\x19\x83T\x16\x91\x15\x15\x16\x17\x90UV[Q`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ`\x04\x82\x01U\x01\x91Q\x16a\xFF\xFF\x19\x82T\x16\x17\x90U`\x01`\xFF\x19`\x05T\x16\x17`\x05U`\x1C`\x01Tx\x1C\0\0\0\0\0\0\0\0\0\0\0\0\0\0T`\0\0\0\0\0\0\0\x01`\x01`\x01`@\x1B\x03`\x80\x1BB`\x80\x1B\x16\x17_Ug\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x92a\xFF\xFF`\x80\x1B\x90`\x80\x1B\x16\x90q\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x17\x17\x16\x17`\x01Ua\">W\0[`\xFF`@\x1B\x19_\x80Q` a\x9F|\x839\x81Q\x91RT\x16_\x80Q` a\x9F|\x839\x81Q\x91RU\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2` `@Q`\x01\x81R\xA1\0[h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16h\x01\0\0\0\0\0\0\0\x01\x17_\x80Q` a\x9F|\x839\x81Q\x91RU\x85a \xABV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[\x90P\x15\x85a sV[0;\x15\x91Pa kV[\x85\x91Pa aV[4a\x05\xDDW``6`\x03\x19\x01\x12a\x05\xDDWa\"\xFFaa!V[`D5`\x05\x81\x10\x15a\x05\xDDWa#\x13ah\x16V[a#\x1Bag\x16V[`\x01`\x01`\xA0\x1B\x03\x82\x16\x80\x15a\x19IWa#;a\x05\xCA\x93`$5\x90a\x95\xD0V[\x90`@Q\x90a#I\x82aa\xE2V[`\x01\x82R` \x82\x01Ra\x91\x94V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a#xaa!V[\x16\x80_R`\n` R`@_ `\xFF`\x01\x82\x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa#\xF5W`\x01\x90T\x91\x80_R`\x18` R`\x02`@_ \x01T\x90`@Q\x93a#\xC0\x85aa\xE2V[\x84R` \x84\x01\x91\x82R`\x01`\x01`@\x1B\x03_T\x16_R`\x0E` R`@_ \x90_R` R`@_ \x92Q\x83UQ\x91\x01U_\x80\xF3[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\n`$\x82\x01RiNot active`\xB0\x1B`D\x82\x01R`d\x90\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa$@aaMV[3_R`\n` R`\xFF`\x01`@_ \x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x1B\x02W3_R`\x0C` Ra$\x83`\x01`\x01`@\x1B\x03`@_ \x92\x16\x80\x92a\x8E\x16V[P3\x7F\xB6\xD5\xE4]w\xB8\x96|\xFFR[7[\xE6\xE0\x7F\x99\xCAZ\xF9\x1D\x88rJ\xC1#z\xAF\xE2\x95\xD5\x0E_\x80\xA3\0[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa$\xC4aaMV[`\x01`\x01`@\x1B\x03a$\xD4aa7V[\x91\x16_R`T` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R` `\x01`\x01`@\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa% aa!V[a%(aa7V[a%0ae\x92V[Pa%9ae\x92V[P`\x01`\x01`\xA0\x1B\x03\x16\x80a%\xB5WP`@Qa%U\x81aa\xE2V[_\x81R_` \x82\x01R\x90[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x10` R`@\x90 \x90a%\x80\x90argV[_R` Ra%\xB1a%\x94`@_ ae\xAAV[`@Q\x91\x82\x91\x82\x91\x90\x91` \x80`@\x83\x01\x94\x80Q\x84R\x01Q\x91\x01RV[\x03\x90\xF3[`@Q\x90a%\xC2\x82aa\xE2V[`\x01\x82R` \x82\x01R\x90a%`V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa%\xEAaaMV[`\x01`\x01`@\x1B\x03a%\xFAaa7V[\x91a&\x03ae\x92V[P\x16_R`\x0E` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` Ra%\xB1a%\x94`@_ ae\xAAV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` _T`\xC0\x1C`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\xFF`\x07T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa&\x86ag\x16V[a&\x8Ea\x83\x05V[P`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW`@\x80Q\x90a&\xC1\x81\x83abNV[`\x05\x82R` \x82\x01\x91d\x03R\xE3\x02\xE3`\xDC\x1B\x83R\x81Q\x92\x83\x91` \x83RQ\x80\x91\x81` \x85\x01R\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x81\x01\x03\x01\x90\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qg\r\xE0\xB6\xB3\xA7d\0\0\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa\0\x18a'>aa!V[a'Fam\x1AV[av\x1BV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa2\xC8\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Q\x7F\xB1\xFA\xDD1B\xAB*\xD7\xF13~\xA4\xD9q\x12\xBC\xC83\x7F\xC1\x1C\xE5\xB2\x0C\xB0J\xD08\xAD\xF9\x98\x19\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa'\xBAaa!V[a'\xC2aacV[\x90_`\xC0`@Qa'\xD2\x81ab3V[\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x01R`\x01\x80`\xA0\x1B\x03\x16_R`Q` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`\xE0`@_ `@Qa()\x81ab3V[\x81T\x91`\x01`\x01`@\x1B\x03\x83\x16\x92\x83\x83R` \x83\x01\x90`\x01`\x01`@\x1B\x03\x81`@\x1C\x16\x82R`\x01`\x01`@\x1B\x03`@\x85\x01\x91`\x80\x1C\x16\x81R`\x01`\x01`@\x1B\x03`\x01\x84\x01T\x91``\x86\x01\x92\x83R\x81`\x02\x86\x01T\x94`\x80\x88\x01\x95\x86R`\xC0`\x04`\x03\x89\x01T\x98`\xA0\x8B\x01\x99\x8AR\x01T\x98\x01\x97\x88R`@Q\x98\x89RQ\x16` \x88\x01RQ\x16`@\x86\x01RQ``\x85\x01RQ`\x80\x84\x01RQ`\xA0\x83\x01RQ`\xC0\x82\x01R\xF3[4a\x05\xDDW``6`\x03\x19\x01\x12a\x05\xDDWa(\xE3aa!V[a(\xEBaacV[P`D5\x90a'\x10a)\x06a\xFF\xFF`\x01T`\x80\x1C\x16\x84adyV[\x04\x91a)>a)\x15\x84\x83adlV[\x92`\x01\x80`\xA0\x1B\x03\x81\x16\x94\x85_R`\x1A` Ra)7`@_ \x91\x82TafjV[\x90Ua\x90\x1BV[\x82_R`\x18` R`@_ \x90`\x01\x82\x01\x91\x82T\x15\x15_\x14a)\xADWg\r\xE0\xB6\xB3\xA7d\0\0\x84\x02\x93\x80\x85\x04g\r\xE0\xB6\xB3\xA7d\0\0\x14\x90\x15\x17\x15a\t\x9EWa)\xA1a)\x9A_\x80Q` a\x9E\xBC\x839\x81Q\x91R\x95` \x95T\x90ad\x8CV[\x82TafjV[\x90U[`@Q\x90\x81R\xA2\0[P` \x91P_\x80Q` a\x9E\xBC\x839\x81Q\x91R\x92\x84_R`\x1A\x83Ra)\xD7`@_ \x91\x82TafjV[\x90Ua)\xA4V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a)\xFFaa!V[\x16\x80_R`\r` R`@_ T\x90a*\x17\x82afwV[\x91a*%`@Q\x93\x84abNV[\x80\x83Ra*1\x81afwV[` \x84\x01\x92\x90`\x1F\x19\x016\x847_[\x82\x81\x10a*\x94W\x83\x85`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10a*rWPPP\x03\x90\xF3[\x82Q`\x01`\x01`\xA0\x1B\x03\x16\x84R\x85\x94P` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a*dV[`\x01\x90\x82_R`\r` Ra*\xAC\x81`@_ a\x8DKV[\x83\x80`\xA0\x1B\x03\x91T\x90`\x03\x1B\x1C\x16a*\xC4\x82\x88ag\xC7V[R\x01a*@V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Q_\x81R\xF3[4a\x05\xDDW`\xC06`\x03\x19\x01\x12a\x05\xDDWa*\xFEaa!V[a+\x06aacV[a+\x0EaayV[\x90`d5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xDDW6`#\x82\x01\x12\x15a\x05\xDDW\x80`\x04\x015`\x01`\x01`@\x1B\x03\x81\x11a\x05\xDDW6`$``\x83\x02\x84\x01\x01\x11a\x05\xDDW` \x94a\x14\xDE\x94a+\\am\xF8V[`\xA45\x94`$`\x845\x95\x01\x92a}CV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qb'\x8D\0\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x05\xCAa+\xA6aa!V[a+\xAEah\x16V[a+\xB6ag\x16V[`$5\x90a|\xEAV[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa+\xD8aaMV[`\x01`\x01`@\x1B\x03a+\xE8aa7V[\x91\x16_R`S` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R` `\x01`\x01`@\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a,<aa!V[\x16_R`R` R` `\x01`\x01`@\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW``6`\x03\x19\x01\x12a\x05\xDDWa,uaa!V[a,}aacV[\x90`D5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW` \x92a\x14\xDE\x92ad\xAAV[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa,\xB6aa7V[`\x045_R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R` `\xFF`@_ T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW`\xA06`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDEa-\x10aa!V[a-\x18aacV[\x90a-!aayV[a-)am\xF8V[`\x845\x92`d5\x92ax,V[ab\x8AV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a-\\aa!V[\x16_R`\x06` R` `\x01\x80`\xA0\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03_T\x16`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW3_R`\n` R`\x01`@_ \x01`\xFF\x81T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x1B\x02Wa.!\x90d\x02\0\0\0\0d\xFF\0\0\0\0\x19\x82T\x16\x17\x81U`\x01`\x01`@\x1B\x03_T\x16l\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x82T\x91`(\x1B\x16\x90l\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\x19\x16\x17\x90UV[a.D`\x01`\x01`@\x1B\x03_T\x16`\x01`\x01`@\x1B\x03`\x01T`@\x1C\x16\x90aggV[`\x01`\x01`@\x1B\x03`@Q\x91\x16\x81R\x7F\xFDG\xED\x8Ee?\xBA^n\x9F\xCA\xA9GA\x9C\xA23K9r\xCE\x19a2\xECip\x85t\xD6\xD3Z` 3\x92\xA2\0[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDW`\x045a.\x97aacV[\x90a.\xA0ah\x16V[3_R`\x13` R`@_ T\x81\x10\x15a1BW3_R`\x13` Ra.\xC9\x81`@_ af\xE9V[P\x90`\x01`\xFF`\x03\x84\x01T\x16a.\xDE\x81aa\x9CV[\x03a13W3_R`\x14` R`@_ \x81_R` R`@_ \x80T\x92`\x01\x84\x11\x15a1$W`\x01`\x01`@\x1B\x03\x85\x16\x93_\x19\x93\x90_[\x81\x81\x10a0\xF1W[PP_\x19\x84\x14a0\xDEW3_\x90\x81R`\x1E` \x90\x81R`@\x80\x83 \x85T`\x01`\x01`\xA0\x1B\x03\x16\x84R\x82R\x80\x83 \x88\x84R\x90\x91R\x81 \x80T\x91\x90U\x83T_\x19\x81\x01\x95\x91\x90\x86\x11a\t\x9EWa/\x98`\x01`\x01`@\x1B\x03a/\x89a/\x82\x89a/\xB6\x95ad\x8CV[\x98\x88an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x92\x86an\x93V[\x81\x93\x91T\x90`\x01`\x01`@\x1B\x03\x80\x91`\x03\x1B\x93\x16\x83\x1B\x92\x1B\x19\x16\x17\x90V[\x90U\x82T\x80\x15a\x0E\xD4W_\x19\x01a/\xCD\x81\x85an\x93V[`\x01`\x01`@\x1B\x03\x82T\x91`\x03\x1B\x1B\x19\x16\x90U\x83U_[\x83T\x81\x10\x15a0LW3_\x90\x81R`\x1E` \x90\x81R`@\x80\x83 \x86T`\x01`\x01`\xA0\x1B\x03\x16\x84R\x90\x91R\x90 `\x01\x91\x90`\x01`\x01`@\x1B\x03\x80a0'\x84\x89an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x16_R` R`@_ a0D\x87\x82TafjV[\x90U\x01a/\xE4V[\x86\x83\x83\x88`@Q\x90\x81R\x7F\xC3\x8C\xEF\r\0;\xC8\xA9\x98-\xB0\xD9\x94\xB2\xEA\x04\x89F\x02\x8E\x92U\xCC\x06\x1AV\xAB\xCB\xB7\xD5H\xA1` 3\x92\xA3` T`\x01`\x01`\xA0\x1B\x03\x16\x80a0\x8FW\0[\x81T`\x01`\x01`\xA0\x1B\x03\x16\x90\x80;\x15a\x05\xDDW`\x02_\x80\x94a0\xCA`@Q\x97\x88\x96\x87\x95\x86\x94c-\x01\xC5\xCB`\xE0\x1B\x86R\x01\x903`\x04\x86\x01an\xD1V[\x03\x92Z\xF1a0\xD4W\0[_a\0\x18\x91abNV[\x84c0b#k`\xE1\x1B_R`\x04R`$_\xFD[\x86`\x01`\x01`@\x1B\x03a1\x04\x83\x88an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x14a1\x19W`\x01\x01a/\x16V[\x94P\x87\x90P\x80a/\x1EV[c0\x1A\xC9%`\xE2\x1B_R`\x04_\xFD[c\x13\x8D\xFE\xD5`\xE1\x1B_R`\x04_\xFD[c\x0B!\x81]`\xE1\x1B_R`\x04R`$_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa1lam\x1AV[a1tah\x16V[`\x01`\xFF\x19_\x80Q` a\x9F<\x839\x81Q\x91RT\x16\x17_\x80Q` a\x9F<\x839\x81Q\x91RU\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@QbO\x1A\0\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDWa&\x8E\x90a2\x12ag\x16V[aw\x98V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x08T`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a2Uaa!V[\x16_R`\x14` R`@_ `$5_R` R`@_ `@Q\x90\x81\x90` \x81T\x93\x84\x81R\x01\x90_R` _ \x92_\x93[\x81`\x03\x86\x01\x10a3:W\x91a%\xB1\x94\x84\x92a2\xC4\x94T\x91\x81\x81\x10a3 W[\x81\x81\x10a3\x03W[\x81\x81\x10a2\xE6W[\x10a2\xD8W[P\x03\x82abNV[`@Q\x91\x82\x91` \x83R` \x83\x01\x90ab\xC4V[`\xC0\x1C\x81R` \x01\x85a2\xBCV[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85`\x80\x1C\x16\x81R\x01\x93\x01a2\xB6V[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85`@\x1C\x16\x81R\x01\x93\x01a2\xAEV[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85\x16\x81R\x01\x93\x01a2\xA6V[\x91`\x01`\x80`\x04\x92\x85T`\x01`\x01`@\x1B\x03\x81\x16\x82R`\x01`\x01`@\x1B\x03\x81`@\x1C\x16` \x83\x01R`\x01`\x01`@\x1B\x03\x81\x84\x1C\x16`@\x83\x01R`\xC0\x1C``\x82\x01R\x01\x93\x01\x94\x01\x93a2\x87V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045\x80\x15\x15\x80\x91\x03a\x05\xDDW` \x7F\xE2\xC3u\xAEp\xEF\xA8/\x7F\x1D\x8E\x95U\xF8?-\xF5\xC6\x92\xD6h4\xEB\xAB\xBA\x9D\x89\x7F\xCAF\xF3\xDF\x91a3\xD0am\x89V[`\xFF\x19`\x07T\x16`\xFF\x82\x16\x17`\x07U`@Q\x90\x81R\xA1\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\xFF`\x05T\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Q\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa4]aa!V[a4eam\x89V[`\x01`\x01`\xA0\x1B\x03\x16\x80a4\xC6Wa4\x82`@Qa\x1B4\x81aa\xE2V[`\xFF\x19`\x05T\x16`\x05U[_R`\x02` R`@_ `\xFF\x19\x81T\x16\x90U\x7F\xFC\x92t\xADd\xAB\n}\x8D\xED\xD8\xC9)\x7F\xB4\xE2]z\x17\xEB\x05tW\xC6\xBC\xF2\xA8\xF1=\xC8\x85\x9C_\x80\xA2\0[a4\xD5`@Qa\x17\xFC\x81aa\xE2V[a4\xDE\x82a\x93pV[Pa4\x8DV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa4\xFDaa!V[_`\xA0`@Qa5\x0C\x81ab\x18V[\x82\x81R` \x81\x01\x83\x90R`@\x81\x01\x83\x90R``\x81\x01\x83\x90R`\x80\x81\x01\x83\x90R\x01R`\x01`\x01`\xA0\x1B\x03\x16\x80a5\xD8WPa5K`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\xC0`@_ a\xFF\xFF`@Qa5g\x81ab\x18V[`\xFF\x83T\x16\x15\x15\x92\x83\x82R`\x01\x81\x01T` \x83\x01\x90\x81R`\x02\x82\x01T`@\x84\x01\x90\x81R`\x03\x83\x01T\x91``\x85\x01\x92\x83R`\xA0\x86`\x05`\x04\x87\x01T\x96`\x80\x89\x01\x97\x88R\x01T\x16\x95\x01\x94\x85R`@Q\x96\x87RQ` \x87\x01RQ`@\x86\x01RQ``\x85\x01RQ`\x80\x84\x01RQ\x16`\xA0\x82\x01R\xF3[`@Qa5K\x91a5\xE8\x82aa\xE2V[`\x01\x82R` \x82\x01RargV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a6.`\x01`\x01`\xA0\x1B\x03a6\x1Caa!V[\x16_R`\t` R`@_ T\x15\x15\x90V[`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa\0\x18a6Taa!V[a6\\am\x1AV[aoHV[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDEa6\x7Faa!V[ad@V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa6\x9Daa!V[a6\xA5aacV[\x90`\x01\x80`\xA0\x1B\x03\x16_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R` `\x02`@_ \x01T`@Q\x90\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\xFF_\x80Q` a\x9F<\x839\x81Q\x91RT\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa7!aa!V[a7)am\x89V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x81\x81R`\x06` R`@\x90 T\x90\x91\x16\x15a7\x8BW_\x81\x81R`\x06` R`@\x81 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90U\x7F\xDF\x98\r!\xD8\xC7\xBB4\x80\x0Ef\x8D\xBE\x002\x99\t;\xAC\x8Ei6\x14\x15\x1D<W\xF7?\x98\xA9=\x90\x80\xA2\0[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x15`$\x82\x01Rt\x13\x9B\xC8\x18Y\x18\\\x1D\x19\\\x88\x1C\x99Y\xDA\\\xDD\x19\\\x99Y`Z\x1B`D\x82\x01R`d\x90\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWa7\xE1aa!V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` \x90\x81R`@\x91\x82\x90 T\x91Q`\xFF\x90\x92\x16\x15\x15\x82R\x90\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a87aa!V[\x16_R`\x15` R`@_ \x80T\x90a8O\x82afwV[\x91a8]`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x80\x92_R` _ _\x91[\x83\x83\x10a9\x0EW\x84\x86`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10a8\xA1WPPP\x03\x90\xF3[\x91\x93P\x91` `\xE0`\x01\x92`\xA0\x87Q\x85\x80\x83\x1B\x03\x81Q\x16\x83Ra8\xCA\x85\x82\x01Q\x86\x85\x01\x90aa\xA6V[`@\x81\x01Q``\x84\x01R`\x01`\x01`@\x1B\x03``\x82\x01Q\x16`\x80\x84\x01R`\x80\x81\x01Qa8\xF5\x81aa\x9CV[\x82\x84\x01R\x01Q`\xC0\x82\x01R\x01\x94\x01\x91\x01\x91\x84\x93\x92a8\x93V[`\x05` `\x01\x92`@Qa9!\x81ab\x18V[\x84\x80`\xA0\x1B\x03\x86T\x16\x81Ra97\x85\x87\x01ag\x95V[\x83\x82\x01R`\x02\x86\x01T`@\x82\x01R`\xFF`\x03\x87\x01T`\x01`\x01`@\x1B\x03\x81\x16``\x84\x01R`@\x1C\x16a9h\x81aa\x9CV[`\x80\x82\x01R`\x04\x86\x01T`\xA0\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90a8oV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa.\xE0\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x160\x03a9\xF8W` `@Q_\x80Q` a\x9E\x9C\x839\x81Q\x91R\x81R\xF3[cp>F\xDD`\xE1\x1B_R`\x04_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Q_\x80Q` a\x9E\xFC\x839\x81Q\x91R\x81R\xF3[`@6`\x03\x19\x01\x12a\x05\xDDWa:Baa!V[`$5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xDDW6`#\x83\x01\x12\x15a\x05\xDDW\x81`\x04\x015\x90a:n\x82aboV[\x91a:|`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x936`$\x83\x83\x01\x01\x11a\x05\xDDW\x81_\x92`$` \x93\x01\x877\x84\x01\x01R`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x81\x14\x90\x81\x15a<\x15W[Pa9\xF8Wa:\xE1am\x1AV[`@QcR\xD1\x90-`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16\x93\x90` \x81`\x04\x81\x88Z\xFA_\x91\x81a;\xE1W[Pa;#W\x84cL\x9C\x8C\xE3`\xE0\x1B_R`\x04R`$_\xFD[\x80_\x80Q` a\x9E\x9C\x839\x81Q\x91R\x86\x92\x03a;\xCFWP\x82;\x15a;\xBDW_\x80Q` a\x9E\x9C\x839\x81Q\x91R\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x82\x17\x90U\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x82Q\x15a;\xA4W_\x80\x91a\0\x18\x94Q\x90\x84Z\xF4a;\x9EawHV[\x91a\x9D\xD7V[PPP4a;\xAEW\0[c\xB3\x98\x97\x9F`\xE0\x1B_R`\x04_\xFD[cL\x9C\x8C\xE3`\xE0\x1B_R`\x04R`$_\xFD[c*\x87Ri`\xE2\x1B_R`\x04R`$_\xFD[\x90\x91P` \x81=` \x11a<\rW[\x81a;\xFD` \x93\x83abNV[\x81\x01\x03\x12a\x05\xDDWQ\x90\x86a;\x0BV[=\x91Pa;\xF0V[_\x80Q` a\x9E\x9C\x839\x81Q\x91RT`\x01`\x01`\xA0\x1B\x03\x16\x14\x15\x90P\x84a:\xD4V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03`\x01T`@\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa<yaa!V[`$5\x90a<\x85ah\x16V[a<\x8Dag\x16V[\x81\x15a\t\xDAW`@Q\x91a<\xA0\x83aa\xE2V[_\x83R_` \x84\x01Ra<\xB2\x83argV[\x91`\x01\x80`\xA0\x1B\x03\x81\x16\x93\x84_R`\x18` R`@_ `\x02\x81\x01T\x90\x81\x15\x80\x15a?aW[\x15a?5WPP\x82[_\x94_[3_R`\x13` R`@_ T\x81\x10\x15a?*W3_R`\x13` Ra=\x0E\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x89\x14\x80a?\x13W[a=/WP`\x01\x01a<\xE5V[\x92\x93\x94\x95\x96PP_\x903_R`\x15` R`@_ _\x91\x81T\x92[\x83\x81\x10a>\xB4WPPPPa=c\x90`\x01\x83\x01TadlV[\x82\x81\x10a>\xA9WP3_R`\x15` R`@_ \x92a=\x94`\xFF`\x03`\x01`\x01`@\x1B\x03_T\x16\x94\x01T\x16\x95ad@V[`@Q\x91a=\xA1\x83ab\x18V[\x88\x83R` \x83\x01\x90\x81R`@\x83\x01\x95\x85\x87R``\x84\x01\x94\x85R`\x80\x84\x01\x97a=\xC8\x81aa\x9CV[\x88R`\xA0\x84\x01\x92\x83R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa=\xEE\x91`\x01\x82\x01\x81UagNV[\x94\x90\x94a\x08\x8EW\x92Q\x84T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x84UQ\x80Q_\x97\x8A\x97`\x04\x95a>8\x94\x90\x93a\x07\xE2\x91`\x01\x8A\x01\x91a\x07\xBC\x90a\x07\xB6\x81aa\x9CV[Q\x91\x01U`\x01`\x01`@\x1B\x03`\x01\x94a>X\x85T\x83\x81`\xC0\x1C\x91\x16aggV[\x90`@Q\x93\x84R` \x84\x01R\x16`@\x82\x01R\x7F\x062]\x83C]\xA8vW\xB0c\xC6\x14*[\x91\xA6j~\x81\x18'\xD0\x82\xD6$(z\x99S\xC4\xBA``3\x92\xA4[\x15a\x08xW`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[a\x08\xC0\x86\x91\x86a\x8A\xB7V[\x8Aa>\xBF\x82\x85agNV[PT`\x01`\x01`\xA0\x1B\x03\x16\x14\x80a>\xF9W[a>\xDEW[`\x01\x01a=JV[\x93a>\xF1`\x01\x91`\x02a\t\x12\x88\x87agNV[\x94\x90Pa>\xD6V[P\x81a?\ra\t>`\x01a\t7\x85\x88agNV[\x14a>\xD1V[P\x82a?$a\t>`\x02\x84\x01ag\x95V[\x14a=\"V[PPPPPPa>\x91V[\x81a\t~`\x01a?G\x93\x01T\x87adyV[_\x19\x81\x01\x91\x90\x82\x11a\t\x9EWa?\\\x91ad\x8CV[a<\xE1V[P`\x01\x81\x01T\x15a<\xD8V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa?\x85ag\x16V[a&\x8E3aw\x98V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03a?\xAFaa!V[\x16_R`\r` R` `@_ T`@Q\x90\x81R\xF3[` 6`\x03\x19\x01\x12a\x05\xDDWa\x05\xCAa?\xDDaa!V[a?\xE5ah\x16V[a?\xEDag\x16V[a?\xF5awwV[4\x90ah=V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa>\x80\x81R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWa@0ag\x16V[_\x80[3_R`\x13` R`@_ T\x82\x10\x15aB9W3_R`\x13` Ra@\\\x82`@_ af\xE9V[P`\xFF`\x03\x82\x01T\x16a@n\x81aa\x9CV[aA\x04Wa@\xF3\x90`\x01\x92g\r\xE0\xB6\xB3\xA7d\0\0a@\xC3\x85\x80\x80`\xA0\x1B\x03\x85T\x16\x94\x01T\x84_R`\x18` R`@_ \x943_R`\x19` R`@_ \x90\x88\x80`\xA0\x1B\x03\x16_R` R`@_ \x94TadyV[\x04\x82T\x80\x82\x11_\x14a@\xFCWa@\xD9\x90\x82adlV[\x92[_a@\xEB\x87\x83\x01\x95\x86T\x90afjV[\x94UUafjV[\x91[\x01\x90a@3V[P_\x92a@\xDBV[3_\x90\x81R`\x14` \x90\x81R`@\x80\x83 \x86\x84R\x90\x91R\x81 \x91T\x90\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x81\x90\x83[\x81T\x81\x10\x15aB#W\x95`\x01\x87`\x01`\x01`@\x1B\x03aAQ\x83\x9A\x86an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x85_R`\x1B` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` Rg\r\xE0\xB6\xB3\xA7d\0\0aA\xDF`@_ 3_R`\x1C` R`@_ \x8A_R` R`@_ `\x01`\x01`@\x1B\x03\x85\x16_R` R`@_ \x933_R`\x1E` R`@_ \x8B_R` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ T\x90TadyV[\x04\x90\x80T\x80\x83\x11_\x14aB\x17WaB\x0BaA\xFA_\x92\x85adlV[\x9A[a\nU\x87\x85\x01\x9C\x8DT\x90afjV[\x99UU\x01\x90\x96PaA1V[P_aB\x0B\x81\x9AaA\xFCV[PPPPaB3\x90`\x01\x92afjV[\x91a@\xF5V[\x80aB[W[` \x90`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU`@Q\x90\x81R\xF3[_\x80\x80\x80\x843Z\xF1aBkawHV[P\x15aB\xA6W` \x90`@Q\x81\x81R\x7F\x10o\x92?\x99<!I\xD4\x9BBU\xFFr:\xCA\xFA\x1F-\x949?V\x1D>\xDA2\xAE4\x8FrA\x833\x92\xA2\x90PaB?V[c\x12\x17\x1D\x83`\xE3\x1B_R`\x04_\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045aB\xD1ah\x16V[3_R`\n` R`@_ `\xFF`\x01\x82\x01T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x1B\x02W\x81\x15a\t\xDAWaC\n`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\x01`@_ \x01T3_R`\x0B` RaC1`@_ T\x80\x93TadlV[\x81aC<\x85\x83adlV[\x10aC\xD7W\x83aCL\x81\x85afjV[`\x01`\x01`@\x1B\x03`\x01\x81\x80_T\x16`@Q\x94aCh\x86aa\xE2V[\x85R` \x85\x01\x90\x81R3_R`\x0B` R`@_ \x94Q\x85UQ\x16\x92\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x7F\xF7\xE8t\xD9\xFDB\x83\x8B\x0F\x06\xA4L{\xBEEA{\x99\x1Ek\0\x0E\x8C\xA4\xC5\xC1\xF0\x86\x08J\x9C\xD3aC\xD2a\x16\xC2_T`\x01`\x01`@\x1B\x03\x81`\xC0\x1C\x91\x16aggV[\x03\x90\xA2\0[\x83aC\xE1\x91adlV[\x90c\"\xDF\x05\x13`\xE1\x1B_R`\x04R`$R`D_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWaD\x0Fam\x1AV[_\x80Q` a\x9F<\x839\x81Q\x91RT`\xFF\x81\x16\x15aDfW`\xFF\x19\x16_\x80Q` a\x9F<\x839\x81Q\x91RU\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[c\x8D\xFC +`\xE0\x1B_R`\x04_\xFD[4a\x05\xDDW`\x806`\x03\x19\x01\x12a\x05\xDDWaD\x8Eaa!V[aD\x96aacV[\x90aD\x9FaayV[P`d5a'\x10aD\xB9a\xFF\xFF`\x01T`\x80\x1C\x16\x83adyV[\x04\x92aD\xEAaD\xC8\x85\x84adlV[\x93`\x01\x80`\xA0\x1B\x03\x81\x16\x95\x86_R`\x1A` Ra)7`@_ \x91\x82TafjV[\x83_R`\x18` R`@_ \x90`\x01\x82\x01\x91\x82T\x80aF\x02W[PP\x84_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ \x90`\x01`\x01`@\x1B\x03_T\x16`\x01`\x01`@\x1B\x03`\x03\x84\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U`\x01\x82\x01T\x80\x15\x92\x83\x15aE\xB2W[PP\x92` \x92\x91_\x80Q` a\x9E\xBC\x839\x81Q\x91R\x94T\x15\x90\x81aE\xAAW[PaE\x8CW[P`@Q\x90\x81R\xA2\0[\x84_R`\x1A\x83RaE\xA2`@_ \x91\x82TafjV[\x90U\x84aE\x82V[\x90P\x86aE|V[\x93\x92\x90\x94\x91g\r\xE0\xB6\xB3\xA7d\0\0\x83\x02\x94\x83\x86\x04g\r\xE0\xB6\xB3\xA7d\0\0\x14\x84\x15\x17\x15a\t\x9EWaE\xF5a)\x9A_\x80Q` a\x9E\xBC\x839\x81Q\x91R\x98` \x98ad\x8CV[\x90U\x91\x94\x81\x93\x94PaE]V[g\r\xE0\xB6\xB3\xA7d\0\0\x86\x02\x86\x81\x04g\r\xE0\xB6\xB3\xA7d\0\0\x14\x87\x15\x17\x15a\t\x9EWaF/\x91a)\x9A\x91ad\x8CV[\x90U\x85\x80aE\x04V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWaFQaa7V[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03aFmWa\0\x18\x90`\x045av\xACV[c3K\xD9\x19`\xE1\x1B_R`\x04_\xFD[4a\x05\xDDW`\x806`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDEaF\x9Aaa!V[aF\xA2aacV[\x90aF\xABam\xF8V[`d5\x91`D5\x91ar\xAEV[4a\x05\xDDW`\xA06`\x03\x19\x01\x12a\x05\xDDWaF\xD1aa!V[`$5\x90`D5\x90`\x845\x92a\xFF\xFF\x84\x16\x80\x94\x03a\x05\xDDW\x7F\x9ALY\xC5aS$^#\xDC\xB8\0\x0E0\x1B\x9A^5\xB8\xE6i<\\\xDB\xF3\xB6\xA2\xAA\x0F\x8A7\xEA\x92`@\x92aG\x16am\x89V[`\x01`\x01`\xA0\x1B\x03\x16\x94aG+\x86\x15\x15ad\x07V[a\xFF\xFF`\x05aG>\x86Qa\x13B\x81aa\xE2V[\x86Q\x90aGJ\x82ab\x18V[`\x01\x82R` \x82\x01\x87\x81R\x88\x83\x01\x87\x81R``\x84\x01\x91`d5\x83R`\x80\x85\x01\x93_\x85R`\xA0\x86\x01\x98\x89R_R`\x02` Ra\x13\xAA\x8B_ \x95Q\x15\x15\x86\x90`\xFF\x80\x19\x83T\x16\x91\x15\x15\x16\x17\x90UV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` a\xFF\xFF`\x01T`\x80\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03aG\xDCaa!V[\x16_R`\x13` R`@_ \x80T\x90aG\xF4\x82afwV[\x91aH\x02`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x80\x92_R` _ _\x91[\x83\x83\x10aH\x97W\x84\x86`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10aHFWPPP\x03\x90\xF3[\x91\x93P\x91` `\xA0`\x01\x92``\x87Q\x85\x80\x85\x1B\x03\x81Q\x16\x83R\x84\x81\x01Q\x85\x84\x01RaHy`@\x82\x01Q`@\x85\x01\x90aa\xA6V[\x01QaH\x84\x81aa\x9CV[`\x80\x82\x01R\x01\x94\x01\x91\x01\x91\x84\x93\x92aH8V[`\x04` `\x01\x92`@QaH\xAA\x81aa\xC7V[\x84\x80`\xA0\x1B\x03\x86T\x16\x81R\x84\x86\x01T\x83\x82\x01RaH\xC9`\x02\x87\x01ag\x95V[`@\x82\x01R`\xFF`\x03\x87\x01T\x16aH\xDF\x81aa\x9CV[``\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90aH\x14V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x01`\x01`\xA0\x1B\x03aI\x13aa!V[\x16_R`\x1A` R` `@_ T`@Q\x90\x81R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\0\x18`\x045aIIaa7V[\x90aIVa\x1C\xE8\x82ac\xE9V[aq\xD6V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaItaa!V[aI|ac\xC5V[PaI\x85ac\xC5V[P`\x01\x80`\xA0\x1B\x03\x16_R`\n` R`@_ `\x01`@Q\x91aI\xA8\x83aa\xC7V[\x80T\x83R\x01T\x90` \x81\x01c\xFF\xFF\xFF\xFF\x83\x16\x81R`\xFF\x83` \x1C\x16`@\x83\x01\x91`\x03\x82\x10\x15a\x14\x82Wc\xFF\xFF\xFF\xFF\x91\x83R`\x01`\x01`@\x1B\x03``\x85\x01\x95`(\x1C\x16\x85R`@Q\x93Q\x84RQ\x16` \x83\x01RQ`\x03\x81\x10\x15a\x14\x82W`\x80\x92`\x01`\x01`@\x1B\x03\x91`@\x84\x01RQ\x16``\x82\x01R\xF3[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` \x80T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R\xF3[_6`\x03\x19\x01\x12a\x05\xDDWaJWah\x16V[aJ_ag\x16V[aJt3_R`\t` R`@_ T\x15\x15\x90V[a\x19\\WaJ\x87`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`@_ `\xFF\x81T\x16\x15a\x19IW`\x01\x01T\x804\x10aK^WaJ\xB03a\x8D`V[P`@QaJ\xBD\x81aa\xC7V[4\x81R` \x81\x01_\x81R`@\x82\x01_\x81Rc\xFF\xFF\xFF\xFF\x80`\x01``\x86\x01\x95_\x87R3_R`\n` R`@_ \x90Q\x81U\x01\x93Q\x16\x16c\xFF\xFF\xFF\xFF\x19\x83T\x16\x17\x82UQ`\x03\x81\x10\x15a\x14\x82WaK\x1F\x92a\x18\xB4`\x01`\x01`@\x1B\x03\x92\x84ao#V[`@Q4\x81R\x7F\xBC\x11a~W]e\x8Ct\xE9!\xC8\xDF\"\xF8\xE4\x85f\x07/\xA7\x81E\xA6\xCF\xE1\x84 \xBF\x8D\x0CN` 3\x92\xA2`\x01_\x80Q` a\x9F\\\x839\x81Q\x91RU\0[c\"\xDF\x05\x13`\xE1\x1B_R`\x04R4`$R`D_\xFD[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaK\x8DaaMV[3_R`\x0C` RaK\xAD`\x01`\x01`@\x1B\x03`@_ \x92\x16\x80\x92a\x94\xC6V[P3\x7FK\x9B\xBF.\xBCy\xE9\xFB9\xA6I \x93K?E\x8AHeR\xD3\xDF\x959Z\xA7P\xEC\xE9\xE9p\x93_\x80\xA3\0[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` aK\xF5`\x045`\x08a\x8DKV[\x90T`@Q`\x03\x92\x90\x92\x1B\x1C`\x01`\x01`\xA0\x1B\x03\x16\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW` a\x14\xDE`\x045ac\xE9V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDW`\x045aLHaacV[\x90aLQah\x16V[3_R`\x13` R`@_ T\x81\x10\x15a1BW3_R`\x13` RaLz\x81`@_ af\xE9V[P\x90`\x01`\xFF`\x03\x84\x01T\x16aL\x8F\x81aa\x9CV[\x03a13W3_R`\x14` R`@_ \x81_R` R`@_ _\x90\x80T`\x01`\x01`@\x1B\x03\x86\x16\x92[\x81\x81\x10aO\xB4WP`\x01\x85\x01T\x90`\x01\x81\x01\x80\x82\x11a\t\x9EWaL\xDD\x90\x83ad\x8CV[\x91\x81aN+W[PP3_R`\x1E` R`@_ `\x01\x80`\xA0\x1B\x03\x86T\x16`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x83_R` R\x80`@_ U`\x01\x80`\xA0\x1B\x03\x85T\x16_R`\x1B` R`@_ \x83_R` RaMe`\x02`@_ \x92`\x01\x84\x01aMM\x82\x82TafjV[\x80\x91U\x81\x81\x14_\x14aN\x05WP\x92[\x01\x91\x82TafjV[\x90U\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa/\x98\x81\x84\x93`\x01aM\x89\x94\x01\x81Uan\x93V[\x90U`@Q\x90\x81R\x7F\xA7\xB8\x1E\x01z\xBE\xB5\x0E\xCF,\x12\x1C\xB0\xDBp\x87\xDF\xC4\xB3\xCC\x85\xCD\x8D\x85\x7F\x9A_\x1E\x81\xF6HE` 3\x92\xA3` T`\x01`\x01`\xA0\x1B\x03\x16\x80aM\xCAW\0[\x81T`\x01`\x01`\xA0\x1B\x03\x16\x90\x80;\x15a\x05\xDDW`\x02_\x80\x94a0\xCA`@Q\x97\x88\x96\x87\x95\x86\x94cg\xB2sM`\xE0\x1B\x86R\x01\x903`\x04\x86\x01an\xD1V[aN\x1FaN%\x92aN\x19\x85\x88\x01T\x82adyV[\x92adlV[\x90ad\x8CV[\x92aM\\V[\x91aN=aNB\x92\x82\x98\x96\x97\x94ad\x8CV[adlV[\x93_[\x83T\x81\x10\x15aO\xA7W\x80`\x01`\x01`@\x1B\x03aNc`\x01\x93\x87an\x93V[\x90T\x90`\x03\x1B\x1C\x163_R`\x1E` R`@_ \x90\x83\x80`\xA0\x1B\x03\x88T\x16\x91\x84\x80`\xA0\x1B\x03\x83\x16_R` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` R`@_ T\x91\x82\x8A\x11_\x14aO\x9CWaN\xBB\x83\x80adlV[\x903_R`\x1E` R`@_ \x90\x86\x80`\xA0\x1B\x03\x16_R` R`@_ `\x01`\x01`@\x1B\x03\x83\x16_R` R`@_ U\x83\x80`\xA0\x1B\x03\x88T\x16_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ \x83\x81\x01\x90\x81T\x90\x83\x82\x10\x15aO.W[PPPP\x01aNEV[aO:\x84`\x02\x93adlV[\x80\x93U\x01\x91\x82T\x91\x82\x15\x15\x80aO\x93W[\x15aO\x8DWaN\x1F\x82aOa\x85aOg\x95adyV[\x92afjV[\x81\x81\x11\x15aO~WPP_\x90[U\x89\x80\x80\x80aO$V[aO\x87\x91adlV[\x90aOtV[PaOgV[P\x80\x15\x15aOKV[aN\xBB\x8A\x80\x94adlV[P\x92\x94\x90\x93P\x86\x80aL\xE4V[\x83`\x01`\x01`@\x1B\x03aO\xC7\x83\x86an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x14aO\xDCW`\x01\x01aL\xBAV[\x83b\xD0\r/`\xE1\x1B_R`\x04R`$_\xFD[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW_T`\x01`\x01`@\x1B\x03\x81`\x80\x1C\x16aP#`\x01`\x01`@\x1B\x03\x83`@\x1C\x16\x82aggV[\x90\x15\x15\x80aP\xC6W[aP\x9DWP`\x01`\x01`@\x1B\x03aPD\x81\x83\x16an\xB4V[\x16\x80\x91`\x01`\x01`@\x1B\x03`\x80\x1BB`\x80\x1B\x16\x90w\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x17\x17_U\x7F|\xEEp\x87\xBA\xAF\xDF\xA8\xF9\xD1\xBD9\xC5`x..\xED\xF8a\xE2d\x8B#*\x80P3S|V\x95_\x80\xA2\0[`\x01`\x01`@\x1B\x03\x90c'I(\xD5`\xE0\x1B_R\x16`\x04R`\x01`\x01`@\x1B\x03B\x16`$R`D_\xFD[P`\x01`\x01`@\x1B\x03\x81\x16B\x10aP,V[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `@Qa*\xF8\x81R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaQ\raa!V[_\x90`\x01`\x01`\xA0\x1B\x03\x16\x81[\x81_R`\x13` R`@_ T\x83\x10\x15a\ncW\x81_R`\x13` RaQC\x83`@_ af\xE9V[P`\xFF`\x03\x82\x01T\x16aQU\x81aa\x9CV[aQ\xE4W`\x01\x91a\nUaQ\xD1\x92g\r\xE0\xB6\xB3\xA7d\0\0aQ\xAF\x86\x80`\xA0\x1B\x03\x83T\x16\x92\x83_R`\x18` R`@_ \x93\x89_R`\x19` R`@_ \x90\x89\x80`\xA0\x1B\x03\x16_R` R\x87`@_ \x94T\x91\x01T\x90adyV[\x04\x81T\x90\x81\x81\x11_\x14aQ\xDAW\x86\x91aQ\xC7\x91adlV[\x91[\x01T\x90afjV[\x92[\x01\x91aQ\x1AV[PP\x84_\x91aQ\xC9V[_\x83\x81R`\x14` \x90\x81R`@\x80\x83 \x87\x84R\x90\x91R\x81 \x80T\x92T\x93\x95\x93`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x90[\x84\x84\x10aR$WPPPPP`\x01\x90aQ\xD3V[`\x01aR\xD3\x81\x99a\nU`\x01`\x01`@\x1B\x03aRE\x89\x87\x9D\x9A\x9B\x9C\x9Dan\x93V[\x90T\x90`\x03\x1B\x1C\x16\x86_R`\x1B` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` Rg\r\xE0\xB6\xB3\xA7d\0\0aQ\xAF`@_ \x8B_R`\x1C` R`@_ \x8B_R` R`@_ `\x01`\x01`@\x1B\x03\x85\x16_R` R`@_ \x93\x8C_R`\x1E` R`@_ \x8C_R` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ T\x90TadyV[\x95\x01\x93\x96\x95\x94\x97PaR\x10V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWaR\xF9aa!V[aS\x01aa7V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x81\x16_\x80[\x84_R`\x13` R`@_ T\x82\x10\x15a\ncW\x84_R`\x13` RaS;\x82`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x84\x90\x03aT*W`\xFF`\x03\x82\x01T\x16aS_\x81aa\x9CV[aS\x7FW`\x01\x91a\nU\x83aSv\x93\x01T\x87a\x8A\xB7V[\x91[\x01\x90aS\x12V[P\x90\x84_R`\x14` R`@_ \x81_R` R`@_ _\x81T\x91[\x82\x82\x10aS\xAEWPPP`\x01\x90aSxV[\x91\x93\x94`\x01aT\x1B\x89\x98\x93\x95\x97\x82\x9A_R`\x1E` R`@_ \x84_R` R`@_ `\x01`\x01`@\x1B\x03\x80aS\xE5\x8A\x8Aan\x93V[\x90T\x90`\x03\x1B\x1C\x16\x16_R` Ra\nU`@_ T`\x01`\x01`@\x1B\x03aT\r\x8A\x8Aan\x93V[\x90T\x90`\x03\x1B\x1C\x16\x87a\x8D\x07V[\x94\x01\x91\x96\x97P\x94\x92\x93\x91aS\x9CV[P\x90`\x01\x90aSxV[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWaTMaa!V[`\x01`\x01`\xA0\x1B\x03aT]aa7V[\x16\x80aU\x8CWP`@QaTp\x81aa\xE2V[_\x81R_` \x82\x01R\x90[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x11` R`@\x90 \x90aT\x9B\x90argV[_R` R`@_ \x80T\x90aT\xB0\x82afwV[\x91aT\xBE`@Q\x93\x84abNV[\x80\x83R` \x83\x01\x80\x92_R` _ _\x91[\x83\x83\x10aUCW\x84\x86`@Q\x91\x82\x91` \x83\x01\x90` \x84RQ\x80\x91R`@\x83\x01\x91\x90_[\x81\x81\x10aU\x02WPPP\x03\x90\xF3[\x91\x93P\x91` ```\x01\x92`\x01`\x01`@\x1B\x03`@\x88Q\x80Q\x84RaU-\x86\x82\x01Q\x87\x86\x01\x90aa\x8FV[\x01Q\x16`@\x82\x01R\x01\x94\x01\x91\x01\x91\x84\x93\x92aT\xF4V[`\x02` `\x01\x92`@QaUV\x81aa\xFDV[\x85T\x81R`\x01`\x01`@\x1B\x03\x85\x87\x01TaUu`\xFF\x82\x16\x86\x85\x01an\x87V[`\x08\x1C\x16`@\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90aT\xD0V[`@Q\x90aU\x99\x82aa\xE2V[`\x01\x82R` \x82\x01R\x90aT{V[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWaU\xC1aa!V[aU\xC9aacV[\x90`\x01\x80`\xA0\x1B\x03\x16_R`Q` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`\xE0`@_ \x80T\x90`\x01\x81\x01T\x90`\x02\x81\x01T`\x04`\x03\x83\x01T\x92\x01T\x92`\x01`\x01`@\x1B\x03`@Q\x95\x81\x81\x16\x87R\x81\x81`@\x1C\x16` \x88\x01R`\x80\x1C\x16`@\x86\x01R``\x85\x01R`\x80\x84\x01R`\xA0\x83\x01R`\xC0\x82\x01R\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaV_aa!V[aVgam\x1AV[`\x1F\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\0[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDW` `\x01`\x01`@\x1B\x03_T`\x80\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xDDW``6`\x03\x19\x01\x12a\x05\xDDWaV\xCAaaMV[aV\xD2aacV[\x90aV\xDBaayV[\x90aV\xE4am\x1AV[_T\x90`\x01`\x01`@\x1B\x03`\xC0\x1B\x90`\xC0\x1B\x16\x90`\x01\x80`\xC0\x1B\x03\x16\x17_U`\x01`\x01`@\x1B\x03g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B`\x01T\x92`@\x1B\x16\x92\x16\x90o\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x17\x17`\x01U_\x80\xF3[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWaWWaa!V[aW_ac\xC5V[PaWhac\xC5V[P`\x01\x80`\xA0\x1B\x03\x16_R`\x18` R`\x80`@_ `\x01`\x01`@\x1B\x03`@QaW\x92\x81aa\xC7V[\x82T\x92\x83\x82R`\x01\x81\x01T` \x83\x01\x90\x81R``\x84`\x03`\x02\x85\x01T\x94`@\x87\x01\x95\x86R\x01T\x16\x93\x01\x92\x83R`@Q\x94\x85RQ` \x85\x01RQ`@\x84\x01RQ\x16``\x82\x01R\xF3[4a\x05\xDDW`@6`\x03\x19\x01\x12a\x05\xDDWa\x05\xCAaW\xF5aa!V[aW\xFDah\x16V[aX\x05ag\x16V[`$5\x90ah=V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDW`\x045c\xFF\xFF\xFF\xFF`\xE0\x1B\x81\x16\x80\x91\x03a\x05\xDDW` \x90cye\xDB\x0B`\xE0\x1B\x81\x14\x90\x81\x15aXSW[P`@Q\x90\x15\x15\x81R\xF3[c\x01\xFF\xC9\xA7`\xE0\x1B\x14\x90P\x82aXHV[4a\x05\xDDW_6`\x03\x19\x01\x12a\x05\xDDWaX|ag\x16V[_3_R`\x15` R`@_ \x90_[\x82T\x81\x10\x15a\x05\xCAWaX\x9F\x81\x84agNV[P\x91_T`\x01`\x01`@\x1B\x03\x80aX\xC0\x81`\x03\x88\x01T\x16\x84`\xC0\x1C\x90aggV[\x16\x91\x16\x10aa\x11WaX\xD7a\t>`\x01\x85\x01ag\x95V[\x91aY\x08`\x01\x80`\xA0\x1B\x03\x85T\x16aX\xF3`\x02\x87\x01T\x82a\x8A\xB7V[\x90aY\x02`\x04\x88\x01T\x91ad@V[\x91a\x8A\xF2V[\x93_[3_R`\x13` R\x85`@_ T\x82\x10\x15aa\x02WP3_R`\x13` RaY6\x81`@_ af\xE9V[P\x80T\x83T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x16\x14\x80a`\xEBW[aY\\WP`\x01\x01aY\x0BV[\x93`\x03\x85\x97\x92\x97\x01\x96`\xFF\x88T\x16\x95aYt\x87aa\x9CV[`\x01\x87\x14\x80\x15a`\xCAW3_R`\x14` R`@_ \x83_R` R`@_ `@Q\x80` \x83T\x91\x82\x81R\x01\x92_R` _ \x90_\x91[\x81`\x03\x84\x01\x10a`zW\x93aY\xE8\x92\x84\x92aY\xEE\x96T\x91\x81\x81\x10a``W[\x81\x81\x10a`CW[\x81\x81\x10a`&W[\x10a`\x18WP\x03\x82abNV[\x98aa\x9CV[\x80a`\x0EW[a_1W[`\x01\x80`\xA0\x1B\x03\x85T\x16\x97`\xFF`\x02\x87\x01T\x9AT\x16\x97a'\x10\x90aZ\x1F`\x01\x89\x01ag\x95V[\x99_aZ*\x82aa\x9CV[\x81a_\nWPaZ9\x8Ca\x90\x1BV[\x8B_R`\x18` R`@_ \x9C3_R`\x19` R`@_ \x8D`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x9B_\x9C_[3_R`\x13` R`@_ T\x81\x10\x15aZ\xE4W\x8F3_R`\x13` RaZ\x93\x82`@_ af\xE9V[P\x90`\x01\x80`\xA0\x1B\x03\x82T\x16\x14\x80aZ\xCCW[aZ\xB4W[P`\x01\x01aZiV[`\x01\x91\x9F\x82aZ\xC5\x92\x01T\x90afjV[\x9E\x90aZ\xABV[P`\xFF`\x03\x82\x01T\x16aZ\xDE\x81aa\x9CV[\x15aZ\xA6V[P\x9D\x8A\x9F\x9Ea[h\x98\x9A\x9D\x9F\x8C\x9D\x9Fg\r\xE0\xB6\xB3\xA7d\0\0\x91a[P\x91\x9E\x96\x97\x98\x99\x9A\x9C\x9E\x80a^\xCBW[_\x98`\x01\x83\x01a[ \x82\x82TadlV[\x90U`\x02\x83\x01\x80T\x8A\x81\x81\x11\x15a^\xBCWPP_\x90[U\x80\x82\x11\x15a^\xB3Wa[H\x91adlV[\x90[TadyV[\x04\x90U[a[b\x87\x85\x85\x85\x853a\x99pV[3a\x9A\xAFV[a[|`\x01`\x02\x88\x01T\x93\x01\x92\x83TadlV[\x82U3_R`\x10` R`@_ \x90_R` R`\x01`@_ \x01a[\xAB\x81T\x80\x86\x11_\x14a^\xACW\x80adlV[\x90UT\x15a]5W[Pa[\xBE\x91afjV[\x92`\x01\x80`\xA0\x1B\x03\x82T\x16\x90`\x02`\x01\x80`\xA0\x1B\x03`\x01\x85\x01T`\x08\x1C\x16\x93\x01T\x90`@Q\x91\x82R` \x82\x01R\x7F\xE4\x185\x14\xC7H09S\x8C\xD1\xF9\xCA \xE4\x89\xB3\xC4\x11\xF3\xAF\x12\x11\xCFkZ\xD0\xA0\x0C\xA4\xE2(`@3\x92\xA4\x82T_\x19\x81\x01\x90\x81\x11a\t\x9EWa\\(\x90\x84agNV[Pa\\3\x82\x85agNV[\x91\x90\x91a\x08\x8EW\x80\x82\x03a\\\x7FW[PP\x82T\x80\x15a\x0E\xD4W_\x19\x01a\\Y\x81\x85agNV[a\x08\x8EW`\x04\x81_\x80\x93U\x82`\x01\x82\x01U\x82`\x02\x82\x01U\x82`\x03\x82\x01U\x01U\x83UaX\x8CV[\x80T\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x82U`\x04\x90\x81\x90`\x01\x80\x82\x01\x90\x85\x01\x82\x86\x03a\\\xFDW[PP`\x02\x81\x01T`\x02\x85\x01Ua\\\xF1`\x03\x85\x01`\xFF`\x03\x84\x01`\x01`\x01`@\x1B\x03\x80\x82T\x16\x16`\x01`\x01`@\x1B\x03\x19\x84T\x16\x17\x83UT`@\x1C\x16\x90ag\xF3V[\x01T\x91\x01U\x83\x80a\\BV[\x81a]\x0F`\xFFa].\x94T\x16\x83ag\xDBV[T\x81Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16a\x01\0`\x01`\xA8\x1B\x03\x90\x91\x16\x17\x90UV[\x87\x80a\\\xB1V[\x90P`\x01\x80`\xA0\x1B\x03\x83T\x16_R`\n` R`\x01`@_ \x01c\xFF\xFF\xFF\xFF\x81T\x16\x80\x15a\t\x9EW\x81Tc\xFF\xFF\xFF\xFF\x19\x16_\x19\x91\x82\x01c\xFF\xFF\xFF\xFF\x16\x17\x90\x91U3_\x90\x81R`\x13` R`@\x90 \x80T\x91\x82\x01\x91\x82\x11a\t\x9EWa]\xAF\x91a]\x9C\x91af\xE9V[P\x913_R`\x13` R`@_ af\xE9V[a\x08\x8EW\x81\x81\x03a^>W[PP3_R`\x13` R`@_ \x90\x81T\x80\x15a\x0E\xD4W_\x19\x01\x90a]\xE0\x82\x84af\xE9V[\x92\x90\x92a\x08\x8EWa[\xBE\x93_`\x03\x85\x82\x8B\x97U\x82`\x01\x82\x01U\x82`\x02\x82\x01U\x01UU`\x01\x80`\xA0\x1B\x03\x84T\x16a^\x16\x813a|gV[\x15a^#W[P\x91a[\xB4V[_R`\r` Ra^73`@_ a\x94\xC6V[P\x87a^\x1CV[\x81T\x81T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x81U`\x01\x80\x83\x01T\x90\x82\x01Ua^\x8D\x91`\x03\x90`\xFF\x90\x82\x90`\x02\x80\x82\x01\x90\x86\x01\x82\x87\x03a^\x94W[PP\x01T\x16\x91\x01ag\xDBV[\x85\x80a]\xBBV[\x81a]\x0F\x86a^\xA5\x94T\x16\x83ag\xDBV[\x8B\x80a^\x81V[\x85\x90adlV[PP_\x90a[JV[a^\xC5\x91adlV[\x90a[6V[\x83a^\xD7\x82\x84TadyV[\x04\x85T\x80\x82\x11_\x14a_\x02Wa^\xEC\x91adlV[a^\xFB`\x01\x87\x01\x91\x82TafjV[\x90Ua[\x0FV[PP_a^\xECV[\x90\x91\x92\x93\x95\x97\x80\x9D\x9B\x8Da_,a[h\x98\x9A\x9D\x9F\x84\x9D\x9F\x85_\x91\x8A\x933a\x97PV[a[TV[\x97\x93\x96\x92\x90\x94\x91a_H`\x02\x89\x01T\x88Q\x90ad\x8CV[\x95_[\x88Q\x81\x10\x15a_\xFFW3_\x90\x81R`\x1E` \x90\x81R`@\x80\x83 \x8DT`\x01`\x01`\xA0\x1B\x03\x16\x80\x85R\x92R\x90\x91 `\x01\x92\x91\x90`\x01`\x01`@\x1B\x03\x80a_\x90\x85\x8Fag\xC7V[Q\x16\x16_R` R`@_ T\x8A\x81\x81\x11_\x14a_\xF0WPP_\x90[3_R`\x1E` R`@_ \x90\x84\x80`\xA0\x1B\x03\x16_R` R\x8A`\x01`\x01`@\x1B\x03\x80a_\xDD\x85`@_ \x94ag\xC7V[Q\x16\x16_R` R`@_ U\x01a_KV[a_\xF9\x91adlV[\x90a_\xACV[P\x91\x93\x97\x94\x98\x90\x92\x95PaY\xF9V[P\x86Q\x15\x15aY\xF4V[`\xC0\x1C\x81R` \x01_a2\xBCV[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85`\x80\x1C\x16\x81R\x01\x93\x01aY\xDBV[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85`@\x1C\x16\x81R\x01\x93\x01aY\xD3V[\x92` `\x01\x91`\x01`\x01`@\x1B\x03\x85\x16\x81R\x01\x93\x01aY\xCBV[\x92\x93`\x01`\x80`\x04\x92\x86T`\x01`\x01`@\x1B\x03\x81\x16\x82R`\x01`\x01`@\x1B\x03\x81`@\x1C\x16` \x83\x01R`\x01`\x01`@\x1B\x03\x81\x84\x1C\x16`@\x83\x01R`\xC0\x1C``\x82\x01R\x01\x94\x01\x92\x01\x91\x93\x92\x93aY\xACV[aY\xEE` `@Q\x90a`\xDD\x81\x83abNV[_\x82RP_6\x817\x98aa\x9CV[P\x85a`\xFCa\t>`\x02\x84\x01ag\x95V[\x14aYOV[\x91\x93\x90Pa[\xBE\x92\x94PafjV[\x91Paa\x1C\x90ag\x87V[aX\x8CV[`\x045\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[`$5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[`\x045\x90`\x01`\x01`@\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[`$5\x90`\x01`\x01`@\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[`D5\x90`\x01`\x01`@\x1B\x03\x82\x16\x82\x03a\x05\xDDWV[\x90`\x05\x82\x10\x15a\x14\x82WRV[`\x02\x11\x15a\x14\x82WV[` \x90\x80Qaa\xB4\x81aa\x9CV[\x83R\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x91\x01RV[`\x80\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[``\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[`\xC0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[`\xE0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x08\xA1W`@RV[`\x01`\x01`@\x1B\x03\x81\x11a\x08\xA1W`\x1F\x01`\x1F\x19\x16` \x01\x90V[4a\x05\xDDW` 6`\x03\x19\x01\x12a\x05\xDDWab\xA3aa!V[`\x01\x80`\xA0\x1B\x03\x16_R`\x18` R` `\x02`@_ \x01T`@Q\x90\x81R\xF3[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90_[\x81\x81\x10ab\xE1WPPP\x90V[\x82Q`\x01`\x01`@\x1B\x03\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01ab\xD4V[``\x90`\x03\x19\x01\x12a\x05\xDDW`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x90`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x90`D5\x90V[\x90`\xA0`\x03\x19\x83\x01\x12a\x05\xDDW`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x91`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x91`D5\x91`d5`\x02\x81\x10\x15a\x05\xDDW\x91`\x845`\x01`\x01`@\x1B\x03\x81\x11a\x05\xDDW\x82`#\x82\x01\x12\x15a\x05\xDDW\x80`\x04\x015\x92`\x01`\x01`@\x1B\x03\x84\x11a\x05\xDDW`$\x84`\x05\x1B\x83\x01\x01\x11a\x05\xDDW`$\x01\x91\x90V[`@Q\x90ac\xD2\x82aa\xC7V[_``\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x01RV[_R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` R`\x01`@_ \x01T\x90V[\x15ad\x0EWV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\n`$\x82\x01RiUse native`\xB0\x1B`D\x82\x01R`d\x90\xFD[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x0F` R`@\x90 T\x80adiWPg\r\xE0\xB6\xB3\xA7d\0\0\x90V[\x90V[\x91\x90\x82\x03\x91\x82\x11a\t\x9EWV[\x81\x81\x02\x92\x91\x81\x15\x91\x84\x04\x14\x17\x15a\t\x9EWV[\x81\x15ad\x96W\x04\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[\x92\x91\x90\x92_\x93`\x01\x80`\xA0\x1B\x03\x82\x16_R`Q` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ \x90`@Q\x92ad\xE5\x84ab3V[\x82T`\x01`\x01`@\x1B\x03\x80\x82\x16\x91\x82\x87R\x81\x81`@\x1C\x16` \x88\x01R`\x80\x1C\x16`@\x86\x01R`\x01\x84\x01T``\x86\x01R`\x02\x84\x01T\x94`\x80\x81\x01\x95\x86R`\xC0`\x04`\x03\x87\x01T\x96`\xA0\x84\x01\x97\x88R\x01T\x91\x01R\x15ae\x89W\x90aeF\x91a|gV[\x91\x82\x15ae\x81WQ\x90Q\x90\x81\x81\x11ae]WPPPV[g\r\xE0\xB6\xB3\xA7d\0\0\x93\x94Pae}\x92\x91aew\x91adlV[\x90adyV[\x04\x90V[P_\x93PPPV[P_\x94PPPPV[`@Q\x90ae\x9F\x82aa\xE2V[_` \x83\x82\x81R\x01RV[\x90`@Qae\xB7\x81aa\xE2V[` `\x01\x82\x94\x80T\x84R\x01T\x91\x01RV[\x15ae\xCFWV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01Rn$\xB7;0\xB64\xB2\x100\xB20\xB8:2\xB9`\x89\x1B`D\x82\x01R`d\x90\xFD[\x90\x81` \x91\x03\x12a\x05\xDDWQ\x80\x15\x15\x81\x03a\x05\xDDW\x90V[\x15af%WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1D`$\x82\x01R\x7FAdapter doesn't support token\0\0\0`D\x82\x01R`d\x90\xFD[\x91\x90\x82\x01\x80\x92\x11a\t\x9EWV[`\x01`\x01`@\x1B\x03\x81\x11a\x08\xA1W`\x05\x1B` \x01\x90V[\x92\x91af\x99\x82afwV[\x93af\xA7`@Q\x95\x86abNV[` \x85\x84\x81R\x01\x92`\x05\x1B\x81\x01\x91\x82\x11a\x05\xDDW\x91[\x81\x83\x10af\xC9WPPPV[\x825`\x01`\x01`@\x1B\x03\x81\x16\x81\x03a\x05\xDDW\x81R` \x92\x83\x01\x92\x01af\xBDV[\x80T\x82\x10\x15ag\x02W_R` _ \x90`\x02\x1B\x01\x90_\x90V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[`\x02_\x80Q` a\x9F\\\x839\x81Q\x91RT\x14ag?W`\x02_\x80Q` a\x9F\\\x839\x81Q\x91RUV[c>\xE5\xAE\xB5`\xE0\x1B_R`\x04_\xFD[\x80T\x82\x10\x15ag\x02W_R`\x05` _ \x91\x02\x01\x90_\x90V[\x90`\x01`\x01`@\x1B\x03\x80\x91\x16\x91\x16\x01\x90`\x01`\x01`@\x1B\x03\x82\x11a\t\x9EWV[_\x19\x81\x14a\t\x9EW`\x01\x01\x90V[\x90`@Qag\xA2\x81aa\xE2V[` \x81\x93T`\xFF\x81\x16ag\xB4\x81aa\x9CV[\x83R`\x08\x1C`\x01`\x01`\xA0\x1B\x03\x16\x91\x01RV[\x80Q\x82\x10\x15ag\x02W` \x91`\x05\x1B\x01\x01\x90V[\x90ag\xE5\x81aa\x9CV[`\xFF\x80\x19\x83T\x16\x91\x16\x17\x90UV[\x90ag\xFD\x81aa\x9CV[`\xFF`@\x1B\x82T\x91`@\x1B\x16\x90`\xFF`@\x1B\x19\x16\x17\x90UV[`\xFF_\x80Q` a\x9F<\x839\x81Q\x91RT\x16ah.WV[c\xD9<\x06e`\xE0\x1B_R`\x04_\xFD[`@Q\x91ahJ\x83aa\xE2V[_\x83R_` \x84\x01R` \x91`@Qahc\x84\x82abNV[_\x81R_6\x817\x82\x15a\t\xDAW\x80Qam\x0BW`\x01`\x01`\xA0\x1B\x03\x82\x16_\x90\x81R`\t\x85R`@\x90 T\x15al\xEAW`\x01\x80`\xA0\x1B\x03\x82\x16_R`\n\x84R`\x01`@_ \x01\x94`\xFF\x86T\x86\x1C\x16`\x03\x81\x10\x15a\x14\x82Wal\xCCWah\xC6\x81argV[3_R`\x10\x86R`@_ \x81_R\x86R`@_ \x92\x83T\x93ah\xED`\x01\x82\x01T\x80\x96adlV[\x87\x81\x10al\xB5WPah\xFF\x87\x87a\x9B`V[\x94\x85\x15a\t\xDAW\x87ai\x10\x91afjV[`\x01\x82\x01U_\x98_\x80[3_R`\x13\x8BR`@_ T\x81\x10\x15al\xA5W3_R`\x13\x8BRaiA\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x8B\x81\x16\x91\x16\x14\x80al\x8EW[aieWP`\x01\x01ai\x1AV[\x91P\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9AP`\xFF`\x03\x82\x01T\x16`\x02_\x10\x15a\x14\x82Wai\x8C\x81aa\x9CV[al\x7FW`\x01\x01ai\x9E\x88\x82TafjV[\x90U`\x01[ak\x86WP3_R`\x13\x89R`@_ T3_R`\x13\x8AR`@_ `@Qai\xCB\x81aa\xC7V[`\x01`\x01`\xA0\x1B\x03\x8A\x16\x81R\x8B\x81\x01\x89\x81R`@\x82\x01\x89\x81R\x92``\x83\x01\x90_\x82R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Waj\n\x91`\x01\x82\x01\x81Uaf\xE9V[\x93\x90\x93a\x08\x8EWaj\x9C\x94\x8F`\x03\x94aj\x8B\x93`\x01\x80`\xA0\x1B\x03\x90`\x01\x80`\xA0\x1B\x03\x90Q\x16\x16k\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x88T\x16\x17\x87UQ`\x01\x87\x01U`\x02\x86\x01\x91Q\x90ajg\x82Qaja\x81aa\x9CV[\x84ag\xDBV[\x01Q\x81Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x90UV[Q\x91aj\x96\x83aa\x9CV[\x01ag\xDBV[3_\x90\x81R`\x1D\x8BR`@\x80\x82 `\x01`\x01`\xA0\x1B\x03\x8B\x16\x83R\x8CR\x80\x82 \x92\x82R\x91\x8BR \x80T`\xFF\x19\x16`\x01\x17\x90U\x80Tc\xFF\xFF\xFF\xFF\x90\x81\x16\x94\x90\x85\x14a\t\x9EW`\x01ak%\x93\x8A\x93c\xFF\xFF\xFF\xFF\x83ak1\x99\x01\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90U\x81\x80`\xA0\x1B\x03\x8A\x16_R`\r\x8CRak\x1A3`@_ a\x8E\x16V[P[\x01T\x903a\x9B\xBBV[\x90_\x87\x86\x86\x893a\x8BeV[` \x01Q`@Q\x93\x84R\x93\x83\x01R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91_`@\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16\x903\x90\x7FO\xE2\xFD\xE61\xE9\x86\xEE&(9\x01\xB9\xCC\x8DmJ1\x1Bu\x0F\x9F\xA0\xD6YR\r\xEB\xA2\x99_\x1F\x90``\x90\xA4V[\x90P\x92\x91\x923_R`\x13\x89R`\x01`\xFF`\x03ak\xA5\x84`@_ af\xE9V[P\x01T\x16ak\xB2\x81aa\x9CV[\x14ak\xCAW[P\x86ak1\x93\x92`\x01ak%\x93ak\x1CV[\x97\x94\x91\x96\x92\x95\x93\x90\x973_R`\x14\x86R`@_ \x90_R\x85R`@_ \x95\x86T\x80\x15\x15_\x14alwWak\xFD\x90\x84ad\x8CV[\x97[_[\x88T\x81\x10\x15alcW3_\x90\x81R`\x1E\x89R`@\x80\x82 `\x01`\x01`\xA0\x1B\x03\x8A\x16\x83R\x8AR\x90 `\x01\x91\x90`\x01`\x01`@\x1B\x03\x80al?\x84\x8Ean\x93V[\x90T\x90`\x03\x1B\x1C\x16\x16_R\x89R`@_ al[\x8C\x82TafjV[\x90U\x01al\x01V[P\x95\x98\x93\x97P\x93\x95P\x90\x93\x90\x92\x91\x86ak\xB8V[P_\x97ak\xFFV[c\n\xBC\xE6\xAF`\xE4\x1B_R`\x04_\xFD[P\x86al\x9Fa\t>`\x02\x84\x01ag\x95V[\x14aiXV[P\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99ai\xA3V[\x87\x90c\x12\xE1\xFA7`\xE1\x1B_R`\x04R`$R`D_\xFD[cq\xABj\xD5`\xE1\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16`\x04R`$\x90\xFD[Pc\xBDb\x013`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[c\x10\xDB\x86\xDF`\xE2\x1B_R`\x04_\xFD[3_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 T`\xFF\x16\x15amRWV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u`$R`D_\xFD[3_\x90\x81R\x7F[\xC8A\xA6\xD9%\xA6 \x86i\"\xBA\xDA6\xD1m\xA3\xDC\xC9\xD5\"\x90Q\x9E\xA1\x12n\\\xA27!9` R`@\x90 T`\xFF\x16\x15am\xC1WV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7F\xB1\xFA\xDD1B\xAB*\xD7\xF13~\xA4\xD9q\x12\xBC\xC83\x7F\xC1\x1C\xE5\xB2\x0C\xB0J\xD08\xAD\xF9\x98\x19`$R`D_\xFD[3_\x90\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x90 T`\xFF\x16\x15an\x1DWV[c\xE2Q}?`\xE0\x1B_R3`\x04R_\x80Q` a\x9E\xFC\x839\x81Q\x91R`$R`D_\xFD[_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 T`\xFF\x16\x15anqWPV[c\xE2Q}?`\xE0\x1B_R3`\x04R`$R`D_\xFD[`\x05\x82\x10\x15a\x14\x82WRV[\x91\x90\x91\x80T\x83\x10\x15ag\x02W_R`\x18` _ \x83`\x02\x1C\x01\x92`\x03\x1B\x16\x90V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x81\x14a\t\x9EW`\x01\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x81R\x91\x16` \x82\x01R\x90T`\xA0\x82\x01\x93\x92`\x80\x91`\x01`\x01`@\x1B\x03\x91\x90`\xFF\x81\x16ao\x07\x81aa\x9CV[`@\x86\x01R`\x08\x1C`\x01`\x01`\xA0\x1B\x03\x16``\x85\x01R\x16\x91\x01RV[\x90`\x03\x81\x10\x15a\x14\x82Wd\xFF\0\0\0\0\x82T\x91` \x1B\x16\x90d\xFF\0\0\0\0\x19\x16\x17\x90UV[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x90 T`\xFF\x16ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90_\x80Q` a\x9E\xFC\x839\x81Q\x91R\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x90\x80\xA4`\x01\x90V[P_\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x81\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 T`\xFF\x16ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x90\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F[\xC8A\xA6\xD9%\xA6 \x86i\"\xBA\xDA6\xD1m\xA3\xDC\xC9\xD5\"\x90Q\x9E\xA1\x12n\\\xA27!9` R`@\x90 T`\xFF\x16ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F[\xC8A\xA6\xD9%\xA6 \x86i\"\xBA\xDA6\xD1m\xA3\xDC\xC9\xD5\"\x90Q\x9E\xA1\x12n\\\xA27!9` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90\x7F\xB1\xFA\xDD1B\xAB*\xD7\xF13~\xA4\xD9q\x12\xBC\xC83\x7F\xC1\x1C\xE5\xB2\x0C\xB0J\xD08\xAD\xF9\x98\x19\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x90\x80\xA4`\x01\x90V[_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\xFF\x16araW_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x95\x90\x95\x16\x80\x84R\x94\x90\x91R\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x92\x91\x90_\x80Q` a\x9E|\x839\x81Q\x91R\x90\x80\xA4`\x01\x90V[PP_\x90V[\x80Q\x90ars\x82aa\x9CV[` `\x01\x80`\xA0\x1B\x03\x91\x01Q\x16`@Q\x90` \x82\x01\x92ar\x92\x81aa\x9CV[\x83R`@\x82\x01R`@\x81Rar\xA8``\x82abNV[Q\x90 \x90V[\x90\x93\x92\x91`\x01\x80`\xA0\x1B\x03\x82\x16\x91\x82_R`\n` R`@_ \x90ar\xDE\x84_R`\t` R`@_ T\x15\x15\x90V[\x15av\x08War\xEC\x81a\x8EcV[au\xF5W\x83_R`\x18` R`@_ \x96\x83\x97as\x0F`\x02\x85T\x92\x01T\x82afjV[\x94\x85\x15au\xE8W\x85\x10au\xDEW[\x84as+as0\x92\x8BadyV[ad\x8CV[\x91asWasQas@\x83a\x8E\xE6V[\x94asK\x81\x85a\x8FEV[\x9BadlV[\x82a\x8F~V[\x98asb\x8A\x82afjV[\x99asl\x83a\x8E\xE6V[\x95as|`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\x01`@_ \x01T\x81T\x10au\xC2W[P\x87_R`R` R\x8A`@_ \x99\x8AT`\x01`\x01`@\x1B\x03\x16\x9Aas\xB7\x8Can\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x87\x8A_T`\x01`\x01`@\x1B\x03\x16\x93`@Q\x94as\xEA\x86ab3V[\x85R\x8D` \x86\x01\x99`\x01`\x01`@\x1B\x03\x16\x99\x8A\x81R`@\x87\x01\x91_\x83R``\x88\x01\x93\x84R`\x80\x88\x01\x94\x8D\x86R`\xA0\x89\x01\x96\x87R`\xC0\x89\x01\x97\x88R_R`Q` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x96Q`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x88T\x16\x17\x87UQ`\x01`\x01`@\x1B\x03\x16at\x9C\x90\x87\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x82T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17\x90UV[Q\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x85UQ`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ\x90`\x04\x01U\x83_R`S` R`@_ \x88_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16au\x05\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90Ua'\x10\x8B\x02\x91\x8B\x83\x04a'\x10\x14\x8C\x15\x17\x15a\t\x9EWau\x89\x89\x94au\x83\x7F\x15\x08\xFB\xE2,\x98\x05w\x07@\xC8\xF3\x82ug\x95\0\"r\x9E\0\x96\xE3\x11\xDC\x08y\x90\xC1W\xFF\xFC\x9A\x7F\x91uK%AS\x86\x1C\x1E\x9B\xC9\x18d\x84\xA0\xBBw\x08#\xAC\xFA\0B0D\xBA\x17Y\xA0\x12\x10\xE7\x96ad\x8CV[\x90a\x8F\xC1V[`@\x80Q\x91\x82R` \x82\x01\x92\x90\x92R\x90\x81\x01\x86\x90R``\x90\xA3`@\x80Q\x88\x81R` \x81\x01\x92\x90\x92R\x81\x01\x91\x90\x91R\x80``\x81\x01[\x03\x90\xA3V[`\x01\x01\x80Td\xFF\0\0\0\0\x19\x16d\x01\0\0\0\0\x17\x90U_as\x93V[\x93\x97P\x87\x93as\x1DV[P_\x98PPPPPPPPV[\x83c\xB5\x16&\r`\xE0\x1B_R`\x04R`$_\xFD[\x83c\xBDb\x013`\xE0\x1B_R`\x04R`$_\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x90 T`\xFF\x16\x15ao\xC8W`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R_\x80Q` a\x9E\xDC\x839\x81Q\x91R` R`@\x81 \x80T`\xFF\x19\x16\x90U3\x91\x90_\x80Q` a\x9E\xFC\x839\x81Q\x91R\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x90\x80\xA4`\x01\x90V[_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\xFF\x16\x15araW_\x81\x81R_\x80Q` a\x9F\x1C\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x95\x90\x95\x16\x80\x84R\x94\x90\x91R\x81 \x80T`\xFF\x19\x16\x90U3\x92\x91\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B\x90\x80\xA4`\x01\x90V[=\x15awrW=\x90awY\x82aboV[\x91awg`@Q\x93\x84abNV[\x82R=_` \x84\x01>V[``\x90V[aw\x96`@Qaw\x86\x81aa\xE2V[_\x81R_` \x82\x01R4\x90a\x90jV[V[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15ax\x1DW3_R`\x1A` R`@_ T\x91\x82\x15ax\x0EW_\x80\x80\x85\x81\x943\x83R`\x1A` R\x82`@\x81 UZ\xF1aw\xDAawHV[P\x15aB\xA6W`@Q\x82\x81R\x7F\x10o\x92?\x99<!I\xD4\x9BBU\xFFr:\xCA\xFA\x1F-\x949?V\x1D>\xDA2\xAE4\x8FrA` 3\x92\xA2V[cs8\r\x99`\xE0\x1B_R`\x04_\xFD[c\xD9.#=`\xE0\x1B_R`\x04_\xFD[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\n` \x90\x81R`@\x80\x83 `\t\x90\x92R\x90\x91 T\x94\x96\x94\x92\x93\x92\x90\x91\x90\x15a|GW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\x18` \x90\x81R`@\x80\x83 `\x1B\x83R\x81\x84 `\x01`\x01`@\x1B\x03\x89\x16\x85R\x90\x92R\x90\x91 \x83T`\x02\x92\x83\x01T\x92\x90\x91\x01T\x90\x94\x91\x90ax\xAF\x90a\t~\x83\x88afjV[\x94\x85\x15a|9W\x89\x86ax\xF0\x92\x81as+\x9A\x9B\x9C\x9D\x11a|/W[\x81ax\xDFaN=\x93as+ax\xE8\x94\x87adyV[\x9A\x8B\x96\x85adyV[\x93\x84\x92adlV[ay\x18ay\x10ay\tay\x02\x87a\x8E\xE6V[\x99\x87a\x8FEV[\x93\x86a\x8F~V[\x91\x89\x86a\x95wV[\x95ay'\x87a\t~\x84\x86afjV[\x9A\x8B\x99ay3\x87a\x8E\xE6V[\x97ayC`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\x01`@_ \x01T\x81T\x10a|\x13W[P`\x01`\x01`\xA0\x1B\x03\x87\x16_\x90\x81R`R` R`@\x90 \x80T`\x01`\x01`@\x1B\x03\x16\x9B\x8C\x93\x91\x8A\x91\x8D\x91ay\x8E\x87an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U_T`\x01`\x01`@\x1B\x03\x16\x94`@Q\x95ay\xBF\x87ab3V[\x86R` \x86\x01\x9A`\x01`\x01`@\x1B\x03\x16\x9A\x8B\x81R`@\x87\x01\x91`\x01`\x01`@\x1B\x03\x16\x97\x88\x83R``\x88\x01\x93\x84R`\x80\x88\x01\x94\x85R`\xA0\x88\x01\x95\x86R`\xC0\x88\x01\x96\x87R\x8D`\x01`\xA0\x1B`\x01\x90\x03\x16_R`Q` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x96Q`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x88T\x16\x17\x87UQ`\x01`\x01`@\x1B\x03\x16az\x84\x90\x87\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x82T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17\x90UV[Q\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x85UQ`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ\x90`\x04\x01U\x84_R`S` R`@_ `\x01`\xA0\x1B`\x01\x90\x03\x87\x16_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16az\xF7\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U_R`T` R`@_ `\x01`\xA0\x1B`\x01\x90\x03\x86\x16_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16a{B\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90Ua'\x10\x8B\x02\x8B\x81\x04a'\x10\x14\x8C\x15\x17\x15a\t\x9EW\x7F\x15\x08\xFB\xE2,\x98\x05w\x07@\xC8\xF3\x82ug\x95\0\"r\x9E\0\x96\xE3\x11\xDC\x08y\x90\xC1W\xFF\xFC\x97\x7F\x91uK%AS\x86\x1C\x1E\x9B\xC9\x18d\x84\xA0\xBBw\x08#\xAC\xFA\0B0D\xBA\x17Y\xA0\x12\x10\xE7\x93a\t~a{\xC3\x8A\x95a{\xC9\x95ad\x8CV[\x89a\x8F\xC1V[`@\x80Q\x94\x85R` \x85\x01\x91\x90\x91R\x83\x01R`\x01`\x01`\xA0\x1B\x03\x84\x16\x91``\x90\xA3`@\x80Q\x88\x81R` \x81\x01\x95\x90\x95R\x84\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x16\x91\x80``\x81\x01au\xBDV[`\x01\x01\x80Td\xFF\0\0\0\0\x19\x16d\x01\0\0\0\0\x17\x90U_ayZV[\x90\x91P\x81\x90ax\xCAV[PPPPPPP\x91PP_\x90V[c\xBDb\x013`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[\x90\x91_\x92_[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\x13` R`@\x90 T\x82\x10\x15a|\xE3W\x80_R`\x13` Ra|\xA1\x82`@_ af\xE9V[PT`\x01`\x01`\xA0\x1B\x03\x84\x81\x16\x91\x16\x14a|\xBFW[P`\x01\x01a|mV[`\x01\x91\x95a|\xDC\x91_R`\x13` R\x82a\t\x12\x88`@_ af\xE9V[\x94\x90a|\xB6V[PPP\x90PV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x90\x81\x15a\x19IWaw\x96\x92a}\x08\x91a\x95\xD0V[\x90`@Q\x90a}\x16\x82aa\xE2V[`\x01\x82R` \x82\x01Ra\x90jV[\x91\x90\x81\x10\x15ag\x02W``\x02\x01\x90V[5a\xFF\xFF\x81\x16\x81\x03a\x05\xDDW\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R`\n` \x90\x81R`@\x80\x83 `\t\x90\x92R\x90\x91 T\x95\x98\x97\x96\x94\x95\x90\x93\x91\x92\x91\x90\x15a\x82\xA9W\x88\x15a\x82\x99W`\x01`\x01`\xA0\x1B\x03\x83\x16_\x90\x81R`\x18` \x90\x81R`@\x80\x83 `\x1B\x83R\x81\x84 `\x01`\x01`@\x1B\x03\x87\x16\x85R\x90\x92R\x82 \x86T`\x02\x92\x83\x01T\x92\x90\x91\x01T\x98\x92\x97\x91\x92\x88[\x8D\x80\x82\x10a\x82\tWPP\x88\x15a\x81\xF9W\x88\x83\x11a\x81\xF1W[a}\xE4\x87a\x8E\xE6V[\x99a}\xF3\x81a\t~\x87\x86afjV[\x15a\x81\xE0W\x89\x92\x91\x8E\x91_\x93_\x97_\x93_\x94[\x86\x86\x10a\x81_WPPPPPPP\x92aOaa~_a~Xa~Q\x86aN=a~I\x88a~@a\t~\x9Aas+a~g\x9Eas+\x9EadyV[\x9A\x8B\x99\x85adyV[\x98\x89\x92adlV[\x93\x8Aa\x8FEV[\x94\x89a\x8F~V[\x91\x87\x89a\x95wV[\x98a~q\x84a\x8E\xE6V[\x94a~\x81`@Qa\x1B4\x81aa\xE2V[_R`\x02` R`\x01`@_ \x01T\x81T\x10a\x81CW[P`\x01`\x01`\xA0\x1B\x03\x84\x16_\x90\x81R`R` R`@\x90 \x80T`\x01`\x01`@\x1B\x03\x16\x98\x90a~\xC6\x8Aan\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U_T`\x01`\x01`@\x1B\x03\x16\x90`@Q\x91a~\xF7\x83ab3V[\x82R\x89` \x83\x01\x94`\x01`\x01`@\x1B\x03\x16\x94\x85\x81R\x8D`@\x85\x01\x97`\x01`\x01`@\x1B\x03\x16\x97\x88\x81R``\x86\x01\x91\x82R`\x80\x86\x01\x92\x8D\x84R`\xA0\x87\x01\x94\x8C\x86R`\xC0\x88\x01\x96\x87R`\x01`\xA0\x1B`\x01\x90\x03\x8C\x16_R`Q` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x96Q`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x88T\x16\x17\x87UQ`\x01`\x01`@\x1B\x03\x16a\x7F\xC0\x90\x87\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x82T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17\x90UV[Q\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x85UQ`\x01\x85\x01UQ`\x02\x84\x01UQ`\x03\x83\x01UQ\x90`\x04\x01U\x81_R`S` R`@_ `\x01`\xA0\x1B`\x01\x90\x03\x85\x16_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16a\x803\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U\x82_R`T` R`@_ `\x01`\xA0\x1B`\x01\x90\x03\x85\x16_R` R`@_ \x80T`\x01`\x01`@\x1B\x03\x16a\x80\x7F\x90an\xB4V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90Ua'\x10\x8A\x02\x95\x8A\x87\x04a'\x10\x14\x8B\x15\x17\x15a\t\x9EWa\x80\xDAa\x80\xE0\x91\x7F\x15\x08\xFB\xE2,\x98\x05w\x07@\xC8\xF3\x82ug\x95\0\"r\x9E\0\x96\xE3\x11\xDC\x08y\x90\xC1W\xFF\xFC\x98ad\x8CV[\x85a\x8F\xC1V[`@Q\x90\x8A\x82R` \x82\x01R\x7F\xEB\r\x9B4\xEF\x07\x1B\x87\xDA\x85\x91\xDD\xD8,\xC6\x7F\x90\xC6\x80b\x01\xB5\xC9\xDD\xC9\x1F\x06$g}\xC8\x15`@`\x01\x80`\xA0\x1B\x03\x86\x16\x92\xA4`@\x80Q\x88\x81R` \x81\x01\x95\x90\x95R\x84\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x16\x91\x80``\x81\x01au\xBDV[`\x01\x01\x80Td\xFF\0\0\0\0\x19\x16d\x01\0\0\0\0\x17\x90U_a~\x98V[\x90\x91\x92\x93\x94\x95\x96\x99\x97Pa\x81t\x86\x88\x84a}$V[`@\x01a\x81\x80\x90a}4V[a\xFF\xFF\x16\x99a\x81\x8F\x8B\x86adyV[a'\x10\x90\x04a\x81\x9D\x91afjV[\x97a\x81\xA8\x8B\x85adyV[a'\x10\x90\x04a\x81\xB6\x91afjV[\x99a\x81\xC1\x90\x86adyV[a'\x10\x90\x04a\x81\xCF\x91afjV[\x94`\x01\x01\x93\x92\x91\x90\x8E\x97\x96\x95a~\x06V[P_\x9CPPPPPPPPPPPPV[\x88\x92Pa}\xDBV[P_\x9BPPPPPPPPPPPV[\x81a\x82\x17\x91\x84\x9C\x93\x9Ca}$V[\x805\x91`\x02\x83\x10\x15a\x05\xDDW\x8C\x87\x86`\x01\x95a\x822\x81aa\x9CV[a\x82sW\x93a\xFF\xFFa\x82]`@a\x82Va'\x10\x96a\t~a\x82d\x97a\x82k\x9BafjV[\x93\x01a}4V[\x16\x90adyV[\x04\x90afjV[\x99[\x01a}\xC3V[\x93a\xFF\xFFa\x82]`@a\x82Va'\x10\x96a\t~a\x82d\x97a\x82\x93\x9BafjV[\x99a\x82mV[\x93\x94P\x91Padi\x95\x96Pax,V[c\xBDb\x013`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x84\x16`\x04R`$\x90\xFD[\x15a\x82\xCEWV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x0F`$\x82\x01Rn\x15\x1C\x98[\x9C\xD9\x99\\\x88\x19\x98Z[\x19Y`\x8A\x1B`D\x82\x01R`d\x90\xFD[3_R`\x0B` R`@_ \x90\x81T\x91\x82\x15a\x83\xBEW_T`\x01`\x01`@\x1B\x03`\x01\x81\x83\x16\x93\x01T\x16\x90`\xC0\x1C\x90`\x01`\x01`@\x1B\x03a\x83E\x83\x83aggV[\x16\x83\x10a\x1D\xFEWPPP\x813_R`\n` R`@_ a\x83g\x82\x82TadlV[\x90U3_R`\x0B` R_`\x01`@\x82 \x82\x81U\x01Ua\x83\x90_\x80\x80\x80\x853Z\xF1a\x1D\xC0awHV[`@Q\x90\x81R\x7F\xDA+Q4\x10y\xF3\xDD\x8Egc\xA5\x0F2\x9B\xBC=\xC6\xCAjQ\xB9 \xFE\x99\xFB\xF8\x9AT\xEC\x0E'` 3\x92\xA2V[P_\x91PV[`@Qc\xA9\x05\x9C\xBB`\xE0\x1B` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16`$\x83\x01R`D\x80\x83\x01\x93\x90\x93R\x91\x81Raw\x96\x91a\x84\0`d\x83abNV[a\x96\xB4V[\x80T\x82\x10\x15ag\x02W_R`\x03` _ \x91\x02\x01\x90_\x90V[\x92\x93\x92\x91\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a\x8A\x9BWP`@Qa\x84>\x81aa\xE2V[_\x81R_` \x82\x01R\x93[\x81\x15a\t\xDAWa\x84X\x81aa\x9CV[\x80\x15\x94\x85\x15a\x8A\x86W\x84Qam\x0BW[`\x01`\x01`\xA0\x1B\x03\x84\x16_\x81\x81R`\t` R`@\x90 T\x90\x94\x90\x15a\x8AsW\x84_R`\n` R`\x01`@_ \x01\x90`\xFF\x82T` \x1C\x16`\x03\x81\x10\x15a\x14\x82Wa\x8A`Wa\x84\xB6\x83argV[\x963_R`\x10` R`@_ \x88_R` R`@_ \x97`\x01\x89T\x99\x01\x93a\x84\xE1\x85T\x80\x9BadlV[\x88\x81\x10a\x8AIWPa\x84\xF3\x88\x85a\x9B`V[\x99\x8A\x15a\t\xDAW\x88a\x85\x04\x91afjV[\x85U_\x9A_\x80[3_R`\x13` R`@_ T\x81\x10\x15a\x8A7W3_R`\x13` Ra\x854\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x8D\x14\x80a\x8A W[a\x85UWP`\x01\x01a\x85\x0BV[\x91P\x91\x92\x93\x94\x95\x96\x97\x98\x80\x9A\x9B\x9C\x9DP`\xFF`\x03\x83\x01T\x16a\x85v\x82aa\x9CV[a\x85\x7F\x81aa\x9CV[\x03al\x7FW`\x01\x01a\x85\x92\x8D\x82TafjV[\x90U`\x01[a\x89!WP3_\x90\x81R`\x13` R`@\x90\x81\x90 \x80T\x91Q\x91\x92\x91a\x85\xBC\x81aa\xC7V[\x8C\x81R` \x81\x01\x8E\x81R`@\x82\x01\x8B\x81R\x92``\x83\x01\x90a\x85\xDC\x8Eaa\x9CV[\x8D\x82R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x85\xFC\x91`\x01\x82\x01\x81Uaf\xE9V[\x93\x90\x93a\x08\x8EWQ\x83T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x83U\x90Q`\x01\x83\x01U\x91Q\x80Qa\x86I\x93`\x03\x92\x90\x91aj\x8B\x91`\x02\x86\x01\x91a\x07\xBC\x90a\x07\xB6\x81aa\x9CV[a\x86R\x89aa\x9CV[\x15a\x870W3_R`\x1D` R`@_ \x8A_R` R`@_ \x90_R` R`@_ `\x01`\xFF\x19\x82T\x16\x17\x90U[c\xFF\xFF\xFF\xFF\x81T\x16\x91c\xFF\xFF\xFF\xFF\x83\x14a\t\x9EW\x86a\x86\xDA\x8A\x8D\x93a\x86\xE1\x99\x8E\x83\x97c\xFF\xFF\xFF\xFF\x8F\x9A`\x01\x01\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90U_R`\r` Ra\x86\xD03`@_ a\x8E\x16V[P[T\x903a\x9B\xBBV[\x953a\x8BeV[` `\x01\x80`\xA0\x1B\x03\x91\x01Q\x16\x93`@Q\x92\x83R` \x83\x01Ra\x87\x03\x81aa\x9CV[`@\x82\x01R\x7FO\xE2\xFD\xE61\xE9\x86\xEE&(9\x01\xB9\xCC\x8DmJ1\x1Bu\x0F\x9F\xA0\xD6YR\r\xEB\xA2\x99_\x1F``3\x92\xA4V[\x99\x95\x92\x97\x94\x91\x98\x96\x93\x90\x993_R`\x14` R`@_ \x90_R` R`@_ \x88Q`\x01`\x01`@\x1B\x03\x81\x11a\x08\xA1W`\x01`@\x1B\x81\x11a\x08\xA1W\x81T\x81\x83U\x80\x82\x10a\x88\xC7W[P` \x8A\x01\x91_R` _ \x81`\x02\x1C\x91_[\x83\x81\x10a\x88\x82WP`\x03\x19\x81\x16\x90\x03\x80a\x88*W[PP\x89Q\x91PP\x80\x15a\x88\"Wa\x87\xB8\x90\x87ad\x8CV[\x98[_[\x89Q\x81\x10\x15a\x88\x11W`\x01\x903_R`\x1E` R`@_ \x8A_R` R\x8A`\x01`\x01`@\x1B\x03\x80a\x87\xF2\x84`@_ \x94ag\xC7V[Q\x16\x16_R` R`@_ a\x88\t\x8D\x82TafjV[\x90U\x01a\x87\xBCV[P\x91\x94\x97\x92\x95\x99\x90\x93\x96\x98Pa\x86\x83V[P_\x98a\x87\xBAV[\x92_\x93_[\x81\x81\x10a\x88DWPPP\x01U_\x80\x80\x80a\x87\xA1V[\x90\x91\x94` a\x88x`\x01\x92`\x01`\x01`@\x1B\x03\x89Q\x16\x90\x85`\x03\x1B`\x01`\x01`@\x1B\x03\x80\x91`\x03\x1B\x93\x16\x83\x1B\x92\x1B\x19\x16\x17\x90V[\x96\x01\x92\x91\x01a\x88/V[_\x80[`\x04\x81\x10a\x88\x9AWP\x83\x82\x01U`\x01\x01a\x87\x8CV[\x86Q\x90\x96\x91`\x01\x91` \x91`\x01`\x01`@\x1B\x03`\x06\x8B\x90\x1B\x81\x81\x1B\x19\x90\x92\x16\x92\x16\x90\x1B\x17\x92\x01\x96\x01a\x88\x85V[\x82_R` _ `\x03\x80\x84\x01`\x02\x1C\x82\x01\x92\x01`\x02\x1C\x01\x90`\x18\x83`\x03\x1B\x16\x80a\x89\x06W[P[\x81\x81\x10a\x88\xFBWPa\x87yV[_\x81U`\x01\x01a\x88\xEEV[_\x19\x82\x01\x90\x81T\x90_\x19\x90` \x03`\x03\x1B\x1C\x16\x90U_a\x88\xECV[\x91PP\x93\x90\x91\x92\x933_R`\x13` R`\x01`\xFF`\x03a\x89D\x84`@_ af\xE9V[P\x01T\x16a\x89Q\x81aa\x9CV[\x14a\x89lW[P\x86\x89\x86a\x86\xDA\x83a\x86\xE1\x98\x97\x96\x8B\x96a\x86\xD2V[\x98\x94\x91\x97\x95\x92\x96\x93\x90\x983_R`\x14` R`@_ \x90_R` R`@_ \x96\x87T\x80\x15\x15_\x14a\x8A\x18Wa\x89\xA2\x90\x87ad\x8CV[\x98[_[\x89T\x81\x10\x15a\x8A\x01W`\x01\x903_R`\x1E` R`@_ \x8A_R` R\x8A`\x01`\x01`@\x1B\x03\x80a\x89\xDC\x84`@_ \x94an\x93V[\x90T\x90`\x03\x1B\x1C\x16\x16_R` R`@_ a\x89\xF9\x8D\x82TafjV[\x90U\x01a\x89\xA6V[P\x95\x99\x96\x98P\x93\x96P\x91\x94\x90\x93\x91\x92\x91\x90\x86a\x89WV[P_\x98a\x89\xA4V[P\x85a\x8A1a\t>`\x02\x84\x01ag\x95V[\x14a\x85HV[P\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9Ba\x85\x97V[\x88\x90c\x12\xE1\xFA7`\xE1\x1B_R`\x04R`$R`D_\xFD[\x85cq\xABj\xD5`\xE1\x1B_R`\x04R`$_\xFD[\x84c\xBDb\x013`\xE0\x1B_R`\x04R`$_\xFD[\x84Qa\x84hWc\x1D\xB6\xD0\x8B`\xE1\x1B_R`\x04_\xFD[`@Q\x90a\x8A\xA8\x82aa\xE2V[`\x01\x82R` \x82\x01R\x93a\x84IV[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x18` R`@\x90 `\x01\x81\x01T\x90\x81\x15a\x8A\xEBWadi\x92`\x02as+\x92\x01T\x90adyV[PPP_\x90V[\x91\x81\x15\x80\x15a\x8B\x12W[a\x8B\rWas+\x90adi\x93adyV[PP\x90V[P\x81\x81\x10\x15a\x8A\xFCV[`\x05\x81\x10\x15a\x14\x82W`\x01\x81\x14a\x8B^W`\x02\x81\x14a\x8BWW`\x03\x81\x14a\x8BPW`\x04\x14a\x8BJWa'\x10\x90V[a>\x80\x90V[Pa2\xC8\x90V[Pa.\xE0\x90V[Pa*\xF8\x90V[\x93\x96\x92\x96\x95\x91\x95\x94\x90\x94a\x8Bx\x82aa\x9CV[\x81a\x8C\xE9Wa\x8B\x86\x86a\x90\x1BV[`\x01\x80`\xA0\x1B\x03\x86\x16\x96\x87_R`\x18` R`@_ \x96`\x01\x80`\xA0\x1B\x03\x87\x16\x96\x87_R`\x19` R`@_ \x8A_R` R`@_ _\x99_[\x8A_R`\x13` R`@_ T\x81\x10\x15a\x8C<W\x8A_R`\x13` Ra\x8B\xEA\x81`@_ af\xE9V[P\x80T`\x01`\x01`\xA0\x1B\x03\x16\x8E\x14\x80a\x8C$W[a\x8C\x0CW[P`\x01\x01a\x8B\xC1V[`\x01\x91\x9C\x82a\x8C\x1D\x92\x01T\x90afjV[\x9B\x90a\x8C\x03V[P`\xFF`\x03\x82\x01T\x16a\x8C6\x81aa\x9CV[\x15a\x8B\xFEV[P`\x01\x98\x9BPg\r\xE0\xB6\xB3\xA7d\0\0\x92\x94\x96\x99Pa[H\x8Da\x8Chaw\x96\x9Fa\x8C\x94\x95\x97\x99\x9B\x9EadlV[\x80a\x8C\xABW[\x8B\x84\x01a\x8C|\x83\x82TafjV[\x90U`\x02\x84\x01a\x8C\x8D\x8C\x82TafjV[\x90UafjV[\x04\x90U[a\x8C\xA6\x88\x86\x86\x86\x86\x86a\x99pV[a\x9A\xAFV[\x85a\x8C\xB7\x82\x86TadyV[\x04\x87T\x80\x82\x11_\x14a\x8C\xE1Wa\x8C\xCC\x91adlV[a\x8C\xDA\x8D\x89\x01\x91\x82TafjV[\x90Ua\x8CnV[PP_a\x8C\xCCV[\x91\x94\x84a\x8D\x02\x87`\x01\x86aw\x96\x9C\x86\x83\x9A\x9D\x98\x9Ba\x97PV[a\x8C\x98V[`\x01\x80`\xA0\x1B\x03\x16_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`@_ `\x01\x81\x01T\x90\x81\x15a\x8B\rWadi\x92`\x02as+\x92\x01T\x90adyV[\x80T\x82\x10\x15ag\x02W_R` _ \x01\x90_\x90V[\x80_R`\t` R`@_ T\x15_\x14ao\xC8W`\x08T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x8D\xAFa\x8D\x99\x82`\x01\x85\x94\x01`\x08U`\x08a\x8DKV[\x81\x93\x91T\x90`\x03\x1B\x91\x82\x1B\x91_\x19\x90\x1B\x19\x16\x17\x90V[\x90U`\x08T\x90_R`\t` R`@_ U`\x01\x90V[\x80_R`\x04` R`@_ T\x15_\x14ao\xC8W`\x03T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x8D\xFFa\x8D\x99\x82`\x01\x85\x94\x01`\x03U`\x03a\x8DKV[\x90U`\x03T\x90_R`\x04` R`@_ U`\x01\x90V[_\x82\x81R`\x01\x82\x01` R`@\x90 TaraW\x80T\x90`\x01`@\x1B\x82\x10\x15a\x08\xA1W\x82a\x8ENa\x8D\x99\x84`\x01\x80\x96\x01\x85U\x84a\x8DKV[\x90U\x80T\x92_R\x01` R`@_ U`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R`\x0C` R`@\x90 \x80T\x91\x90\x82\x15a\x8A\xEBW_[\x83\x81\x10a\x8E\x94WPPPP_\x90V[`\x01`\x01`@\x1B\x03a\x8E\xA6\x82\x84a\x8DKV[\x90T\x90`\x03\x1B\x1C\x16\x83_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`\x02`@_ \x01Ta\x8E\xDDW`\x01\x01a\x8E\x85V[PPPP`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x18` R`@\x90 `\x01\x81\x01T\x90\x81\x15a\x8F7W`\x02\x01T\x90g\r\xE0\xB6\xB3\xA7d\0\0\x82\x02\x91\x80\x83\x04g\r\xE0\xB6\xB3\xA7d\0\0\x14\x90\x15\x17\x15a\t\x9EWadi\x91ad\x8CV[PPg\r\xE0\xB6\xB3\xA7d\0\0\x90V[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\n` R`@\x90 \x80T\x82\x81\x10a\x8FuWPa\x8Fp\x82\x82TadlV[\x90U\x90V[_\x91\x93\x92P\x92UV[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x18` R`@\x90 `\x02\x01\x80T\x80\x15\x80\x15a\x8F\xB9W[a\x8A\xEBW\x82\x81\x10a\x8FuWPa\x8Fp\x82\x82TadlV[P\x82\x15a\x8F\xA2V[\x90\x80\x15\x80\x15a\x90\x10W[a\x90\x0CWa\x8F\xD8\x82ad@V[\x90a'\x10\x03\x90a'\x10\x82\x11a\t\x9EWa'\x10\x91a\x8F\xF4\x91adyV[\x04\x90`\x01\x80`\xA0\x1B\x03\x16_R`\x0F` R`@_ UV[PPV[Pa'\x10\x81\x11a\x8F\xCBV[`\x01\x80`\xA0\x1B\x03\x16_R`\x18` R`@_ `\x01`\x01`@\x1B\x03`\x03\x81_T\x16\x92\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90UV[\x80T\x82\x10\x15ag\x02W_R` _ \x90`\x01\x1B\x01\x90_\x90V[\x81\x15a\t\xDAWa\x90y\x81argV[\x80_R`\x02` R`@_ `\xFF\x81T\x16\x15a\x91pW`\x02\x81\x01T\x80\x85\x10a\x91YWP`\x03\x81\x01T\x80\x15\x15\x80a\x91CW[a\x91$WP`\x04\x01a\x90\xBD\x84\x82TafjV[\x90U3_R`\x10` R`@_ \x90_R` R`@_ a\x90\xE0\x83\x82TafjV[\x90U` \x01Q`@Q\x91\x82R`\x01`\x01`\xA0\x1B\x03\x16\x90_` \x82\x01R\x7FuO\xFF\"\x05\xCA\x9F\x1A\x08\xAE\x1F8\xF4\x87\x83\x9B\xA7\xE1\x88\x95\xF0#\x89\x08\xEA\x8B\x88B\xD7BO\xBB`@3\x92\xA3V[`\x04\x85\x92\x01T\x90cK\x98PE`\xE0\x1B_R`\x04R`$R`DR`d_\xFD[P\x80a\x91S\x86`\x04\x85\x01TafjV[\x11a\x90\xAAV[\x84\x90c\x1E+\xE2\x11`\xE0\x1B_R`\x04R`$R`D_\xFD[` \x83\x01Qc\xF6\xF2K\x83`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04R`$\x90\xFD[\x81\x15a\t\xDAWa\x91\xA3\x81argV[\x90\x81_R`\x02` R`@_ `\xFF\x81T\x16\x15a\x93LW`\x02\x81\x01T\x80\x85\x10a\x91YWP`\x03\x81\x01T\x80\x15\x15\x80a\x936W[a\x91$WP`\x04\x01a\x91\xE8\x84\x82TafjV[\x90U3_R`\x10` R`@_ \x82_R` R`@_ a\x92\x0B\x84\x82TafjV[\x90U`\x05\x84\x10\x15a\x14\x82W\x83a\x92hW[` \x90\x81\x01Q`@Q\x93\x84R`\x01`\x01`\xA0\x1B\x03\x16\x93a\x92@\x92P\x90\x83\x01\x90aa\x8FV[\x7FuO\xFF\"\x05\xCA\x9F\x1A\x08\xAE\x1F8\xF4\x87\x83\x9B\xA7\xE1\x88\x95\xF0#\x89\x08\xEA\x8B\x88B\xD7BO\xBB`@3\x92\xA3V[a\x92q\x84a\x9C\xFFV[a\x92z\x84a\x9D\x8CV[\x913_R`\x11` R`@_ \x90_R` Ra\x92\xA4`@_ \x92`\x01`\x01`@\x1B\x03C\x16aggV[\x91`@Qa\x92\xB1\x81aa\xFDV[\x84\x81R` \x81\x01\x91a\x92\xC3\x87\x84an\x87V[`\x01`\x01`@\x1B\x03`@\x83\x01\x95\x16\x85R\x80T`\x01`@\x1B\x81\x10\x15a\x08\xA1Wa\x92\xF0\x91`\x01\x82\x01\x81Ua\x90QV[a\x08\x8EW`\x01\x91Q\x81U\x01\x90Q`\x05\x81\x10\x15a\x14\x82Wa\x92@\x93`\xFFh\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x84T\x92Q`\x08\x1B\x16\x92\x16\x90h\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x17\x17\x90Ua\x92\x1CV[P\x80a\x93F\x86`\x04\x85\x01TafjV[\x11a\x91\xD5V[P` \x01Qc\xF6\xF2K\x83`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04R`$\x90\xFD[_\x81\x81R`\x04` R`@\x90 T\x80\x15araW_\x19\x81\x01\x81\x81\x11a\t\x9EW`\x03T_\x19\x81\x01\x91\x90\x82\x11a\t\x9EW\x81\x81\x03a\x93\xE3W[PPP`\x03T\x80\x15a\x0E\xD4W_\x19\x01a\x93\xC0\x81`\x03a\x8DKV[\x81T\x90_\x19\x90`\x03\x1B\x1B\x19\x16\x90U`\x03U_R`\x04` R_`@\x81 U`\x01\x90V[a\x94\x05a\x93\xF4a\x8D\x99\x93`\x03a\x8DKV[\x90T\x90`\x03\x1B\x1C\x92\x83\x92`\x03a\x8DKV[\x90U_R`\x04` R`@_ U_\x80\x80a\x93\xA6V[_\x81\x81R`\t` R`@\x90 T\x80\x15araW_\x19\x81\x01\x81\x81\x11a\t\x9EW`\x08T_\x19\x81\x01\x91\x90\x82\x11a\t\x9EW\x81\x81\x03a\x94\x8EW[PPP`\x08T\x80\x15a\x0E\xD4W_\x19\x01a\x94k\x81`\x08a\x8DKV[\x81T\x90_\x19\x90`\x03\x1B\x1B\x19\x16\x90U`\x08U_R`\t` R_`@\x81 U`\x01\x90V[a\x94\xB0a\x94\x9Fa\x8D\x99\x93`\x08a\x8DKV[\x90T\x90`\x03\x1B\x1C\x92\x83\x92`\x08a\x8DKV[\x90U_R`\t` R`@_ U_\x80\x80a\x94QV[\x90`\x01\x82\x01\x91\x81_R\x82` R`@_ T\x80\x15\x15_\x14a\x95oW_\x19\x81\x01\x81\x81\x11a\t\x9EW\x82T_\x19\x81\x01\x91\x90\x82\x11a\t\x9EW\x81\x81\x03a\x95:W[PPP\x80T\x80\x15a\x0E\xD4W_\x19\x01\x90a\x95\x1B\x82\x82a\x8DKV[\x81T\x90_\x19\x90`\x03\x1B\x1B\x19\x16\x90UU_R` R_`@\x81 U`\x01\x90V[a\x95Za\x95Ja\x8D\x99\x93\x86a\x8DKV[\x90T\x90`\x03\x1B\x1C\x92\x83\x92\x86a\x8DKV[\x90U_R\x83` R`@_ U_\x80\x80a\x95\x02V[PPPP_\x90V[`\x01\x80`\xA0\x1B\x03\x16_R`\x1B` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R`\x02`@_ \x01\x80T\x80\x15\x80\x15a\x8F\xB9Wa\x8A\xEBW\x82\x81\x10a\x8FuWPa\x8Fp\x82\x82TadlV[\x90\x81` \x91\x03\x12a\x05\xDDWQ\x90V[`\x01`\x01`\xA0\x1B\x03\x90\x81\x16_\x81\x81R`\x06` R`@\x90 T\x90\x91\x16\x90\x81\x15a\x96]WP`@Qc\x11\xF9\xFB\xC9`\xE2\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x92\x90\x92R` \x90\x82\x90`D\x90\x82\x90_\x90Z\xF1\x90\x81\x15a\ruW_\x91a\x96.WP\x90V[\x90P` \x81=` \x11a\x96UW[\x81a\x96I` \x93\x83abNV[\x81\x01\x03\x12a\x05\xDDWQ\x90V[=\x91Pa\x96<V[\x90P`\xFF`\x07T\x16a\x96wW\x81adi\x910\x903\x90a\x97\x0CV[c\xF6\xF2K\x83`\xE0\x1B_R`\x04R`$_\xFD[`\xFF_\x80Q` a\x9F|\x839\x81Q\x91RT`@\x1C\x16\x15a\x96\xA5WV[c\x1A\xFC\xD7\x9F`\xE3\x1B_R`\x04_\xFD[\x90_` \x91\x82\x81Q\x91\x01\x82\x85Z\xF1\x15a\ruW_Q=a\x97\x03WP`\x01`\x01`\xA0\x1B\x03\x81\x16;\x15[a\x96\xE3WPV[cRt\xAF\xE7`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[`\x01\x14\x15a\x96\xDCV[`@Qc#\xB8r\xDD`\xE0\x1B` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x92\x83\x16`$\x82\x01R\x92\x90\x91\x16`D\x83\x01R`d\x80\x83\x01\x93\x90\x93R\x91\x81Raw\x96\x91a\x84\0`\x84\x83abNV[\x95\x94\x90\x93\x92\x91\x81Q\x90\x81\x15a\x99fWa\x97u\x91a\x97l\x91ad\x8CV[\x92\x82Q\x90ad\x8CV[\x90_[\x81Q\x81\x10\x15a\x99fW\x80`\x01`\x01`@\x1B\x03a\x97\x96`\x01\x93\x85ag\xC7V[Q\x16\x82\x80`\xA0\x1B\x03\x88\x16_R`\x1B` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` Rg\r\xE0\xB6\xB3\xA7d\0\0a\x98\xA3`@_ \x85\x80`\xA0\x1B\x03\x8D\x16\x93\x84_R`\x1C` R`@_ \x87\x80`\xA0\x1B\x03\x8D\x16_R` R`@_ `\x01`\x01`@\x1B\x03\x82\x16_R` R`@_ \x94`\x01`\x01`@\x1B\x03_T\x16`\x01`\x01`@\x1B\x03`\x03\x85\x01\x91\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90U_R`\x1E` R`@_ \x87\x80`\xA0\x1B\x03\x8D\x16_R` R`\x01`\x01`@\x1B\x03`@_ \x91\x16_R` R\x89\x89`@_ T\x91a\x99WW[P\x80a\x99\x19W[\x8A\x15a\x98\xCDW\x86\x82\x01a\x98\x7F\x8B\x82TafjV[\x90U`\x02\x82\x01a\x98\x90\x8A\x82TafjV[\x90U[\x89\x8B\x15a\x98\xACWa[H\x91afjV[\x04\x90U\x01a\x97xV[P\x89\x80\x82\x11\x15a\x98\xC5Wa\x98\xBF\x91adlV[\x90a[JV[PP_a\x98\xBFV[\x81\x87\x01\x80T\x8B\x81\x81\x11\x15a\x99\nWPP_\x90[U`\x02\x82\x01\x80T\x8A\x81\x81\x11\x15a\x98\xFBWPP_\x90[Ua\x98\x93V[a\x99\x04\x91adlV[\x90a\x98\xF5V[a\x99\x13\x91adlV[\x90a\x98\xE0V[\x83a\x99%\x82\x84TadyV[\x04\x85T\x80\x82\x11_\x14a\x99OWa\x99:\x91adlV[a\x99H\x88\x87\x01\x91\x82TafjV[\x90Ua\x98kV[PP_a\x99:V[a\x99`\x91adlV[\x89a\x98dV[PPPPPP\x90PV[`\x1FT_\x96\x92\x94\x91\x93\x91\x92\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90\x81\x15a\x9A\xA5W\x80Qa\x99\x99\x81aa\x9CV[a\x99\xA2\x81aa\x9CV[a\x9A\x92WP_\x95[\x15a\x9A2WP`\x1FT`\x01`\x01`\xA0\x1B\x03\x16\x91\x82;\x15a\x9A.W`@Qc\x16\xF6\x0E\xC5`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x94\x85\x16`\x04\x82\x01R\x94\x84\x16`$\x86\x01R\x94\x90\x92\x16`D\x84\x01R`d\x83\x01\x93\x90\x93Ra\xFF\xFF\x16`\x84\x82\x01R\x90\x82\x90\x82\x90`\xA4\x90\x82\x90\x84\x90Z\xF1a\x9A\x19WPPV[a\x9A$\x82\x80\x92abNV[a\x9A+WPV[\x80\xFD[\x86\x80\xFD[\x92\x91\x94\x95PP\x81;\x15a\x05\xDDW`@Qb\xF7K\xBF`\xE7\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x91\x82\x16`\x04\x82\x01R\x92\x81\x16`$\x84\x01R\x90\x93\x16`D\x82\x01R`d\x81\x01\x91\x90\x91R\x90_\x90\x82\x90`\x84\x90\x82\x90\x84\x90Z\xF1a\x9A\x88WPV[_aw\x96\x91abNV[` \x01Q`\x01`\x01`\xA0\x1B\x03\x16\x95a\x99\xAAV[PPPPPPPPV[\x90\x92\x96\x94\x91\x94` T`\x01\x80`\xA0\x1B\x03\x16\x94\x85\x15a\x9BUW\x85;\x15a\x05\xDDWa\x9BB_\x98\x89\x95a\xFF\xFF\x93a\x9B\x15\x9C`@Q\x9D\x8E\x9C\x8D\x9B\x8C\x9Ac\x08\xAE\xC5-`\xE3\x1B\x8CR`\x01\x80`\xA0\x1B\x03\x16`\x04\x8C\x01R`\x01\x80`\xA0\x1B\x03\x16`$\x8B\x01R`D\x8A\x01\x90aa\xA6V[`\x84\x88\x01R\x15\x15`\xA4\x87\x01Ra\x9B*\x81aa\x9CV[`\xC4\x86\x01Ra\x01 `\xE4\x86\x01Ra\x01$\x85\x01\x90ab\xC4V[\x91\x16a\x01\x04\x83\x01R\x03\x92Z\xF1a\x9A\x88WPV[PPPPPPPPPV[`\x01`\x01`\xA0\x1B\x03\x16_\x90\x81R`\x18` R`@\x90 `\x01\x81\x01T\x80\x15\x80\x15a\x9B\xAFW[a\x8B\rWa\x9B\x97`\x02\x91a\x9B\xA0\x94adyV[\x91\x01T\x90ad\x8CV[\x90\x81\x15a\x9B\xA9WV[`\x01\x91PV[P`\x02\x82\x01T\x15a\x9B\x84V[\x92\x90\x91\x81\x15a\x9CtW_\x92_\x94`\x01\x80`\xA0\x1B\x03\x16_R`\x11` R`@_ \x90_R` R`@_ _\x90\x80T\x91[\x82\x81\x10a\x9C\x9AWPPP\x82\x15a\x9CtW\x81\x80\x82\x10a\x9C\x92Wa\x9C\x0C\x91adlV[\x82\x81\x10\x15a\x9C\x8BW[\x80\x83\x11\x15a\x9C\x84Wa\x9C'\x90\x83adlV[\x80\x82\x10\x15a\x9C~WP\x80\x92[\x83\x15a\x9CtWa\xFF\xFF\x93a\nUa\x9CPa\x9Cp\x95as+\x94ad\x8CV[\x91a\x9Ck\x87a\x9Cba'\x10\x95\x84adyV[\x94\x16\x91\x86adlV[adyV[\x16\x90V[PPPPa'\x10\x90V[\x92a\x9C3V[P_a\x9C'V[P\x81a\x9C\x15V[PP_a\x9C\x0CV[a\x9C\xA4\x81\x83a\x90QV[P`\x01\x81\x01TC`\x01`\x01`@\x1B\x03\x82`\x08\x1C\x16\x11a\x9C\xC8W[PP`\x01\x01a\x9B\xEBV[\x97a\nUa\x9C\xF7\x92\x98a\xFF\xFFa\x9C\xEFa\x9C\xE6`\xFF`\x01\x98\x9E\x16a\x8B\x1CV[\x9BT\x80\x93afjV[\x9A\x16\x90a\x9E5V[\x96\x90_a\x9C\xBEV[\x90`\x05\x82\x10\x15\x90\x81a\x14\x82W\x82\x15\x80\x15a\x9D\x7FW[\x82\x81\x15a\x9DoW[\x81\x15a\x9D_W[\x81\x15a\x9DOW[Pa\x9DJWPa\x14\x82W`\xFF\x90c\xAA\xE7X\xA1`\xE0\x1B_R\x16`\x04R`$_\xFD[\x91PPV[\x90Pa\x14\x82W`\x04\x83\x14\x82a\x9D*V[\x90Pa\x14\x82W`\x03\x83\x14\x82a\x9D#V[\x90Pa\x14\x82W`\x02\x83\x14\x82a\x9D\x1CV[P_\x91P`\x01\x83\x14a\x9D\x14V[`\x05\x81\x10\x15a\x14\x82W`\x01\x81\x14a\x9D\xCFW`\x02\x81\x14a\x9D\xC7W`\x03\x81\x14a\x9D\xBFW`\x04\x14a\x9D\xB8W_\x90V[b\xEDN\0\x90V[Pbv\xA7\0\x90V[PbO\x1A\0\x90V[Pb'\x8D\0\x90V[\x90a\x9D\xFBWP\x80Q\x15a\x9D\xECW\x80Q\x90` \x01\xFD[c\xD6\xBD\xA2u`\xE0\x1B_R`\x04_\xFD[\x81Q\x15\x80a\x9E,W[a\x9E\x0CWP\x90V[c\x99\x96\xB3\x15`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[P\x80;\x15a\x9E\x04V[\x81\x81\x02\x91\x90__\x19\x83\x83\t\x84\x80\x82\x10\x91\x03\x81\x81\x14a\x9EsW\x03`\x01\x11\x15a\x9EaWP\x90`\x01\x91\t\x90\x03\x90V[cNH{q\x90R`\x11` R`$`\x1C\xFD[PPPPP\x90V\xFE/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\xE3I\x18\xFF\x1Cp\x84\x97\0h\xB5?\xD7\x1A\xD6\xD8\xB0N\x9F\x15\xD3\x88l\xBF\0dC\xE6\xCD\xC5.\xA6i\x89!\x94\xD2\xF1\xEBMH\xBD\t\xF1f\xBF\xCE\x17T\xA6\x81\xE8\xE1p\x11\xB3\xE1+q\x0C\xCEV\xA8{\x12\xB4.\x8A\x16\x0F`d\xDC\x95\x9Co%\x1E:\xF0u\n\xD2\x13\xDB\xEC\xF5s\xB4q\rg\xD6\xC2\x8E9\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x9Bw\x9B\x17B-\r\xF9\"#\x01\x8B2\xB4\xD1\xFAF\xE0qr=h\x17\xE2Hm\0;\xEC\xC5_\0\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\xA1dsolcC\0\x08\x1A\0\n",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AllModeDisallowsBlueprints()` and selector `0x436e1b7c`.
```solidity
error AllModeDisallowsBlueprints();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AllModeDisallowsBlueprints;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AllModeDisallowsBlueprints>
        for UnderlyingRustTuple<'_> {
            fn from(value: AllModeDisallowsBlueprints) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AllModeDisallowsBlueprints {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AllModeDisallowsBlueprints {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AllModeDisallowsBlueprints()";
            const SELECTOR: [u8; 4] = [67u8, 110u8, 27u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AmountLocked(uint256,uint256)` and selector `0x8ec33211`.
```solidity
error AmountLocked(uint256 locked, uint256 requested);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AmountLocked {
        #[allow(missing_docs)]
        pub locked: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub requested: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AmountLocked> for UnderlyingRustTuple<'_> {
            fn from(value: AmountLocked) -> Self {
                (value.locked, value.requested)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AmountLocked {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    locked: tuple.0,
                    requested: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AmountLocked {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AmountLocked(uint256,uint256)";
            const SELECTOR: [u8; 4] = [142u8, 195u8, 50u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.locked),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requested),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AssetNotEnabled(address)` and selector `0xf6f24b83`.
```solidity
error AssetNotEnabled(address asset);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssetNotEnabled {
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssetNotEnabled> for UnderlyingRustTuple<'_> {
            fn from(value: AssetNotEnabled) -> Self {
                (value.asset,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssetNotEnabled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { asset: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AssetNotEnabled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AssetNotEnabled(address)";
            const SELECTOR: [u8; 4] = [246u8, 242u8, 75u8, 131u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BelowMinimumDeposit(uint256,uint256)` and selector `0x1e2be211`.
```solidity
error BelowMinimumDeposit(uint256 minimum, uint256 provided);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BelowMinimumDeposit {
        #[allow(missing_docs)]
        pub minimum: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub provided: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BelowMinimumDeposit> for UnderlyingRustTuple<'_> {
            fn from(value: BelowMinimumDeposit) -> Self {
                (value.minimum, value.provided)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BelowMinimumDeposit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    minimum: tuple.0,
                    provided: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BelowMinimumDeposit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BelowMinimumDeposit(uint256,uint256)";
            const SELECTOR: [u8; 4] = [30u8, 43u8, 226u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minimum),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.provided),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BlueprintAlreadySelected(uint64)` and selector `0x01a01a5e`.
```solidity
error BlueprintAlreadySelected(uint64 blueprintId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlueprintAlreadySelected {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlueprintAlreadySelected>
        for UnderlyingRustTuple<'_> {
            fn from(value: BlueprintAlreadySelected) -> Self {
                (value.blueprintId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for BlueprintAlreadySelected {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { blueprintId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BlueprintAlreadySelected {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BlueprintAlreadySelected(uint64)";
            const SELECTOR: [u8; 4] = [1u8, 160u8, 26u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `BlueprintNotSelected(uint64)` and selector `0x60c446d6`.
```solidity
error BlueprintNotSelected(uint64 blueprintId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlueprintNotSelected {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlueprintNotSelected> for UnderlyingRustTuple<'_> {
            fn from(value: BlueprintNotSelected) -> Self {
                (value.blueprintId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlueprintNotSelected {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { blueprintId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BlueprintNotSelected {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BlueprintNotSelected(uint64)";
            const SELECTOR: [u8; 4] = [96u8, 196u8, 70u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `CannotRemoveLastBlueprint()` and selector `0xc06b2494`.
```solidity
error CannotRemoveLastBlueprint();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CannotRemoveLastBlueprint;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CannotRemoveLastBlueprint>
        for UnderlyingRustTuple<'_> {
            fn from(value: CannotRemoveLastBlueprint) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for CannotRemoveLastBlueprint {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CannotRemoveLastBlueprint {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CannotRemoveLastBlueprint()";
            const SELECTOR: [u8; 4] = [192u8, 107u8, 36u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DelegationNotFound(address,address)` and selector `0x241e33fc`.
```solidity
error DelegationNotFound(address delegator, address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DelegationNotFound {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DelegationNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: DelegationNotFound) -> Self {
                (value.delegator, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DelegationNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    delegator: tuple.0,
                    operator: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DelegationNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DelegationNotFound(address,address)";
            const SELECTOR: [u8; 4] = [36u8, 30u8, 51u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `DepositCapExceeded(uint256,uint256,uint256)` and selector `0x4b985045`.
```solidity
error DepositCapExceeded(uint256 cap, uint256 current, uint256 adding);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DepositCapExceeded {
        #[allow(missing_docs)]
        pub cap: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub current: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub adding: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DepositCapExceeded> for UnderlyingRustTuple<'_> {
            fn from(value: DepositCapExceeded) -> Self {
                (value.cap, value.current, value.adding)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DepositCapExceeded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    cap: tuple.0,
                    current: tuple.1,
                    adding: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DepositCapExceeded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DepositCapExceeded(uint256,uint256,uint256)";
            const SELECTOR: [u8; 4] = [75u8, 152u8, 80u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.cap),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.current),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.adding),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `FixedModeRequiresBlueprints()` and selector `0x3b6da116`.
```solidity
error FixedModeRequiresBlueprints();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FixedModeRequiresBlueprints;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FixedModeRequiresBlueprints>
        for UnderlyingRustTuple<'_> {
            fn from(value: FixedModeRequiresBlueprints) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for FixedModeRequiresBlueprints {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FixedModeRequiresBlueprints {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FixedModeRequiresBlueprints()";
            const SELECTOR: [u8; 4] = [59u8, 109u8, 161u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientAvailableBalance(uint256,uint256)` and selector `0xadb9e043`.
```solidity
error InsufficientAvailableBalance(uint256 available, uint256 requested);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientAvailableBalance {
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub requested: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientAvailableBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientAvailableBalance) -> Self {
                (value.available, value.requested)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientAvailableBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    available: tuple.0,
                    requested: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientAvailableBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientAvailableBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [173u8, 185u8, 224u8, 67u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.available),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requested),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientDelegation(uint256,uint256)` and selector `0x88c4fe8f`.
```solidity
error InsufficientDelegation(uint256 available, uint256 requested);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientDelegation {
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub requested: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientDelegation> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientDelegation) -> Self {
                (value.available, value.requested)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientDelegation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    available: tuple.0,
                    requested: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientDelegation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientDelegation(uint256,uint256)";
            const SELECTOR: [u8; 4] = [136u8, 196u8, 254u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.available),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requested),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientDeposit(uint256,uint256)` and selector `0x25c3f46e`.
```solidity
error InsufficientDeposit(uint256 available, uint256 requested);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientDeposit {
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub requested: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientDeposit> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientDeposit) -> Self {
                (value.available, value.requested)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientDeposit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    available: tuple.0,
                    requested: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientDeposit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientDeposit(uint256,uint256)";
            const SELECTOR: [u8; 4] = [37u8, 195u8, 244u8, 110u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.available),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.requested),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientStake(uint256,uint256)` and selector `0x45be0a26`.
```solidity
error InsufficientStake(uint256 required, uint256 provided);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientStake {
        #[allow(missing_docs)]
        pub required: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub provided: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientStake> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientStake) -> Self {
                (value.required, value.provided)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientStake {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    required: tuple.0,
                    provided: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientStake {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientStake(uint256,uint256)";
            const SELECTOR: [u8; 4] = [69u8, 190u8, 10u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.provided),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidDelegationIndex(uint256)` and selector `0x164302ba`.
```solidity
error InvalidDelegationIndex(uint256 index);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDelegationIndex {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDelegationIndex> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDelegationIndex) -> Self {
                (value.index,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidDelegationIndex {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { index: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDelegationIndex {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDelegationIndex(uint256)";
            const SELECTOR: [u8; 4] = [22u8, 67u8, 2u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidLockMultiplier(uint8)` and selector `0xaae758a1`.
```solidity
error InvalidLockMultiplier(uint8 value);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidLockMultiplier {
        #[allow(missing_docs)]
        pub value: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<8>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidLockMultiplier> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidLockMultiplier) -> Self {
                (value.value,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidLockMultiplier {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { value: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidLockMultiplier {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidLockMultiplier(uint8)";
            const SELECTOR: [u8; 4] = [170u8, 231u8, 88u8, 161u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LeavingTooEarly(uint64,uint64)` and selector `0x6c136474`.
```solidity
error LeavingTooEarly(uint64 currentRound, uint64 requiredRound);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LeavingTooEarly {
        #[allow(missing_docs)]
        pub currentRound: u64,
        #[allow(missing_docs)]
        pub requiredRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LeavingTooEarly> for UnderlyingRustTuple<'_> {
            fn from(value: LeavingTooEarly) -> Self {
                (value.currentRound, value.requiredRound)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LeavingTooEarly {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    currentRound: tuple.0,
                    requiredRound: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LeavingTooEarly {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LeavingTooEarly(uint64,uint64)";
            const SELECTOR: [u8; 4] = [108u8, 19u8, 100u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentRound),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requiredRound),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `LegacySlashRequiresAllMode(address)` and selector `0xb516260d`.
```solidity
error LegacySlashRequiresAllMode(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LegacySlashRequiresAllMode {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LegacySlashRequiresAllMode>
        for UnderlyingRustTuple<'_> {
            fn from(value: LegacySlashRequiresAllMode) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for LegacySlashRequiresAllMode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LegacySlashRequiresAllMode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LegacySlashRequiresAllMode(address)";
            const SELECTOR: [u8; 4] = [181u8, 22u8, 38u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NoRewardsToClaim()` and selector `0x73380d99`.
```solidity
error NoRewardsToClaim();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoRewardsToClaim;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoRewardsToClaim> for UnderlyingRustTuple<'_> {
            fn from(value: NoRewardsToClaim) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoRewardsToClaim {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoRewardsToClaim {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoRewardsToClaim()";
            const SELECTOR: [u8; 4] = [115u8, 56u8, 13u8, 153u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotFixedMode()` and selector `0x271bfdaa`.
```solidity
error NotFixedMode();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotFixedMode;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotFixedMode> for UnderlyingRustTuple<'_> {
            fn from(value: NotFixedMode) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotFixedMode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotFixedMode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotFixedMode()";
            const SELECTOR: [u8; 4] = [39u8, 27u8, 253u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OperatorAlreadyRegistered(address)` and selector `0x866b0dcf`.
```solidity
error OperatorAlreadyRegistered(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorAlreadyRegistered {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorAlreadyRegistered>
        for UnderlyingRustTuple<'_> {
            fn from(value: OperatorAlreadyRegistered) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OperatorAlreadyRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorAlreadyRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorAlreadyRegistered(address)";
            const SELECTOR: [u8; 4] = [134u8, 107u8, 13u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OperatorNotActive(address)` and selector `0xe356d5aa`.
```solidity
error OperatorNotActive(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorNotActive {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorNotActive) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorNotActive(address)";
            const SELECTOR: [u8; 4] = [227u8, 86u8, 213u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OperatorNotLeaving(address)` and selector `0x9923c539`.
```solidity
error OperatorNotLeaving(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorNotLeaving {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorNotLeaving> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorNotLeaving) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorNotLeaving {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorNotLeaving {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorNotLeaving(address)";
            const SELECTOR: [u8; 4] = [153u8, 35u8, 197u8, 57u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `OperatorNotRegistered(address)` and selector `0xbd620133`.
```solidity
error OperatorNotRegistered(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorNotRegistered {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorNotRegistered> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorNotRegistered) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorNotRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorNotRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorNotRegistered(address)";
            const SELECTOR: [u8; 4] = [189u8, 98u8, 1u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `RoundAdvanceTooSoon(uint64,uint64)` and selector `0x274928d5`.
```solidity
error RoundAdvanceTooSoon(uint64 nextAllowedTime, uint64 currentTime);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RoundAdvanceTooSoon {
        #[allow(missing_docs)]
        pub nextAllowedTime: u64,
        #[allow(missing_docs)]
        pub currentTime: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<RoundAdvanceTooSoon> for UnderlyingRustTuple<'_> {
            fn from(value: RoundAdvanceTooSoon) -> Self {
                (value.nextAllowedTime, value.currentTime)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for RoundAdvanceTooSoon {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    nextAllowedTime: tuple.0,
                    currentTime: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for RoundAdvanceTooSoon {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RoundAdvanceTooSoon(uint64,uint64)";
            const SELECTOR: [u8; 4] = [39u8, 73u8, 40u8, 213u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.nextAllowedTime),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.currentTime),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SafeERC20FailedOperation(address)` and selector `0x5274afe7`.
```solidity
error SafeERC20FailedOperation(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeERC20FailedOperation {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeERC20FailedOperation>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeERC20FailedOperation) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeERC20FailedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeERC20FailedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeERC20FailedOperation(address)";
            const SELECTOR: [u8; 4] = [82u8, 116u8, 175u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SelectionModeMismatch()` and selector `0xabce6af0`.
```solidity
error SelectionModeMismatch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SelectionModeMismatch;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SelectionModeMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: SelectionModeMismatch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SelectionModeMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SelectionModeMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SelectionModeMismatch()";
            const SELECTOR: [u8; 4] = [171u8, 206u8, 106u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TransferFailed()` and selector `0x90b8ec18`.
```solidity
error TransferFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TransferFailed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TransferFailed> for UnderlyingRustTuple<'_> {
            fn from(value: TransferFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TransferFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TransferFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TransferFailed()";
            const SELECTOR: [u8; 4] = [144u8, 184u8, 236u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `AdapterRegistered(address,address)` and selector `0xc47df14ad9309b59073546f93dbe3115ed09c8b206d940f8441ddb07f745b10b`.
```solidity
event AdapterRegistered(address indexed token, address indexed adapter);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AdapterRegistered {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub adapter: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AdapterRegistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "AdapterRegistered(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                196u8, 125u8, 241u8, 74u8, 217u8, 48u8, 155u8, 89u8, 7u8, 53u8, 70u8,
                249u8, 61u8, 190u8, 49u8, 21u8, 237u8, 9u8, 200u8, 178u8, 6u8, 217u8,
                64u8, 248u8, 68u8, 29u8, 219u8, 7u8, 247u8, 69u8, 177u8, 11u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    token: topics.1,
                    adapter: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.token.clone(), self.adapter.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.adapter,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AdapterRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AdapterRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AdapterRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `AdapterRemoved(address)` and selector `0xdf980d21d8c7bb34800e668dbe003299093bac8e693614151d3c57f73f98a93d`.
```solidity
event AdapterRemoved(address indexed token);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AdapterRemoved {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AdapterRemoved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "AdapterRemoved(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                223u8, 152u8, 13u8, 33u8, 216u8, 199u8, 187u8, 52u8, 128u8, 14u8, 102u8,
                141u8, 190u8, 0u8, 50u8, 153u8, 9u8, 59u8, 172u8, 142u8, 105u8, 54u8,
                20u8, 21u8, 29u8, 60u8, 87u8, 247u8, 63u8, 152u8, 169u8, 61u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { token: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AdapterRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AdapterRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AdapterRemoved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `AssetDisabled(address)` and selector `0xfc9274ad64ab0a7d8dedd8c9297fb4e25d7a17eb057457c6bcf2a8f13dc8859c`.
```solidity
event AssetDisabled(address indexed token);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AssetDisabled {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AssetDisabled {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "AssetDisabled(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                252u8, 146u8, 116u8, 173u8, 100u8, 171u8, 10u8, 125u8, 141u8, 237u8,
                216u8, 201u8, 41u8, 127u8, 180u8, 226u8, 93u8, 122u8, 23u8, 235u8, 5u8,
                116u8, 87u8, 198u8, 188u8, 242u8, 168u8, 241u8, 61u8, 200u8, 133u8, 156u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { token: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AssetDisabled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AssetDisabled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AssetDisabled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `AssetEnabled(address,uint256,uint256)` and selector `0x9a4c59c56153245e23dcb8000e301b9a5e35b8e6693c5cdbf3b6a2aa0f8a37ea`.
```solidity
event AssetEnabled(address indexed token, uint256 minOperatorStake, uint256 minDelegation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AssetEnabled {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub minOperatorStake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub minDelegation: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AssetEnabled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "AssetEnabled(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                154u8, 76u8, 89u8, 197u8, 97u8, 83u8, 36u8, 94u8, 35u8, 220u8, 184u8,
                0u8, 14u8, 48u8, 27u8, 154u8, 94u8, 53u8, 184u8, 230u8, 105u8, 60u8,
                92u8, 219u8, 243u8, 182u8, 162u8, 170u8, 15u8, 138u8, 55u8, 234u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    token: topics.1,
                    minOperatorStake: data.0,
                    minDelegation: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minOperatorStake),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minDelegation),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AssetEnabled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AssetEnabled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &AssetEnabled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BlueprintAddedToDelegation(address,uint256,uint64)` and selector `0xa7b81e017abeb50ecf2c121cb0db7087dfc4b3cc85cd8d857f9a5f1e81f64845`.
```solidity
event BlueprintAddedToDelegation(address indexed delegator, uint256 indexed delegationIndex, uint64 blueprintId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlueprintAddedToDelegation {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub delegationIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlueprintAddedToDelegation {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "BlueprintAddedToDelegation(address,uint256,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                167u8, 184u8, 30u8, 1u8, 122u8, 190u8, 181u8, 14u8, 207u8, 44u8, 18u8,
                28u8, 176u8, 219u8, 112u8, 135u8, 223u8, 196u8, 179u8, 204u8, 133u8,
                205u8, 141u8, 133u8, 127u8, 154u8, 95u8, 30u8, 129u8, 246u8, 72u8, 69u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    delegationIndex: topics.2,
                    blueprintId: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.delegationIndex.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.delegationIndex);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlueprintAddedToDelegation {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlueprintAddedToDelegation> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &BlueprintAddedToDelegation,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BlueprintRemovedFromDelegation(address,uint256,uint64)` and selector `0xc38cef0d003bc8a9982db0d994b2ea048946028e9255cc061a56abcbb7d548a1`.
```solidity
event BlueprintRemovedFromDelegation(address indexed delegator, uint256 indexed delegationIndex, uint64 blueprintId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlueprintRemovedFromDelegation {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub delegationIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlueprintRemovedFromDelegation {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            const SIGNATURE: &'static str = "BlueprintRemovedFromDelegation(address,uint256,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                195u8, 140u8, 239u8, 13u8, 0u8, 59u8, 200u8, 169u8, 152u8, 45u8, 176u8,
                217u8, 148u8, 178u8, 234u8, 4u8, 137u8, 70u8, 2u8, 142u8, 146u8, 85u8,
                204u8, 6u8, 26u8, 86u8, 171u8, 203u8, 183u8, 213u8, 72u8, 161u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    delegationIndex: topics.2,
                    blueprintId: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.delegationIndex.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.delegationIndex);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlueprintRemovedFromDelegation {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlueprintRemovedFromDelegation>
        for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &BlueprintRemovedFromDelegation,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Delegated(address,address,address,uint256,uint256,uint8)` and selector `0x4fe2fde631e986ee26283901b9cc8d6d4a311b750f9fa0d659520deba2995f1f`.
```solidity
event Delegated(address indexed delegator, address indexed operator, address indexed token, uint256 amount, uint256 shares, Types.BlueprintSelectionMode selectionMode);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Delegated {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub shares: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub selectionMode: <Types::BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Delegated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                Types::BlueprintSelectionMode,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Delegated(address,address,address,uint256,uint256,uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                79u8, 226u8, 253u8, 230u8, 49u8, 233u8, 134u8, 238u8, 38u8, 40u8, 57u8,
                1u8, 185u8, 204u8, 141u8, 109u8, 74u8, 49u8, 27u8, 117u8, 15u8, 159u8,
                160u8, 214u8, 89u8, 82u8, 13u8, 235u8, 162u8, 153u8, 95u8, 31u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    operator: topics.2,
                    token: topics.3,
                    amount: data.0,
                    shares: data.1,
                    selectionMode: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.shares),
                    <Types::BlueprintSelectionMode as alloy_sol_types::SolType>::tokenize(
                        &self.selectionMode,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.operator.clone(),
                    self.token.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Delegated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Delegated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Delegated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DelegatorUnstakeExecuted(address,address,address,uint256,uint256)` and selector `0xe4183514c7483039538cd1f9ca20e489b3c411f3af1211cf6b5ad0a00ca4e228`.
```solidity
event DelegatorUnstakeExecuted(address indexed delegator, address indexed operator, address indexed token, uint256 shares, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegatorUnstakeExecuted {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub shares: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegatorUnstakeExecuted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegatorUnstakeExecuted(address,address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                228u8, 24u8, 53u8, 20u8, 199u8, 72u8, 48u8, 57u8, 83u8, 140u8, 209u8,
                249u8, 202u8, 32u8, 228u8, 137u8, 179u8, 196u8, 17u8, 243u8, 175u8, 18u8,
                17u8, 207u8, 107u8, 90u8, 208u8, 160u8, 12u8, 164u8, 226u8, 40u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    operator: topics.2,
                    token: topics.3,
                    shares: data.0,
                    amount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.shares),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.operator.clone(),
                    self.token.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegatorUnstakeExecuted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegatorUnstakeExecuted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &DelegatorUnstakeExecuted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `DelegatorUnstakeScheduled(address,address,address,uint256,uint256,uint64)` and selector `0x06325d83435da87657b063c6142a5b91a66a7e811827d082d624287a9953c4ba`.
```solidity
event DelegatorUnstakeScheduled(address indexed delegator, address indexed operator, address indexed token, uint256 shares, uint256 estimatedAmount, uint64 readyRound);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct DelegatorUnstakeScheduled {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub shares: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub estimatedAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub readyRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for DelegatorUnstakeScheduled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "DelegatorUnstakeScheduled(address,address,address,uint256,uint256,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                6u8, 50u8, 93u8, 131u8, 67u8, 93u8, 168u8, 118u8, 87u8, 176u8, 99u8,
                198u8, 20u8, 42u8, 91u8, 145u8, 166u8, 106u8, 126u8, 129u8, 24u8, 39u8,
                208u8, 130u8, 214u8, 36u8, 40u8, 122u8, 153u8, 83u8, 196u8, 186u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    operator: topics.2,
                    token: topics.3,
                    shares: data.0,
                    estimatedAmount: data.1,
                    readyRound: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.shares),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.estimatedAmount),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.readyRound),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.delegator.clone(),
                    self.operator.clone(),
                    self.token.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for DelegatorUnstakeScheduled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&DelegatorUnstakeScheduled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &DelegatorUnstakeScheduled,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Deposited(address,address,uint256,uint8)` and selector `0x754fff2205ca9f1a08ae1f38f487839ba7e18895f0238908ea8b8842d7424fbb`.
```solidity
event Deposited(address indexed delegator, address indexed token, uint256 amount, Types.LockMultiplier lock);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Deposited {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lock: <Types::LockMultiplier as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Deposited {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                Types::LockMultiplier,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Deposited(address,address,uint256,uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                117u8, 79u8, 255u8, 34u8, 5u8, 202u8, 159u8, 26u8, 8u8, 174u8, 31u8,
                56u8, 244u8, 135u8, 131u8, 155u8, 167u8, 225u8, 136u8, 149u8, 240u8,
                35u8, 137u8, 8u8, 234u8, 139u8, 136u8, 66u8, 215u8, 66u8, 79u8, 187u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    token: topics.2,
                    amount: data.0,
                    lock: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <Types::LockMultiplier as alloy_sol_types::SolType>::tokenize(
                        &self.lock,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegator.clone(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Deposited {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Deposited> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Deposited) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorBlueprintAdded(address,uint64)` and selector `0xb6d5e45d77b8967cff525b375be6e07f99ca5af91d88724ac1237aafe295d50e`.
```solidity
event OperatorBlueprintAdded(address indexed operator, uint64 indexed blueprintId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorBlueprintAdded {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorBlueprintAdded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "OperatorBlueprintAdded(address,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                182u8, 213u8, 228u8, 93u8, 119u8, 184u8, 150u8, 124u8, 255u8, 82u8, 91u8,
                55u8, 91u8, 230u8, 224u8, 127u8, 153u8, 202u8, 90u8, 249u8, 29u8, 136u8,
                114u8, 74u8, 193u8, 35u8, 122u8, 175u8, 226u8, 149u8, 213u8, 14u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    blueprintId: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.blueprintId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorBlueprintAdded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorBlueprintAdded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorBlueprintAdded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorBlueprintRemoved(address,uint64)` and selector `0x4b9bbf2ebc79e9fb39a64920934b3f458a486552d3df95395aa750ece9e97093`.
```solidity
event OperatorBlueprintRemoved(address indexed operator, uint64 indexed blueprintId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorBlueprintRemoved {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorBlueprintRemoved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "OperatorBlueprintRemoved(address,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                75u8, 155u8, 191u8, 46u8, 188u8, 121u8, 233u8, 251u8, 57u8, 166u8, 73u8,
                32u8, 147u8, 75u8, 63u8, 69u8, 138u8, 72u8, 101u8, 82u8, 211u8, 223u8,
                149u8, 57u8, 90u8, 167u8, 80u8, 236u8, 233u8, 233u8, 112u8, 147u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    blueprintId: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.blueprintId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorBlueprintRemoved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorBlueprintRemoved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OperatorBlueprintRemoved,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorLeavingScheduled(address,uint64)` and selector `0xfd47ed8e653fba5e6e9fcaa947419ca2334b3972ce196132ec69708574d6d35a`.
```solidity
event OperatorLeavingScheduled(address indexed operator, uint64 readyRound);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorLeavingScheduled {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub readyRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorLeavingScheduled {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorLeavingScheduled(address,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                253u8, 71u8, 237u8, 142u8, 101u8, 63u8, 186u8, 94u8, 110u8, 159u8, 202u8,
                169u8, 71u8, 65u8, 156u8, 162u8, 51u8, 75u8, 57u8, 114u8, 206u8, 25u8,
                97u8, 50u8, 236u8, 105u8, 112u8, 133u8, 116u8, 214u8, 211u8, 90u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    readyRound: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.readyRound),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorLeavingScheduled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorLeavingScheduled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OperatorLeavingScheduled,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorLeft(address)` and selector `0x120599f8830115ed973189f8f4947cc793fcd90a15d47c4d6ad8d1a3f15af734`.
```solidity
event OperatorLeft(address indexed operator);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorLeft {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorLeft {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorLeft(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                18u8, 5u8, 153u8, 248u8, 131u8, 1u8, 21u8, 237u8, 151u8, 49u8, 137u8,
                248u8, 244u8, 148u8, 124u8, 199u8, 147u8, 252u8, 217u8, 10u8, 21u8,
                212u8, 124u8, 77u8, 106u8, 216u8, 209u8, 163u8, 241u8, 90u8, 247u8, 52u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { operator: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorLeft {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorLeft> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorLeft) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorRegistered(address,uint256)` and selector `0xbc11617e575d658c74e921c8df22f8e48566072fa78145a6cfe18420bf8d0c4e`.
```solidity
event OperatorRegistered(address indexed operator, uint256 stake);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorRegistered {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub stake: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorRegistered {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorRegistered(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 17u8, 97u8, 126u8, 87u8, 93u8, 101u8, 140u8, 116u8, 233u8, 33u8,
                200u8, 223u8, 34u8, 248u8, 228u8, 133u8, 102u8, 7u8, 47u8, 167u8, 129u8,
                69u8, 166u8, 207u8, 225u8, 132u8, 32u8, 191u8, 141u8, 12u8, 78u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    stake: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.stake),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorSlashed(address,uint64,uint256,bytes32)` and selector `0x06375226ceedb2039eb5a3c61ffeaaea13e8717d38d59209b7e092f54dbf5276`.
```solidity
event OperatorSlashed(address indexed operator, uint64 indexed serviceId, uint256 amount, bytes32 evidence);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorSlashed {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorSlashed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "OperatorSlashed(address,uint64,uint256,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                6u8, 55u8, 82u8, 38u8, 206u8, 237u8, 178u8, 3u8, 158u8, 181u8, 163u8,
                198u8, 31u8, 254u8, 170u8, 234u8, 19u8, 232u8, 113u8, 125u8, 56u8, 213u8,
                146u8, 9u8, 183u8, 224u8, 146u8, 245u8, 77u8, 191u8, 82u8, 118u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    serviceId: topics.2,
                    amount: data.0,
                    evidence: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.serviceId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorSlashed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorSlashed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorSlashed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorStakeIncreased(address,uint256)` and selector `0x614a3fa8467eb54cb60af3aab440279837c9fcd75c5a2617fe0af9c6e5e60e83`.
```solidity
event OperatorStakeIncreased(address indexed operator, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorStakeIncreased {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorStakeIncreased {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorStakeIncreased(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                97u8, 74u8, 63u8, 168u8, 70u8, 126u8, 181u8, 76u8, 182u8, 10u8, 243u8,
                170u8, 180u8, 64u8, 39u8, 152u8, 55u8, 201u8, 252u8, 215u8, 92u8, 90u8,
                38u8, 23u8, 254u8, 10u8, 249u8, 198u8, 229u8, 230u8, 14u8, 131u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorStakeIncreased {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorStakeIncreased> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorStakeIncreased) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorUnstakeExecuted(address,uint256)` and selector `0xda2b51341079f3dd8e6763a50f329bbc3dc6ca6a51b920fe99fbf89a54ec0e27`.
```solidity
event OperatorUnstakeExecuted(address indexed operator, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorUnstakeExecuted {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorUnstakeExecuted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorUnstakeExecuted(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                218u8, 43u8, 81u8, 52u8, 16u8, 121u8, 243u8, 221u8, 142u8, 103u8, 99u8,
                165u8, 15u8, 50u8, 155u8, 188u8, 61u8, 198u8, 202u8, 106u8, 81u8, 185u8,
                32u8, 254u8, 153u8, 251u8, 248u8, 154u8, 84u8, 236u8, 14u8, 39u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorUnstakeExecuted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorUnstakeExecuted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OperatorUnstakeExecuted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OperatorUnstakeScheduled(address,uint256,uint64)` and selector `0xf7e874d9fd42838b0f06a44c7bbe45417b991e6b000e8ca4c5c1f086084a9cd3`.
```solidity
event OperatorUnstakeScheduled(address indexed operator, uint256 amount, uint64 readyRound);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorUnstakeScheduled {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub readyRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorUnstakeScheduled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorUnstakeScheduled(address,uint256,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                247u8, 232u8, 116u8, 217u8, 253u8, 66u8, 131u8, 139u8, 15u8, 6u8, 164u8,
                76u8, 123u8, 190u8, 69u8, 65u8, 123u8, 153u8, 30u8, 107u8, 0u8, 14u8,
                140u8, 164u8, 197u8, 193u8, 240u8, 134u8, 8u8, 74u8, 156u8, 211u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    amount: data.0,
                    readyRound: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.readyRound),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorUnstakeScheduled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorUnstakeScheduled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OperatorUnstakeScheduled,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RequireAdaptersUpdated(bool)` and selector `0xe2c375ae70efa82f7f1d8e9555f83f2df5c692d66834ebabba9d897fca46f3df`.
```solidity
event RequireAdaptersUpdated(bool required);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RequireAdaptersUpdated {
        #[allow(missing_docs)]
        pub required: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RequireAdaptersUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RequireAdaptersUpdated(bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                226u8, 195u8, 117u8, 174u8, 112u8, 239u8, 168u8, 47u8, 127u8, 29u8,
                142u8, 149u8, 85u8, 248u8, 63u8, 45u8, 245u8, 198u8, 146u8, 214u8, 104u8,
                52u8, 235u8, 171u8, 186u8, 157u8, 137u8, 127u8, 202u8, 70u8, 243u8, 223u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { required: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.required,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RequireAdaptersUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RequireAdaptersUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RequireAdaptersUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RewardClaimed(address,uint256)` and selector `0x106f923f993c2149d49b4255ff723acafa1f2d94393f561d3eda32ae348f7241`.
```solidity
event RewardClaimed(address indexed account, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RewardClaimed {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RewardClaimed {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RewardClaimed(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                16u8, 111u8, 146u8, 63u8, 153u8, 60u8, 33u8, 73u8, 212u8, 155u8, 66u8,
                85u8, 255u8, 114u8, 58u8, 202u8, 250u8, 31u8, 45u8, 148u8, 57u8, 63u8,
                86u8, 29u8, 62u8, 218u8, 50u8, 174u8, 52u8, 143u8, 114u8, 65u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RewardClaimed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RewardClaimed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RewardClaimed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RewardDistributed(address,uint256)` and selector `0xe34918ff1c7084970068b53fd71ad6d8b04e9f15d3886cbf006443e6cdc52ea6`.
```solidity
event RewardDistributed(address indexed operator, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RewardDistributed {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RewardDistributed {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RewardDistributed(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                227u8, 73u8, 24u8, 255u8, 28u8, 112u8, 132u8, 151u8, 0u8, 104u8, 181u8,
                63u8, 215u8, 26u8, 214u8, 216u8, 176u8, 78u8, 159u8, 21u8, 211u8, 136u8,
                108u8, 191u8, 0u8, 100u8, 67u8, 230u8, 205u8, 197u8, 46u8, 166u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RewardDistributed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RewardDistributed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RewardDistributed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RoundAdvanced(uint64)` and selector `0x7cee7087baafdfa8f9d1bd39c560782e2eedf861e2648b232a805033537c5695`.
```solidity
event RoundAdvanced(uint64 indexed round);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoundAdvanced {
        #[allow(missing_docs)]
        pub round: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoundAdvanced {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "RoundAdvanced(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                124u8, 238u8, 112u8, 135u8, 186u8, 175u8, 223u8, 168u8, 249u8, 209u8,
                189u8, 57u8, 197u8, 96u8, 120u8, 46u8, 46u8, 237u8, 248u8, 97u8, 226u8,
                100u8, 139u8, 35u8, 42u8, 128u8, 80u8, 51u8, 83u8, 124u8, 86u8, 149u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { round: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.round.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.round);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoundAdvanced {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoundAdvanced> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoundAdvanced) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SlashRecorded(address,uint64,uint256,uint256,uint256)` and selector `0x1508fbe22c9805770740c8f3827567950022729e0096e311dc087990c157fffc`.
```solidity
event SlashRecorded(address indexed operator, uint64 indexed slashId, uint256 totalSlashed, uint256 exchangeRateBefore, uint256 exchangeRateAfter);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SlashRecorded {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub totalSlashed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub exchangeRateBefore: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub exchangeRateAfter: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SlashRecorded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "SlashRecorded(address,uint64,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                21u8, 8u8, 251u8, 226u8, 44u8, 152u8, 5u8, 119u8, 7u8, 64u8, 200u8,
                243u8, 130u8, 117u8, 103u8, 149u8, 0u8, 34u8, 114u8, 158u8, 0u8, 150u8,
                227u8, 17u8, 220u8, 8u8, 121u8, 144u8, 193u8, 87u8, 255u8, 252u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    slashId: topics.2,
                    totalSlashed: data.0,
                    exchangeRateBefore: data.1,
                    exchangeRateAfter: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalSlashed),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.exchangeRateBefore),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.exchangeRateAfter),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.slashId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.slashId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SlashRecorded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SlashRecorded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SlashRecorded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Slashed(address,uint64,uint256,uint256,uint256)` and selector `0x91754b254153861c1e9bc9186484a0bb770823acfa00423044ba1759a01210e7`.
```solidity
event Slashed(address indexed operator, uint64 indexed serviceId, uint256 operatorSlashed, uint256 delegatorsSlashed, uint256 newExchangeRate);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Slashed {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operatorSlashed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub delegatorsSlashed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub newExchangeRate: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Slashed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "Slashed(address,uint64,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                145u8, 117u8, 75u8, 37u8, 65u8, 83u8, 134u8, 28u8, 30u8, 155u8, 201u8,
                24u8, 100u8, 132u8, 160u8, 187u8, 119u8, 8u8, 35u8, 172u8, 250u8, 0u8,
                66u8, 48u8, 68u8, 186u8, 23u8, 89u8, 160u8, 18u8, 16u8, 231u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    serviceId: topics.2,
                    operatorSlashed: data.0,
                    delegatorsSlashed: data.1,
                    newExchangeRate: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorSlashed),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.delegatorsSlashed),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.newExchangeRate),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.serviceId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Slashed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Slashed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Slashed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SlashedForService(address,uint64,uint64,uint256,uint256)` and selector `0xeb0d9b34ef071b87da8591ddd82cc67f90c6806201b5c9ddc91f0624677dc815`.
```solidity
event SlashedForService(address indexed operator, uint64 indexed serviceId, uint64 indexed blueprintId, uint256 totalSlashed, uint256 commitmentCount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SlashedForService {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub totalSlashed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub commitmentCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SlashedForService {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "SlashedForService(address,uint64,uint64,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                235u8, 13u8, 155u8, 52u8, 239u8, 7u8, 27u8, 135u8, 218u8, 133u8, 145u8,
                221u8, 216u8, 44u8, 198u8, 127u8, 144u8, 198u8, 128u8, 98u8, 1u8, 181u8,
                201u8, 221u8, 201u8, 31u8, 6u8, 36u8, 103u8, 125u8, 200u8, 21u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    serviceId: topics.2,
                    blueprintId: topics.3,
                    totalSlashed: data.0,
                    commitmentCount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalSlashed),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.commitmentCount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.serviceId.clone(),
                    self.blueprintId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SlashedForService {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SlashedForService> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SlashedForService) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `WithdrawScheduled(address,address,uint256,uint64)` and selector `0x91eff7d39d2499d76ac21a1903a95a88f31589cb07b1ffdfb61db9f7cd8a3978`.
```solidity
event WithdrawScheduled(address indexed delegator, address indexed token, uint256 amount, uint64 readyRound);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct WithdrawScheduled {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub readyRound: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for WithdrawScheduled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "WithdrawScheduled(address,address,uint256,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                145u8, 239u8, 247u8, 211u8, 157u8, 36u8, 153u8, 215u8, 106u8, 194u8,
                26u8, 25u8, 3u8, 169u8, 90u8, 136u8, 243u8, 21u8, 137u8, 203u8, 7u8,
                177u8, 255u8, 223u8, 182u8, 29u8, 185u8, 247u8, 205u8, 138u8, 57u8, 120u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    token: topics.2,
                    amount: data.0,
                    readyRound: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.readyRound),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegator.clone(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for WithdrawScheduled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&WithdrawScheduled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &WithdrawScheduled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `Withdrawn(address,address,uint256)` and selector `0xd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb`.
```solidity
event Withdrawn(address indexed delegator, address indexed token, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Withdrawn {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Withdrawn {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Withdrawn(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                209u8, 193u8, 159u8, 188u8, 212u8, 85u8, 26u8, 94u8, 223u8, 182u8, 109u8,
                67u8, 210u8, 227u8, 55u8, 192u8, 72u8, 55u8, 175u8, 218u8, 52u8, 130u8,
                180u8, 43u8, 223u8, 86u8, 154u8, 143u8, 204u8, 218u8, 229u8, 251u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    delegator: topics.1,
                    token: topics.2,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.delegator.clone(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.delegator,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Withdrawn {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Withdrawn> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Withdrawn) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ADMIN_ROLE()` and selector `0x75b238fc`.
```solidity
function ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ADMIN_ROLE()`](ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ADMIN_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ADMIN_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [117u8, 178u8, 56u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `ASSET_MANAGER_ROLE()` and selector `0xa4b32de8`.
```solidity
function ASSET_MANAGER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ASSET_MANAGER_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`ASSET_MANAGER_ROLE()`](ASSET_MANAGER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ASSET_MANAGER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ASSET_MANAGER_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: ASSET_MANAGER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ASSET_MANAGER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ASSET_MANAGER_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: ASSET_MANAGER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for ASSET_MANAGER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ASSET_MANAGER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ASSET_MANAGER_ROLE()";
            const SELECTOR: [u8; 4] = [164u8, 179u8, 45u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ASSET_MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ASSET_MANAGER_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `BPS_DENOMINATOR()` and selector `0xe1a45218`.
```solidity
function BPS_DENOMINATOR() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BPS_DENOMINATORCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`BPS_DENOMINATOR()`](BPS_DENOMINATORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BPS_DENOMINATORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BPS_DENOMINATORCall> for UnderlyingRustTuple<'_> {
                fn from(value: BPS_DENOMINATORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for BPS_DENOMINATORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<BPS_DENOMINATORReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: BPS_DENOMINATORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for BPS_DENOMINATORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for BPS_DENOMINATORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BPS_DENOMINATOR()";
            const SELECTOR: [u8; 4] = [225u8, 164u8, 82u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: BPS_DENOMINATORReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: BPS_DENOMINATORReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: DEFAULT_ADMIN_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `LOCK_ONE_MONTH()` and selector `0x9e870585`.
```solidity
function LOCK_ONE_MONTH() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LOCK_ONE_MONTHCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`LOCK_ONE_MONTH()`](LOCK_ONE_MONTHCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LOCK_ONE_MONTHReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LOCK_ONE_MONTHCall> for UnderlyingRustTuple<'_> {
                fn from(value: LOCK_ONE_MONTHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LOCK_ONE_MONTHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LOCK_ONE_MONTHReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LOCK_ONE_MONTHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LOCK_ONE_MONTHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LOCK_ONE_MONTHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LOCK_ONE_MONTH()";
            const SELECTOR: [u8; 4] = [158u8, 135u8, 5u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: LOCK_ONE_MONTHReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: LOCK_ONE_MONTHReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `LOCK_SIX_MONTHS()` and selector `0xf3c9b311`.
```solidity
function LOCK_SIX_MONTHS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LOCK_SIX_MONTHSCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`LOCK_SIX_MONTHS()`](LOCK_SIX_MONTHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LOCK_SIX_MONTHSReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LOCK_SIX_MONTHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: LOCK_SIX_MONTHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LOCK_SIX_MONTHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LOCK_SIX_MONTHSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LOCK_SIX_MONTHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LOCK_SIX_MONTHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LOCK_SIX_MONTHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LOCK_SIX_MONTHS()";
            const SELECTOR: [u8; 4] = [243u8, 201u8, 179u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: LOCK_SIX_MONTHSReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: LOCK_SIX_MONTHSReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `LOCK_THREE_MONTHS()` and selector `0xd27a6f06`.
```solidity
function LOCK_THREE_MONTHS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LOCK_THREE_MONTHSCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`LOCK_THREE_MONTHS()`](LOCK_THREE_MONTHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LOCK_THREE_MONTHSReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LOCK_THREE_MONTHSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: LOCK_THREE_MONTHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LOCK_THREE_MONTHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LOCK_THREE_MONTHSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LOCK_THREE_MONTHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LOCK_THREE_MONTHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LOCK_THREE_MONTHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LOCK_THREE_MONTHS()";
            const SELECTOR: [u8; 4] = [210u8, 122u8, 111u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: LOCK_THREE_MONTHSReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: LOCK_THREE_MONTHSReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `LOCK_TWO_MONTHS()` and selector `0x7df92ada`.
```solidity
function LOCK_TWO_MONTHS() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LOCK_TWO_MONTHSCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`LOCK_TWO_MONTHS()`](LOCK_TWO_MONTHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LOCK_TWO_MONTHSReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LOCK_TWO_MONTHSCall> for UnderlyingRustTuple<'_> {
                fn from(value: LOCK_TWO_MONTHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for LOCK_TWO_MONTHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<LOCK_TWO_MONTHSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: LOCK_TWO_MONTHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for LOCK_TWO_MONTHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for LOCK_TWO_MONTHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LOCK_TWO_MONTHS()";
            const SELECTOR: [u8; 4] = [125u8, 249u8, 42u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: LOCK_TWO_MONTHSReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: LOCK_TWO_MONTHSReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MULTIPLIER_NONE()` and selector `0x4962f88f`.
```solidity
function MULTIPLIER_NONE() external view returns (uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_NONECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MULTIPLIER_NONE()`](MULTIPLIER_NONECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_NONEReturn {
        #[allow(missing_docs)]
        pub _0: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_NONECall> for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_NONECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for MULTIPLIER_NONECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_NONEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_NONEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_NONEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MULTIPLIER_NONECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u16;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MULTIPLIER_NONE()";
            const SELECTOR: [u8; 4] = [73u8, 98u8, 248u8, 143u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MULTIPLIER_NONEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MULTIPLIER_NONEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MULTIPLIER_ONE_MONTH()` and selector `0x18056dc2`.
```solidity
function MULTIPLIER_ONE_MONTH() external view returns (uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_ONE_MONTHCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MULTIPLIER_ONE_MONTH()`](MULTIPLIER_ONE_MONTHCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_ONE_MONTHReturn {
        #[allow(missing_docs)]
        pub _0: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_ONE_MONTHCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_ONE_MONTHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_ONE_MONTHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_ONE_MONTHReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_ONE_MONTHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_ONE_MONTHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MULTIPLIER_ONE_MONTHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u16;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MULTIPLIER_ONE_MONTH()";
            const SELECTOR: [u8; 4] = [24u8, 5u8, 109u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MULTIPLIER_ONE_MONTHReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MULTIPLIER_ONE_MONTHReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MULTIPLIER_SIX_MONTHS()` and selector `0x453eccea`.
```solidity
function MULTIPLIER_SIX_MONTHS() external view returns (uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_SIX_MONTHSCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MULTIPLIER_SIX_MONTHS()`](MULTIPLIER_SIX_MONTHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_SIX_MONTHSReturn {
        #[allow(missing_docs)]
        pub _0: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_SIX_MONTHSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_SIX_MONTHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_SIX_MONTHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_SIX_MONTHSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_SIX_MONTHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_SIX_MONTHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MULTIPLIER_SIX_MONTHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u16;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MULTIPLIER_SIX_MONTHS()";
            const SELECTOR: [u8; 4] = [69u8, 62u8, 204u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MULTIPLIER_SIX_MONTHSReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MULTIPLIER_SIX_MONTHSReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MULTIPLIER_THREE_MONTHS()` and selector `0xa7fa6f98`.
```solidity
function MULTIPLIER_THREE_MONTHS() external view returns (uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_THREE_MONTHSCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MULTIPLIER_THREE_MONTHS()`](MULTIPLIER_THREE_MONTHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_THREE_MONTHSReturn {
        #[allow(missing_docs)]
        pub _0: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_THREE_MONTHSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_THREE_MONTHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_THREE_MONTHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_THREE_MONTHSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_THREE_MONTHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_THREE_MONTHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MULTIPLIER_THREE_MONTHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u16;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MULTIPLIER_THREE_MONTHS()";
            const SELECTOR: [u8; 4] = [167u8, 250u8, 111u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MULTIPLIER_THREE_MONTHSReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MULTIPLIER_THREE_MONTHSReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `MULTIPLIER_TWO_MONTHS()` and selector `0x54de2320`.
```solidity
function MULTIPLIER_TWO_MONTHS() external view returns (uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_TWO_MONTHSCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`MULTIPLIER_TWO_MONTHS()`](MULTIPLIER_TWO_MONTHSCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MULTIPLIER_TWO_MONTHSReturn {
        #[allow(missing_docs)]
        pub _0: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_TWO_MONTHSCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_TWO_MONTHSCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_TWO_MONTHSCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<MULTIPLIER_TWO_MONTHSReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: MULTIPLIER_TWO_MONTHSReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for MULTIPLIER_TWO_MONTHSReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for MULTIPLIER_TWO_MONTHSCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u16;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MULTIPLIER_TWO_MONTHS()";
            const SELECTOR: [u8; 4] = [84u8, 222u8, 35u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: MULTIPLIER_TWO_MONTHSReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: MULTIPLIER_TWO_MONTHSReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `PRECISION()` and selector `0xaaf5eb68`.
```solidity
function PRECISION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PRECISIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`PRECISION()`](PRECISIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PRECISIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PRECISIONCall> for UnderlyingRustTuple<'_> {
                fn from(value: PRECISIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PRECISIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PRECISIONReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PRECISIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PRECISIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PRECISIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PRECISION()";
            const SELECTOR: [u8; 4] = [170u8, 245u8, 235u8, 104u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: PRECISIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: PRECISIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `SLASHER_ROLE()` and selector `0x5095af64`.
```solidity
function SLASHER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SLASHER_ROLECall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`SLASHER_ROLE()`](SLASHER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SLASHER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SLASHER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: SLASHER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SLASHER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SLASHER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SLASHER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SLASHER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SLASHER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SLASHER_ROLE()";
            const SELECTOR: [u8; 4] = [80u8, 149u8, 175u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: SLASHER_ROLEReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: SLASHER_ROLEReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::String;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: UPGRADE_INTERFACE_VERSIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addBlueprint(uint64)` and selector `0xc7353025`.
```solidity
function addBlueprint(uint64 blueprintId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addBlueprintCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    ///Container type for the return parameters of the [`addBlueprint(uint64)`](addBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addBlueprintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addBlueprintCall> for UnderlyingRustTuple<'_> {
                fn from(value: addBlueprintCall) -> Self {
                    (value.blueprintId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blueprintId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addBlueprintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addBlueprintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addBlueprintReturn {
            fn _tokenize(
                &self,
            ) -> <addBlueprintCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addBlueprintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addBlueprintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addBlueprint(uint64)";
            const SELECTOR: [u8; 4] = [199u8, 53u8, 48u8, 37u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addBlueprintReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addBlueprintToDelegation(uint256,uint64)` and selector `0x23cc2700`.
```solidity
function addBlueprintToDelegation(uint256 delegationIndex, uint64 blueprintId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addBlueprintToDelegationCall {
        #[allow(missing_docs)]
        pub delegationIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    ///Container type for the return parameters of the [`addBlueprintToDelegation(uint256,uint64)`](addBlueprintToDelegationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addBlueprintToDelegationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addBlueprintToDelegationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addBlueprintToDelegationCall) -> Self {
                    (value.delegationIndex, value.blueprintId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addBlueprintToDelegationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegationIndex: tuple.0,
                        blueprintId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addBlueprintToDelegationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addBlueprintToDelegationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addBlueprintToDelegationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addBlueprintToDelegationReturn {
            fn _tokenize(
                &self,
            ) -> <addBlueprintToDelegationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addBlueprintToDelegationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addBlueprintToDelegationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addBlueprintToDelegation(uint256,uint64)";
            const SELECTOR: [u8; 4] = [35u8, 204u8, 39u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.delegationIndex),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addBlueprintToDelegationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `addSlasher(address)` and selector `0x68a9f19c`.
```solidity
function addSlasher(address slasher) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addSlasherCall {
        #[allow(missing_docs)]
        pub slasher: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`addSlasher(address)`](addSlasherCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addSlasherReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addSlasherCall> for UnderlyingRustTuple<'_> {
                fn from(value: addSlasherCall) -> Self {
                    (value.slasher,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addSlasherCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slasher: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addSlasherReturn> for UnderlyingRustTuple<'_> {
                fn from(value: addSlasherReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for addSlasherReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl addSlasherReturn {
            fn _tokenize(
                &self,
            ) -> <addSlasherCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addSlasherCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addSlasherReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addSlasher(address)";
            const SELECTOR: [u8; 4] = [104u8, 169u8, 241u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.slasher,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                addSlasherReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `advanceRound()` and selector `0x1ba9998b`.
```solidity
function advanceRound() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct advanceRoundCall;
    ///Container type for the return parameters of the [`advanceRound()`](advanceRoundCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct advanceRoundReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<advanceRoundCall> for UnderlyingRustTuple<'_> {
                fn from(value: advanceRoundCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for advanceRoundCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<advanceRoundReturn> for UnderlyingRustTuple<'_> {
                fn from(value: advanceRoundReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for advanceRoundReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl advanceRoundReturn {
            fn _tokenize(
                &self,
            ) -> <advanceRoundCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for advanceRoundCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = advanceRoundReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "advanceRound()";
            const SELECTOR: [u8; 4] = [27u8, 169u8, 153u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                advanceRoundReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `blueprintPoolTotals(address,uint64)` and selector `0x5fdc8f2d`.
```solidity
function blueprintPoolTotals(address operator, uint64 blueprintId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blueprintPoolTotalsCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`blueprintPoolTotals(address,uint64)`](blueprintPoolTotalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blueprintPoolTotalsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blueprintPoolTotalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: blueprintPoolTotalsCall) -> Self {
                    (value.operator, value.blueprintId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blueprintPoolTotalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        blueprintId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blueprintPoolTotalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: blueprintPoolTotalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blueprintPoolTotalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blueprintPoolTotalsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blueprintPoolTotals(address,uint64)";
            const SELECTOR: [u8; 4] = [95u8, 220u8, 143u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: blueprintPoolTotalsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: blueprintPoolTotalsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `blueprintSlashCount(uint64,address)` and selector `0x4e9c929a`.
```solidity
function blueprintSlashCount(uint64, address) external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blueprintSlashCountCall {
        #[allow(missing_docs)]
        pub _0: u64,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`blueprintSlashCount(uint64,address)`](blueprintSlashCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blueprintSlashCountReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blueprintSlashCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: blueprintSlashCountCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blueprintSlashCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blueprintSlashCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: blueprintSlashCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blueprintSlashCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blueprintSlashCountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blueprintSlashCount(uint64,address)";
            const SELECTOR: [u8; 4] = [78u8, 156u8, 146u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: blueprintSlashCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: blueprintSlashCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimDelegatorRewards()` and selector `0x44d1480b`.
```solidity
function claimDelegatorRewards() external returns (uint256 totalRewards);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimDelegatorRewardsCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`claimDelegatorRewards()`](claimDelegatorRewardsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimDelegatorRewardsReturn {
        #[allow(missing_docs)]
        pub totalRewards: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimDelegatorRewardsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimDelegatorRewardsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimDelegatorRewardsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimDelegatorRewardsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimDelegatorRewardsReturn) -> Self {
                    (value.totalRewards,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimDelegatorRewardsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { totalRewards: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimDelegatorRewardsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimDelegatorRewards()";
            const SELECTOR: [u8; 4] = [68u8, 209u8, 72u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: claimDelegatorRewardsReturn = r.into();
                        r.totalRewards
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: claimDelegatorRewardsReturn = r.into();
                        r.totalRewards
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimOperatorRewards()` and selector `0x4c4ede2d`.
```solidity
function claimOperatorRewards() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimOperatorRewardsCall;
    ///Container type for the return parameters of the [`claimOperatorRewards()`](claimOperatorRewardsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimOperatorRewardsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimOperatorRewardsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimOperatorRewardsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimOperatorRewardsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimOperatorRewardsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimOperatorRewardsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimOperatorRewardsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl claimOperatorRewardsReturn {
            fn _tokenize(
                &self,
            ) -> <claimOperatorRewardsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimOperatorRewardsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimOperatorRewardsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimOperatorRewards()";
            const SELECTOR: [u8; 4] = [76u8, 78u8, 222u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimOperatorRewardsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimOperatorRewardsTo(address)` and selector `0x7d6941c6`.
```solidity
function claimOperatorRewardsTo(address recipient) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimOperatorRewardsToCall {
        #[allow(missing_docs)]
        pub recipient: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`claimOperatorRewardsTo(address)`](claimOperatorRewardsToCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimOperatorRewardsToReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimOperatorRewardsToCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimOperatorRewardsToCall) -> Self {
                    (value.recipient,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimOperatorRewardsToCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { recipient: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimOperatorRewardsToReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimOperatorRewardsToReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimOperatorRewardsToReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl claimOperatorRewardsToReturn {
            fn _tokenize(
                &self,
            ) -> <claimOperatorRewardsToCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimOperatorRewardsToCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimOperatorRewardsToReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimOperatorRewardsTo(address)";
            const SELECTOR: [u8; 4] = [125u8, 105u8, 65u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recipient,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimOperatorRewardsToReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `completeLeaving()` and selector `0xd1736ba7`.
```solidity
function completeLeaving() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeLeavingCall;
    ///Container type for the return parameters of the [`completeLeaving()`](completeLeavingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct completeLeavingReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeLeavingCall> for UnderlyingRustTuple<'_> {
                fn from(value: completeLeavingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for completeLeavingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<completeLeavingReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: completeLeavingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for completeLeavingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl completeLeavingReturn {
            fn _tokenize(
                &self,
            ) -> <completeLeavingCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for completeLeavingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = completeLeavingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "completeLeaving()";
            const SELECTOR: [u8; 4] = [209u8, 115u8, 107u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                completeLeavingReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `currentRound()` and selector `0x8a19c8bc`.
```solidity
function currentRound() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentRoundCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`currentRound()`](currentRoundCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct currentRoundReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentRoundCall> for UnderlyingRustTuple<'_> {
                fn from(value: currentRoundCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentRoundCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<currentRoundReturn> for UnderlyingRustTuple<'_> {
                fn from(value: currentRoundReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for currentRoundReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for currentRoundCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "currentRound()";
            const SELECTOR: [u8; 4] = [138u8, 25u8, 200u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: currentRoundReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: currentRoundReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `delegate(address,uint256)` and selector `0x026e402b`.
```solidity
function delegate(address operator, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`delegate(address,uint256)`](delegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegateCall) -> Self {
                    (value.operator, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl delegateReturn {
            fn _tokenize(
                &self,
            ) -> <delegateCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegate(address,uint256)";
            const SELECTOR: [u8; 4] = [2u8, 110u8, 64u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                delegateReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `delegateWithOptions(address,address,uint256,uint8,uint64[])` and selector `0xfd7d3dbc`.
```solidity
function delegateWithOptions(address operator, address token, uint256 amount, Types.BlueprintSelectionMode selectionMode, uint64[] memory blueprintIds) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateWithOptionsCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub selectionMode: <Types::BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub blueprintIds: alloy::sol_types::private::Vec<u64>,
    }
    ///Container type for the return parameters of the [`delegateWithOptions(address,address,uint256,uint8,uint64[])`](delegateWithOptionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegateWithOptionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                Types::BlueprintSelectionMode,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                <Types::BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Vec<u64>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateWithOptionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: delegateWithOptionsCall) -> Self {
                    (
                        value.operator,
                        value.token,
                        value.amount,
                        value.selectionMode,
                        value.blueprintIds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for delegateWithOptionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        token: tuple.1,
                        amount: tuple.2,
                        selectionMode: tuple.3,
                        blueprintIds: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegateWithOptionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: delegateWithOptionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for delegateWithOptionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl delegateWithOptionsReturn {
            fn _tokenize(
                &self,
            ) -> <delegateWithOptionsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegateWithOptionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                Types::BlueprintSelectionMode,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegateWithOptionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegateWithOptions(address,address,uint256,uint8,uint64[])";
            const SELECTOR: [u8; 4] = [253u8, 125u8, 61u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <Types::BlueprintSelectionMode as alloy_sol_types::SolType>::tokenize(
                        &self.selectionMode,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<64>,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintIds),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                delegateWithOptionsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `delegationBondLessDelay()` and selector `0xba05bbf5`.
```solidity
function delegationBondLessDelay() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegationBondLessDelayCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`delegationBondLessDelay()`](delegationBondLessDelayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct delegationBondLessDelayReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegationBondLessDelayCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: delegationBondLessDelayCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for delegationBondLessDelayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegationBondLessDelayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: delegationBondLessDelayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for delegationBondLessDelayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegationBondLessDelayCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegationBondLessDelay()";
            const SELECTOR: [u8; 4] = [186u8, 5u8, 187u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: delegationBondLessDelayReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: delegationBondLessDelayReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `deposit()` and selector `0xd0e30db0`.
```solidity
function deposit() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositCall;
    ///Container type for the return parameters of the [`deposit()`](depositCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositCall> for UnderlyingRustTuple<'_> {
                fn from(value: depositCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositReturn> for UnderlyingRustTuple<'_> {
                fn from(value: depositReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl depositReturn {
            fn _tokenize(
                &self,
            ) -> <depositCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deposit()";
            const SELECTOR: [u8; 4] = [208u8, 227u8, 13u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                depositReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `depositAndDelegate(address)` and selector `0x461cc23b`.
```solidity
function depositAndDelegate(address operator) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndDelegateCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`depositAndDelegate(address)`](depositAndDelegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndDelegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndDelegateCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndDelegateCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndDelegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndDelegateReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndDelegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndDelegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl depositAndDelegateReturn {
            fn _tokenize(
                &self,
            ) -> <depositAndDelegateCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositAndDelegateCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositAndDelegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositAndDelegate(address)";
            const SELECTOR: [u8; 4] = [70u8, 28u8, 194u8, 59u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                depositAndDelegateReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `depositAndDelegateWithOptions(address,address,uint256,uint8,uint64[])` and selector `0xfbec4861`.
```solidity
function depositAndDelegateWithOptions(address operator, address token, uint256 amount, Types.BlueprintSelectionMode selectionMode, uint64[] memory blueprintIds) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndDelegateWithOptionsCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub selectionMode: <Types::BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub blueprintIds: alloy::sol_types::private::Vec<u64>,
    }
    ///Container type for the return parameters of the [`depositAndDelegateWithOptions(address,address,uint256,uint8,uint64[])`](depositAndDelegateWithOptionsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositAndDelegateWithOptionsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                Types::BlueprintSelectionMode,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                <Types::BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::Vec<u64>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndDelegateWithOptionsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndDelegateWithOptionsCall) -> Self {
                    (
                        value.operator,
                        value.token,
                        value.amount,
                        value.selectionMode,
                        value.blueprintIds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndDelegateWithOptionsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        token: tuple.1,
                        amount: tuple.2,
                        selectionMode: tuple.3,
                        blueprintIds: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositAndDelegateWithOptionsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositAndDelegateWithOptionsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositAndDelegateWithOptionsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl depositAndDelegateWithOptionsReturn {
            fn _tokenize(
                &self,
            ) -> <depositAndDelegateWithOptionsCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositAndDelegateWithOptionsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                Types::BlueprintSelectionMode,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositAndDelegateWithOptionsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositAndDelegateWithOptions(address,address,uint256,uint8,uint64[])";
            const SELECTOR: [u8; 4] = [251u8, 236u8, 72u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <Types::BlueprintSelectionMode as alloy_sol_types::SolType>::tokenize(
                        &self.selectionMode,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<64>,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintIds),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                depositAndDelegateWithOptionsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `depositERC20(address,uint256)` and selector `0x97feb926`.
```solidity
function depositERC20(address token, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositERC20Call {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`depositERC20(address,uint256)`](depositERC20Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositERC20Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositERC20Call> for UnderlyingRustTuple<'_> {
                fn from(value: depositERC20Call) -> Self {
                    (value.token, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositERC20Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositERC20Return> for UnderlyingRustTuple<'_> {
                fn from(value: depositERC20Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositERC20Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl depositERC20Return {
            fn _tokenize(
                &self,
            ) -> <depositERC20Call as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositERC20Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositERC20Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositERC20(address,uint256)";
            const SELECTOR: [u8; 4] = [151u8, 254u8, 185u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                depositERC20Return::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `depositERC20WithLock(address,uint256,uint8)` and selector `0xcb15038b`.
```solidity
function depositERC20WithLock(address token, uint256 amount, Types.LockMultiplier lockMultiplier) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositERC20WithLockCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub lockMultiplier: <Types::LockMultiplier as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`depositERC20WithLock(address,uint256,uint8)`](depositERC20WithLockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositERC20WithLockReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                Types::LockMultiplier,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                <Types::LockMultiplier as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositERC20WithLockCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositERC20WithLockCall) -> Self {
                    (value.token, value.amount, value.lockMultiplier)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositERC20WithLockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                        lockMultiplier: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositERC20WithLockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositERC20WithLockReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositERC20WithLockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl depositERC20WithLockReturn {
            fn _tokenize(
                &self,
            ) -> <depositERC20WithLockCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositERC20WithLockCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                Types::LockMultiplier,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositERC20WithLockReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositERC20WithLock(address,uint256,uint8)";
            const SELECTOR: [u8; 4] = [203u8, 21u8, 3u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <Types::LockMultiplier as alloy_sol_types::SolType>::tokenize(
                        &self.lockMultiplier,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                depositERC20WithLockReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `depositWithLock(uint8)` and selector `0xf38c7c4e`.
```solidity
function depositWithLock(Types.LockMultiplier lockMultiplier) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositWithLockCall {
        #[allow(missing_docs)]
        pub lockMultiplier: <Types::LockMultiplier as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`depositWithLock(uint8)`](depositWithLockCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct depositWithLockReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Types::LockMultiplier,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::LockMultiplier as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositWithLockCall> for UnderlyingRustTuple<'_> {
                fn from(value: depositWithLockCall) -> Self {
                    (value.lockMultiplier,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for depositWithLockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { lockMultiplier: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<depositWithLockReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: depositWithLockReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for depositWithLockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl depositWithLockReturn {
            fn _tokenize(
                &self,
            ) -> <depositWithLockCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for depositWithLockCall {
            type Parameters<'a> = (Types::LockMultiplier,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = depositWithLockReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "depositWithLock(uint8)";
            const SELECTOR: [u8; 4] = [243u8, 140u8, 124u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Types::LockMultiplier as alloy_sol_types::SolType>::tokenize(
                        &self.lockMultiplier,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                depositWithLockReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `disableAsset(address)` and selector `0x70807528`.
```solidity
function disableAsset(address token) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableAssetCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`disableAsset(address)`](disableAssetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disableAssetReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableAssetCall> for UnderlyingRustTuple<'_> {
                fn from(value: disableAssetCall) -> Self {
                    (value.token,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for disableAssetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { token: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disableAssetReturn> for UnderlyingRustTuple<'_> {
                fn from(value: disableAssetReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for disableAssetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl disableAssetReturn {
            fn _tokenize(
                &self,
            ) -> <disableAssetCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for disableAssetCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = disableAssetReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "disableAsset(address)";
            const SELECTOR: [u8; 4] = [112u8, 128u8, 117u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                disableAssetReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `enableAsset(address,uint256,uint256,uint256,uint16)` and selector `0x354ebef9`.
```solidity
function enableAsset(address token, uint256 _minOperatorStake, uint256 _minDelegation, uint256 _depositCap, uint16 _rewardMultiplierBps) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableAssetCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _minOperatorStake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _minDelegation: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _depositCap: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _rewardMultiplierBps: u16,
    }
    ///Container type for the return parameters of the [`enableAsset(address,uint256,uint256,uint256,uint16)`](enableAssetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableAssetReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u16,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableAssetCall> for UnderlyingRustTuple<'_> {
                fn from(value: enableAssetCall) -> Self {
                    (
                        value.token,
                        value._minOperatorStake,
                        value._minDelegation,
                        value._depositCap,
                        value._rewardMultiplierBps,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enableAssetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        _minOperatorStake: tuple.1,
                        _minDelegation: tuple.2,
                        _depositCap: tuple.3,
                        _rewardMultiplierBps: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableAssetReturn> for UnderlyingRustTuple<'_> {
                fn from(value: enableAssetReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for enableAssetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl enableAssetReturn {
            fn _tokenize(
                &self,
            ) -> <enableAssetCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enableAssetCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = enableAssetReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enableAsset(address,uint256,uint256,uint256,uint16)";
            const SELECTOR: [u8; 4] = [53u8, 78u8, 190u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._minOperatorStake),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._minDelegation),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._depositCap),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self._rewardMultiplierBps),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                enableAssetReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `enableAssetWithAdapter(address,address,uint256,uint256,uint256,uint16)` and selector `0xf0b52bb4`.
```solidity
function enableAssetWithAdapter(address token, address adapter, uint256 _minOperatorStake, uint256 _minDelegation, uint256 _depositCap, uint16 _rewardMultiplierBps) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableAssetWithAdapterCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub adapter: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _minOperatorStake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _minDelegation: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _depositCap: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _rewardMultiplierBps: u16,
    }
    ///Container type for the return parameters of the [`enableAssetWithAdapter(address,address,uint256,uint256,uint256,uint16)`](enableAssetWithAdapterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct enableAssetWithAdapterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u16,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableAssetWithAdapterCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: enableAssetWithAdapterCall) -> Self {
                    (
                        value.token,
                        value.adapter,
                        value._minOperatorStake,
                        value._minDelegation,
                        value._depositCap,
                        value._rewardMultiplierBps,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for enableAssetWithAdapterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        adapter: tuple.1,
                        _minOperatorStake: tuple.2,
                        _minDelegation: tuple.3,
                        _depositCap: tuple.4,
                        _rewardMultiplierBps: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<enableAssetWithAdapterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: enableAssetWithAdapterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for enableAssetWithAdapterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl enableAssetWithAdapterReturn {
            fn _tokenize(
                &self,
            ) -> <enableAssetWithAdapterCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for enableAssetWithAdapterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = enableAssetWithAdapterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "enableAssetWithAdapter(address,address,uint256,uint256,uint256,uint16)";
            const SELECTOR: [u8; 4] = [240u8, 181u8, 43u8, 180u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.adapter,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._minOperatorStake),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._minDelegation),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self._depositCap),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self._rewardMultiplierBps),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                enableAssetWithAdapterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `executeDelegatorUnstake()` and selector `0x007910d0`.
```solidity
function executeDelegatorUnstake() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeDelegatorUnstakeCall;
    ///Container type for the return parameters of the [`executeDelegatorUnstake()`](executeDelegatorUnstakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeDelegatorUnstakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeDelegatorUnstakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeDelegatorUnstakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeDelegatorUnstakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeDelegatorUnstakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeDelegatorUnstakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeDelegatorUnstakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl executeDelegatorUnstakeReturn {
            fn _tokenize(
                &self,
            ) -> <executeDelegatorUnstakeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for executeDelegatorUnstakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = executeDelegatorUnstakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "executeDelegatorUnstake()";
            const SELECTOR: [u8; 4] = [0u8, 121u8, 16u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                executeDelegatorUnstakeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `executeOperatorUnstake()` and selector `0xb0dfce06`.
```solidity
function executeOperatorUnstake() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeOperatorUnstakeCall;
    ///Container type for the return parameters of the [`executeOperatorUnstake()`](executeOperatorUnstakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeOperatorUnstakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeOperatorUnstakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeOperatorUnstakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeOperatorUnstakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeOperatorUnstakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeOperatorUnstakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeOperatorUnstakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl executeOperatorUnstakeReturn {
            fn _tokenize(
                &self,
            ) -> <executeOperatorUnstakeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for executeOperatorUnstakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = executeOperatorUnstakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "executeOperatorUnstake()";
            const SELECTOR: [u8; 4] = [176u8, 223u8, 206u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                executeOperatorUnstakeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `executeWithdraw()` and selector `0xf8fd9795`.
```solidity
function executeWithdraw() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeWithdrawCall;
    ///Container type for the return parameters of the [`executeWithdraw()`](executeWithdrawCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeWithdrawReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeWithdrawCall> for UnderlyingRustTuple<'_> {
                fn from(value: executeWithdrawCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for executeWithdrawCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeWithdrawReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeWithdrawReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeWithdrawReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl executeWithdrawReturn {
            fn _tokenize(
                &self,
            ) -> <executeWithdrawCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for executeWithdrawCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = executeWithdrawReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "executeWithdraw()";
            const SELECTOR: [u8; 4] = [248u8, 253u8, 151u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                executeWithdrawReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAssetAdapter(address)` and selector `0x8a7fe60f`.
```solidity
function getAssetAdapter(address token) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAssetAdapterCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAssetAdapter(address)`](getAssetAdapterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAssetAdapterReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetAdapterCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAssetAdapterCall) -> Self {
                    (value.token,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAssetAdapterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { token: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetAdapterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAssetAdapterReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAssetAdapterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAssetAdapterCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAssetAdapter(address)";
            const SELECTOR: [u8; 4] = [138u8, 127u8, 230u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAssetAdapterReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAssetAdapterReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getAssetConfig(address)` and selector `0x6ec3ab67`.
```solidity
function getAssetConfig(address token) external view returns (Types.AssetConfig memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAssetConfigCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getAssetConfig(address)`](getAssetConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getAssetConfigReturn {
        #[allow(missing_docs)]
        pub _0: <Types::AssetConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: getAssetConfigCall) -> Self {
                    (value.token,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getAssetConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { token: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Types::AssetConfig,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::AssetConfig as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getAssetConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getAssetConfigReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getAssetConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getAssetConfigCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Types::AssetConfig as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Types::AssetConfig,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getAssetConfig(address)";
            const SELECTOR: [u8; 4] = [110u8, 195u8, 171u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Types::AssetConfig as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getAssetConfigReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getAssetConfigReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getDelegation(address,address)` and selector `0x15049a5a`.
```solidity
function getDelegation(address delegator, address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDelegationCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getDelegation(address,address)`](getDelegationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDelegationReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDelegationCall> for UnderlyingRustTuple<'_> {
                fn from(value: getDelegationCall) -> Self {
                    (value.delegator, value.operator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDelegationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegator: tuple.0,
                        operator: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDelegationReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getDelegationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDelegationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDelegationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDelegation(address,address)";
            const SELECTOR: [u8; 4] = [21u8, 4u8, 154u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getDelegationReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getDelegationReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getDelegationBlueprints(address,uint256)` and selector `0x7b9996c5`.
```solidity
function getDelegationBlueprints(address delegator, uint256 idx) external view returns (uint64[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDelegationBlueprintsCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub idx: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getDelegationBlueprints(address,uint256)`](getDelegationBlueprintsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDelegationBlueprintsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<u64>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDelegationBlueprintsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getDelegationBlueprintsCall) -> Self {
                    (value.delegator, value.idx)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getDelegationBlueprintsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegator: tuple.0,
                        idx: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<u64>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDelegationBlueprintsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getDelegationBlueprintsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getDelegationBlueprintsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDelegationBlueprintsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<u64>;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDelegationBlueprints(address,uint256)";
            const SELECTOR: [u8; 4] = [123u8, 153u8, 150u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.idx),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<64>,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getDelegationBlueprintsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getDelegationBlueprintsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getDelegations(address)` and selector `0x31cc13ba`.
```solidity
function getDelegations(address delegator) external view returns (Types.BondInfoDelegator[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDelegationsCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    ///Container type for the return parameters of the [`getDelegations(address)`](getDelegationsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDelegationsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <Types::BondInfoDelegator as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDelegationsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getDelegationsCall) -> Self {
                    (value.delegator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDelegationsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<Types::BondInfoDelegator>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <Types::BondInfoDelegator as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDelegationsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getDelegationsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getDelegationsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDelegationsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                <Types::BondInfoDelegator as alloy::sol_types::SolType>::RustType,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<Types::BondInfoDelegator>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDelegations(address)";
            const SELECTOR: [u8; 4] = [49u8, 204u8, 19u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        Types::BondInfoDelegator,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getDelegationsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getDelegationsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getDeposit(address,address)` and selector `0xc35082a9`.
```solidity
function getDeposit(address delegator, address token) external view returns (Types.Deposit memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDepositCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getDeposit(address,address)`](getDepositCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getDepositReturn {
        #[allow(missing_docs)]
        pub _0: <Types::Deposit as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDepositCall> for UnderlyingRustTuple<'_> {
                fn from(value: getDepositCall) -> Self {
                    (value.delegator, value.token)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDepositCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegator: tuple.0,
                        token: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Types::Deposit,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::Deposit as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getDepositReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getDepositReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getDepositReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getDepositCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Types::Deposit as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Types::Deposit,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getDeposit(address,address)";
            const SELECTOR: [u8; 4] = [195u8, 80u8, 130u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Types::Deposit as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getDepositReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getDepositReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getLocks(address,address)` and selector `0x0c8833ce`.
```solidity
function getLocks(address delegator, address token) external view returns (Types.LockInfo[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLocksCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    ///Container type for the return parameters of the [`getLocks(address,address)`](getLocksCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getLocksReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <Types::LockInfo as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLocksCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLocksCall) -> Self {
                    (value.delegator, value.token)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLocksCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegator: tuple.0,
                        token: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<Types::LockInfo>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <Types::LockInfo as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLocksReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLocksReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLocksReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLocksCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                <Types::LockInfo as alloy::sol_types::SolType>::RustType,
            >;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Array<Types::LockInfo>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLocks(address,address)";
            const SELECTOR: [u8; 4] = [12u8, 136u8, 51u8, 206u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        Types::LockInfo,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getLocksReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getLocksReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorBlueprints(address)` and selector `0xdc972ccc`.
```solidity
function getOperatorBlueprints(address operator) external view returns (uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorBlueprintsCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOperatorBlueprints(address)`](getOperatorBlueprintsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorBlueprintsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorBlueprintsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorBlueprintsCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorBlueprintsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorBlueprintsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorBlueprintsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorBlueprintsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorBlueprintsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::primitives::aliases::U256,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorBlueprints(address)";
            const SELECTOR: [u8; 4] = [220u8, 151u8, 44u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<256>,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorBlueprintsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorBlueprintsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorDelegatedStake(address)` and selector `0x8c5b4ae7`.
```solidity
function getOperatorDelegatedStake(address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorDelegatedStakeCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOperatorDelegatedStake(address)`](getOperatorDelegatedStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorDelegatedStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorDelegatedStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorDelegatedStakeCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorDelegatedStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorDelegatedStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorDelegatedStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorDelegatedStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorDelegatedStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorDelegatedStake(address)";
            const SELECTOR: [u8; 4] = [140u8, 91u8, 74u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorDelegatedStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorDelegatedStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorDelegatorCount(address)` and selector `0x486398c3`.
```solidity
function getOperatorDelegatorCount(address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorDelegatorCountCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOperatorDelegatorCount(address)`](getOperatorDelegatorCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorDelegatorCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorDelegatorCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorDelegatorCountCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorDelegatorCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorDelegatorCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorDelegatorCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorDelegatorCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorDelegatorCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorDelegatorCount(address)";
            const SELECTOR: [u8; 4] = [72u8, 99u8, 152u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorDelegatorCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorDelegatorCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorDelegators(address)` and selector `0xa299e298`.
```solidity
function getOperatorDelegators(address operator) external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorDelegatorsCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOperatorDelegators(address)`](getOperatorDelegatorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorDelegatorsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorDelegatorsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorDelegatorsCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorDelegatorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorDelegatorsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorDelegatorsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorDelegatorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorDelegatorsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorDelegators(address)";
            const SELECTOR: [u8; 4] = [162u8, 153u8, 226u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorDelegatorsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorDelegatorsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorMetadata(address)` and selector `0x2ee663b8`.
```solidity
function getOperatorMetadata(address operator) external view returns (Types.OperatorMetadata memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorMetadataCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    ///Container type for the return parameters of the [`getOperatorMetadata(address)`](getOperatorMetadataCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorMetadataReturn {
        #[allow(missing_docs)]
        pub _0: <Types::OperatorMetadata as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorMetadataCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorMetadataCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorMetadataCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Types::OperatorMetadata,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::OperatorMetadata as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorMetadataReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorMetadataReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorMetadataReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorMetadataCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Types::OperatorMetadata as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Types::OperatorMetadata,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorMetadata(address)";
            const SELECTOR: [u8; 4] = [46u8, 230u8, 99u8, 184u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Types::OperatorMetadata as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorMetadataReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorMetadataReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorRewardPool(address)` and selector `0x03587c1d`.
```solidity
function getOperatorRewardPool(address operator) external view returns (Types.OperatorRewardPool memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorRewardPoolCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOperatorRewardPool(address)`](getOperatorRewardPoolCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorRewardPoolReturn {
        #[allow(missing_docs)]
        pub _0: <Types::OperatorRewardPool as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorRewardPoolCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorRewardPoolCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorRewardPoolCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Types::OperatorRewardPool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::OperatorRewardPool as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorRewardPoolReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorRewardPoolReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorRewardPoolReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorRewardPoolCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Types::OperatorRewardPool as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Types::OperatorRewardPool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorRewardPool(address)";
            const SELECTOR: [u8; 4] = [3u8, 88u8, 124u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Types::OperatorRewardPool as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorRewardPoolReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorRewardPoolReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorSelfStake(address)` and selector `0xd673e0b9`.
```solidity
function getOperatorSelfStake(address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorSelfStakeCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOperatorSelfStake(address)`](getOperatorSelfStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorSelfStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorSelfStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorSelfStakeCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorSelfStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorSelfStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorSelfStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorSelfStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorSelfStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorSelfStake(address)";
            const SELECTOR: [u8; 4] = [214u8, 115u8, 224u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorSelfStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorSelfStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorSlashFactor(address)` and selector `0x615d24de`.
```solidity
function getOperatorSlashFactor(address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorSlashFactorCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOperatorSlashFactor(address)`](getOperatorSlashFactorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorSlashFactorReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorSlashFactorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorSlashFactorCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorSlashFactorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorSlashFactorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorSlashFactorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorSlashFactorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorSlashFactorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorSlashFactor(address)";
            const SELECTOR: [u8; 4] = [97u8, 93u8, 36u8, 222u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorSlashFactorReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorSlashFactorReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getOperatorStake(address)` and selector `0xe4e88de8`.
```solidity
function getOperatorStake(address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorStakeCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getOperatorStake(address)`](getOperatorStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorStakeCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorStake(address)";
            const SELECTOR: [u8; 4] = [228u8, 232u8, 141u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getOperatorStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getOperatorStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPendingDelegatorRewards(address)` and selector `0x168f6865`.
```solidity
function getPendingDelegatorRewards(address delegator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPendingDelegatorRewardsCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPendingDelegatorRewards(address)`](getPendingDelegatorRewardsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPendingDelegatorRewardsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingDelegatorRewardsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingDelegatorRewardsCall) -> Self {
                    (value.delegator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingDelegatorRewardsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingDelegatorRewardsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingDelegatorRewardsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingDelegatorRewardsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPendingDelegatorRewardsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPendingDelegatorRewards(address)";
            const SELECTOR: [u8; 4] = [22u8, 143u8, 104u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getPendingDelegatorRewardsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getPendingDelegatorRewardsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPendingOperatorRewards(address)` and selector `0x30224fc8`.
```solidity
function getPendingOperatorRewards(address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPendingOperatorRewardsCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getPendingOperatorRewards(address)`](getPendingOperatorRewardsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPendingOperatorRewardsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingOperatorRewardsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingOperatorRewardsCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingOperatorRewardsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingOperatorRewardsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingOperatorRewardsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingOperatorRewardsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPendingOperatorRewardsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPendingOperatorRewards(address)";
            const SELECTOR: [u8; 4] = [48u8, 34u8, 79u8, 200u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getPendingOperatorRewardsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getPendingOperatorRewardsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPendingUnstakes(address)` and selector `0x5722d512`.
```solidity
function getPendingUnstakes(address delegator) external view returns (Types.BondLessRequest[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPendingUnstakesCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    ///Container type for the return parameters of the [`getPendingUnstakes(address)`](getPendingUnstakesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPendingUnstakesReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <Types::BondLessRequest as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingUnstakesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingUnstakesCall) -> Self {
                    (value.delegator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingUnstakesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<Types::BondLessRequest>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <Types::BondLessRequest as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingUnstakesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingUnstakesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingUnstakesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPendingUnstakesCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                <Types::BondLessRequest as alloy::sol_types::SolType>::RustType,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<Types::BondLessRequest>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPendingUnstakes(address)";
            const SELECTOR: [u8; 4] = [87u8, 34u8, 213u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        Types::BondLessRequest,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getPendingUnstakesReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getPendingUnstakesReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getPendingWithdrawals(address)` and selector `0xf340c0d0`.
```solidity
function getPendingWithdrawals(address delegator) external view returns (Types.WithdrawRequest[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPendingWithdrawalsCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    ///Container type for the return parameters of the [`getPendingWithdrawals(address)`](getPendingWithdrawalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getPendingWithdrawalsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<
            <Types::WithdrawRequest as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingWithdrawalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingWithdrawalsCall) -> Self {
                    (value.delegator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingWithdrawalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<Types::WithdrawRequest>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    <Types::WithdrawRequest as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getPendingWithdrawalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getPendingWithdrawalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getPendingWithdrawalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getPendingWithdrawalsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Vec<
                <Types::WithdrawRequest as alloy::sol_types::SolType>::RustType,
            >;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<Types::WithdrawRequest>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getPendingWithdrawals(address)";
            const SELECTOR: [u8; 4] = [243u8, 64u8, 192u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        Types::WithdrawRequest,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getPendingWithdrawalsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getPendingWithdrawalsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getRoleAdminReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSlashCount(address)` and selector `0x66c36875`.
```solidity
function getSlashCount(address operator) external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashCountCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSlashCount(address)`](getSlashCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashCountReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: getSlashCountCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getSlashCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getSlashCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getSlashCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSlashCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSlashCount(address)";
            const SELECTOR: [u8; 4] = [102u8, 195u8, 104u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getSlashCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getSlashCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSlashCountForBlueprint(uint64,address)` and selector `0xc550d938`.
```solidity
function getSlashCountForBlueprint(uint64 blueprintId, address operator) external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashCountForBlueprintCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSlashCountForBlueprint(uint64,address)`](getSlashCountForBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashCountForBlueprintReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashCountForBlueprintCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSlashCountForBlueprintCall) -> Self {
                    (value.blueprintId, value.operator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSlashCountForBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        operator: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashCountForBlueprintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSlashCountForBlueprintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSlashCountForBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSlashCountForBlueprintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSlashCountForBlueprint(uint64,address)";
            const SELECTOR: [u8; 4] = [197u8, 80u8, 217u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getSlashCountForBlueprintReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getSlashCountForBlueprintReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSlashCountForService(uint64,address)` and selector `0x72b5032d`.
```solidity
function getSlashCountForService(uint64 serviceId, address operator) external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashCountForServiceCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSlashCountForService(uint64,address)`](getSlashCountForServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashCountForServiceReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashCountForServiceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSlashCountForServiceCall) -> Self {
                    (value.serviceId, value.operator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSlashCountForServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        operator: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashCountForServiceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSlashCountForServiceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSlashCountForServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSlashCountForServiceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSlashCountForService(uint64,address)";
            const SELECTOR: [u8; 4] = [114u8, 181u8, 3u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getSlashCountForServiceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getSlashCountForServiceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSlashImpact(address,uint64,address)` and selector `0x9494f426`.
```solidity
function getSlashImpact(address operator, uint64 slashId, address delegator) external view returns (uint256 lostAmount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashImpactCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSlashImpact(address,uint64,address)`](getSlashImpactCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashImpactReturn {
        #[allow(missing_docs)]
        pub lostAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u64,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashImpactCall> for UnderlyingRustTuple<'_> {
                fn from(value: getSlashImpactCall) -> Self {
                    (value.operator, value.slashId, value.delegator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getSlashImpactCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        slashId: tuple.1,
                        delegator: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashImpactReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSlashImpactReturn) -> Self {
                    (value.lostAmount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSlashImpactReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { lostAmount: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSlashImpactCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSlashImpact(address,uint64,address)";
            const SELECTOR: [u8; 4] = [148u8, 148u8, 244u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getSlashImpactReturn = r.into();
                        r.lostAmount
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getSlashImpactReturn = r.into();
                        r.lostAmount
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSlashRecord(address,uint64)` and selector `0xa457af3d`.
```solidity
function getSlashRecord(address operator, uint64 slashId) external view returns (SlashingManager.SlashRecord memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashRecordCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSlashRecord(address,uint64)`](getSlashRecordCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashRecordReturn {
        #[allow(missing_docs)]
        pub _0: <SlashingManager::SlashRecord as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashRecordCall> for UnderlyingRustTuple<'_> {
                fn from(value: getSlashRecordCall) -> Self {
                    (value.operator, value.slashId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getSlashRecordCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        slashId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (SlashingManager::SlashRecord,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SlashingManager::SlashRecord as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashRecordReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSlashRecordReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSlashRecordReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSlashRecordCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <SlashingManager::SlashRecord as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (SlashingManager::SlashRecord,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSlashRecord(address,uint64)";
            const SELECTOR: [u8; 4] = [164u8, 87u8, 175u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <SlashingManager::SlashRecord as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getSlashRecordReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getSlashRecordReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getSnapshot(uint64,address)` and selector `0xc07449e2`.
```solidity
function getSnapshot(uint64 round, address operator) external view returns (Types.OperatorSnapshot memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSnapshotCall {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getSnapshot(uint64,address)`](getSnapshotCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSnapshotReturn {
        #[allow(missing_docs)]
        pub _0: <Types::OperatorSnapshot as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSnapshotCall> for UnderlyingRustTuple<'_> {
                fn from(value: getSnapshotCall) -> Self {
                    (value.round, value.operator)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getSnapshotCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        round: tuple.0,
                        operator: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (Types::OperatorSnapshot,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::OperatorSnapshot as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSnapshotReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getSnapshotReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getSnapshotReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSnapshotCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = <Types::OperatorSnapshot as alloy::sol_types::SolType>::RustType;
            type ReturnTuple<'a> = (Types::OperatorSnapshot,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSnapshot(uint64,address)";
            const SELECTOR: [u8; 4] = [192u8, 116u8, 73u8, 226u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (<Types::OperatorSnapshot as alloy_sol_types::SolType>::tokenize(ret),)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getSnapshotReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getSnapshotReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getTotalDelegation(address)` and selector `0xfc5e7e09`.
```solidity
function getTotalDelegation(address delegator) external view returns (uint256 total);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalDelegationCall {
        #[allow(missing_docs)]
        pub delegator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getTotalDelegation(address)`](getTotalDelegationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getTotalDelegationReturn {
        #[allow(missing_docs)]
        pub total: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalDelegationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalDelegationCall) -> Self {
                    (value.delegator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalDelegationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { delegator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTotalDelegationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getTotalDelegationReturn) -> Self {
                    (value.total,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getTotalDelegationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { total: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTotalDelegationCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTotalDelegation(address)";
            const SELECTOR: [u8; 4] = [252u8, 94u8, 126u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.delegator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getTotalDelegationReturn = r.into();
                        r.total
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getTotalDelegationReturn = r.into();
                        r.total
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl grantRoleReturn {
            fn _tokenize(
                &self,
            ) -> <grantRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                grantRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: hasRoleReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `increaseStake()` and selector `0xd9e257ef`.
```solidity
function increaseStake() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct increaseStakeCall;
    ///Container type for the return parameters of the [`increaseStake()`](increaseStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct increaseStakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<increaseStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: increaseStakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for increaseStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<increaseStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: increaseStakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for increaseStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl increaseStakeReturn {
            fn _tokenize(
                &self,
            ) -> <increaseStakeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for increaseStakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = increaseStakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "increaseStake()";
            const SELECTOR: [u8; 4] = [217u8, 226u8, 87u8, 239u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                increaseStakeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `initialize(address,uint256,uint256,uint16)` and selector `0xcbb6d6bd`.
```solidity
function initialize(address admin, uint256 nativeMinOperatorStake, uint256 nativeMinDelegation, uint16 _operatorCommissionBps) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub nativeMinOperatorStake: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub nativeMinDelegation: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub _operatorCommissionBps: u16,
    }
    ///Container type for the return parameters of the [`initialize(address,uint256,uint256,uint16)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                u16,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value.admin,
                        value.nativeMinOperatorStake,
                        value.nativeMinDelegation,
                        value._operatorCommissionBps,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        admin: tuple.0,
                        nativeMinOperatorStake: tuple.1,
                        nativeMinDelegation: tuple.2,
                        _operatorCommissionBps: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl initializeReturn {
            fn _tokenize(
                &self,
            ) -> <initializeCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,uint256,uint256,uint16)";
            const SELECTOR: [u8; 4] = [203u8, 182u8, 214u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.nativeMinOperatorStake,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.nativeMinDelegation),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self._operatorCommissionBps,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                initializeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isOperator(address)` and selector `0x6d70f7ae`.
```solidity
function isOperator(address operator) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOperatorCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isOperator(address)`](isOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOperatorReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isOperatorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isOperator(address)";
            const SELECTOR: [u8; 4] = [109u8, 112u8, 247u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isOperatorReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isOperatorReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isOperatorActive(address)` and selector `0xeb473533`.
```solidity
function isOperatorActive(address operator) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOperatorActiveCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isOperatorActive(address)`](isOperatorActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOperatorActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorActiveCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorActiveCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isOperatorActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isOperatorActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isOperatorActiveCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isOperatorActive(address)";
            const SELECTOR: [u8; 4] = [235u8, 71u8, 53u8, 51u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isOperatorActiveReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isOperatorActiveReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `isSlasher(address)` and selector `0x57601c5d`.
```solidity
function isSlasher(address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isSlasherCall {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`isSlasher(address)`](isSlasherCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isSlasherReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isSlasherCall> for UnderlyingRustTuple<'_> {
                fn from(value: isSlasherCall) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isSlasherCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isSlasherReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isSlasherReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isSlasherReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isSlasherCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isSlasher(address)";
            const SELECTOR: [u8; 4] = [87u8, 96u8, 28u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: isSlasherReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: isSlasherReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `lastRoundAdvance()` and selector `0x05d64e38`.
```solidity
function lastRoundAdvance() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastRoundAdvanceCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`lastRoundAdvance()`](lastRoundAdvanceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct lastRoundAdvanceReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastRoundAdvanceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastRoundAdvanceCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastRoundAdvanceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<lastRoundAdvanceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: lastRoundAdvanceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for lastRoundAdvanceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for lastRoundAdvanceCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "lastRoundAdvance()";
            const SELECTOR: [u8; 4] = [5u8, 214u8, 78u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: lastRoundAdvanceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: lastRoundAdvanceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `leaveDelegatorsDelay()` and selector `0xdb8a173a`.
```solidity
function leaveDelegatorsDelay() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaveDelegatorsDelayCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`leaveDelegatorsDelay()`](leaveDelegatorsDelayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaveDelegatorsDelayReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaveDelegatorsDelayCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: leaveDelegatorsDelayCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leaveDelegatorsDelayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaveDelegatorsDelayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: leaveDelegatorsDelayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leaveDelegatorsDelayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leaveDelegatorsDelayCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leaveDelegatorsDelay()";
            const SELECTOR: [u8; 4] = [219u8, 138u8, 23u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: leaveDelegatorsDelayReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: leaveDelegatorsDelayReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `leaveOperatorsDelay()` and selector `0x4de8addc`.
```solidity
function leaveOperatorsDelay() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaveOperatorsDelayCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`leaveOperatorsDelay()`](leaveOperatorsDelayCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaveOperatorsDelayReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaveOperatorsDelayCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: leaveOperatorsDelayCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leaveOperatorsDelayCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaveOperatorsDelayReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: leaveOperatorsDelayReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for leaveOperatorsDelayReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leaveOperatorsDelayCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leaveOperatorsDelay()";
            const SELECTOR: [u8; 4] = [77u8, 232u8, 173u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: leaveOperatorsDelayReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: leaveOperatorsDelayReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `meetsStakeRequirement(address,uint256)` and selector `0xf46913bb`.
```solidity
function meetsStakeRequirement(address operator, uint256 required) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct meetsStakeRequirementCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub required: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`meetsStakeRequirement(address,uint256)`](meetsStakeRequirementCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct meetsStakeRequirementReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<meetsStakeRequirementCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: meetsStakeRequirementCall) -> Self {
                    (value.operator, value.required)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for meetsStakeRequirementCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        required: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<meetsStakeRequirementReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: meetsStakeRequirementReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for meetsStakeRequirementReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for meetsStakeRequirementCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "meetsStakeRequirement(address,uint256)";
            const SELECTOR: [u8; 4] = [244u8, 105u8, 19u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: meetsStakeRequirementReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: meetsStakeRequirementReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `minOperatorStake()` and selector `0xd775cb61`.
```solidity
function minOperatorStake() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct minOperatorStakeCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`minOperatorStake()`](minOperatorStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct minOperatorStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<minOperatorStakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: minOperatorStakeCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for minOperatorStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<minOperatorStakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: minOperatorStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for minOperatorStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for minOperatorStakeCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "minOperatorStake()";
            const SELECTOR: [u8; 4] = [215u8, 117u8, 203u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: minOperatorStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: minOperatorStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nativeEnabled()` and selector `0x77ab2cf3`.
```solidity
function nativeEnabled() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nativeEnabledCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nativeEnabled()`](nativeEnabledCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nativeEnabledReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nativeEnabledCall> for UnderlyingRustTuple<'_> {
                fn from(value: nativeEnabledCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nativeEnabledCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nativeEnabledReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nativeEnabledReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nativeEnabledReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nativeEnabledCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nativeEnabled()";
            const SELECTOR: [u8; 4] = [119u8, 171u8, 44u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nativeEnabledReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nativeEnabledReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `nextSlashId(address)` and selector `0x96085673`.
```solidity
function nextSlashId(address) external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextSlashIdCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`nextSlashId(address)`](nextSlashIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct nextSlashIdReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextSlashIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: nextSlashIdCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextSlashIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<nextSlashIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: nextSlashIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for nextSlashIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for nextSlashIdCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "nextSlashId(address)";
            const SELECTOR: [u8; 4] = [150u8, 8u8, 86u8, 115u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: nextSlashIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: nextSlashIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `notifyReward(address,uint64,uint256)` and selector `0xa3b9c5c2`.
```solidity
function notifyReward(address operator, uint64 serviceId, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct notifyRewardCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`notifyReward(address,uint64,uint256)`](notifyRewardCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct notifyRewardReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<notifyRewardCall> for UnderlyingRustTuple<'_> {
                fn from(value: notifyRewardCall) -> Self {
                    (value.operator, value.serviceId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for notifyRewardCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        serviceId: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<notifyRewardReturn> for UnderlyingRustTuple<'_> {
                fn from(value: notifyRewardReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for notifyRewardReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl notifyRewardReturn {
            fn _tokenize(
                &self,
            ) -> <notifyRewardCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for notifyRewardCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = notifyRewardReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "notifyReward(address,uint64,uint256)";
            const SELECTOR: [u8; 4] = [163u8, 185u8, 197u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                notifyRewardReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `notifyRewardForBlueprint(address,uint64,uint64,uint256)` and selector `0x3dcad9db`.
```solidity
function notifyRewardForBlueprint(address operator, uint64 blueprintId, uint64 serviceId, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct notifyRewardForBlueprintCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`notifyRewardForBlueprint(address,uint64,uint64,uint256)`](notifyRewardForBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct notifyRewardForBlueprintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u64,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<notifyRewardForBlueprintCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: notifyRewardForBlueprintCall) -> Self {
                    (value.operator, value.blueprintId, value.serviceId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for notifyRewardForBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        blueprintId: tuple.1,
                        serviceId: tuple.2,
                        amount: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<notifyRewardForBlueprintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: notifyRewardForBlueprintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for notifyRewardForBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl notifyRewardForBlueprintReturn {
            fn _tokenize(
                &self,
            ) -> <notifyRewardForBlueprintCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for notifyRewardForBlueprintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = notifyRewardForBlueprintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "notifyRewardForBlueprint(address,uint64,uint64,uint256)";
            const SELECTOR: [u8; 4] = [61u8, 202u8, 217u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                notifyRewardForBlueprintReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `operatorAt(uint256)` and selector `0x26142335`.
```solidity
function operatorAt(uint256 index) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorAtCall {
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`operatorAt(uint256)`](operatorAtCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorAtReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorAtCall> for UnderlyingRustTuple<'_> {
                fn from(value: operatorAtCall) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for operatorAtCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorAtReturn> for UnderlyingRustTuple<'_> {
                fn from(value: operatorAtReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for operatorAtReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for operatorAtCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "operatorAt(uint256)";
            const SELECTOR: [u8; 4] = [38u8, 20u8, 35u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: operatorAtReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: operatorAtReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `operatorCommissionBps()` and selector `0x32273f61`.
```solidity
function operatorCommissionBps() external view returns (uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorCommissionBpsCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`operatorCommissionBps()`](operatorCommissionBpsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorCommissionBpsReturn {
        #[allow(missing_docs)]
        pub _0: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorCommissionBpsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: operatorCommissionBpsCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for operatorCommissionBpsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorCommissionBpsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: operatorCommissionBpsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for operatorCommissionBpsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for operatorCommissionBpsCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u16;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "operatorCommissionBps()";
            const SELECTOR: [u8; 4] = [50u8, 39u8, 63u8, 97u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: operatorCommissionBpsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: operatorCommissionBpsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `operatorCount()` and selector `0x7c6f3158`.
```solidity
function operatorCount() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorCountCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`operatorCount()`](operatorCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: operatorCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for operatorCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: operatorCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for operatorCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for operatorCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "operatorCount()";
            const SELECTOR: [u8; 4] = [124u8, 111u8, 49u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: operatorCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: operatorCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `operatorStake(address)` and selector `0xb39bcf3f`.
```solidity
function operatorStake(address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorStakeCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`operatorStake(address)`](operatorStakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorStakeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorStakeCall> for UnderlyingRustTuple<'_> {
                fn from(value: operatorStakeCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for operatorStakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorStakeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: operatorStakeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for operatorStakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for operatorStakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "operatorStake(address)";
            const SELECTOR: [u8; 4] = [179u8, 155u8, 207u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: operatorStakeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: operatorStakeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall;
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl pauseReturn {
            fn _tokenize(
                &self,
            ) -> <pauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                pauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pausedReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: proxiableUUIDReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `registerAdapter(address,address)` and selector `0xd655b92a`.
```solidity
function registerAdapter(address token, address adapter) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerAdapterCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub adapter: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`registerAdapter(address,address)`](registerAdapterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerAdapterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerAdapterCall> for UnderlyingRustTuple<'_> {
                fn from(value: registerAdapterCall) -> Self {
                    (value.token, value.adapter)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerAdapterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        adapter: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerAdapterReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerAdapterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerAdapterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl registerAdapterReturn {
            fn _tokenize(
                &self,
            ) -> <registerAdapterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerAdapterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerAdapterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerAdapter(address,address)";
            const SELECTOR: [u8; 4] = [214u8, 85u8, 185u8, 42u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.adapter,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                registerAdapterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `registerOperator()` and selector `0x2acde098`.
```solidity
function registerOperator() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerOperatorCall;
    ///Container type for the return parameters of the [`registerOperator()`](registerOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerOperatorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl registerOperatorReturn {
            fn _tokenize(
                &self,
            ) -> <registerOperatorCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerOperatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerOperator()";
            const SELECTOR: [u8; 4] = [42u8, 205u8, 224u8, 152u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                registerOperatorReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `registerOperatorWithAsset(address,uint256)` and selector `0xe0a5825b`.
```solidity
function registerOperatorWithAsset(address token, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerOperatorWithAssetCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`registerOperatorWithAsset(address,uint256)`](registerOperatorWithAssetCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerOperatorWithAssetReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorWithAssetCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorWithAssetCall) -> Self {
                    (value.token, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerOperatorWithAssetCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorWithAssetReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorWithAssetReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerOperatorWithAssetReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl registerOperatorWithAssetReturn {
            fn _tokenize(
                &self,
            ) -> <registerOperatorWithAssetCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerOperatorWithAssetCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerOperatorWithAssetReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerOperatorWithAsset(address,uint256)";
            const SELECTOR: [u8; 4] = [224u8, 165u8, 130u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                registerOperatorWithAssetReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeAdapter(address)` and selector `0x585cd34b`.
```solidity
function removeAdapter(address token) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAdapterCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeAdapter(address)`](removeAdapterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeAdapterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAdapterCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeAdapterCall) -> Self {
                    (value.token,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeAdapterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { token: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeAdapterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeAdapterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeAdapterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeAdapterReturn {
            fn _tokenize(
                &self,
            ) -> <removeAdapterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeAdapterCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeAdapterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeAdapter(address)";
            const SELECTOR: [u8; 4] = [88u8, 92u8, 211u8, 75u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeAdapterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeBlueprint(uint64)` and selector `0x28e70ecc`.
```solidity
function removeBlueprint(uint64 blueprintId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBlueprintCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    ///Container type for the return parameters of the [`removeBlueprint(uint64)`](removeBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBlueprintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBlueprintCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeBlueprintCall) -> Self {
                    (value.blueprintId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blueprintId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBlueprintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeBlueprintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeBlueprintReturn {
            fn _tokenize(
                &self,
            ) -> <removeBlueprintCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBlueprintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBlueprintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBlueprint(uint64)";
            const SELECTOR: [u8; 4] = [40u8, 231u8, 14u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeBlueprintReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeBlueprintFromDelegation(uint256,uint64)` and selector `0x859caa18`.
```solidity
function removeBlueprintFromDelegation(uint256 delegationIndex, uint64 blueprintId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBlueprintFromDelegationCall {
        #[allow(missing_docs)]
        pub delegationIndex: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    ///Container type for the return parameters of the [`removeBlueprintFromDelegation(uint256,uint64)`](removeBlueprintFromDelegationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeBlueprintFromDelegationReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBlueprintFromDelegationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeBlueprintFromDelegationCall) -> Self {
                    (value.delegationIndex, value.blueprintId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeBlueprintFromDelegationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        delegationIndex: tuple.0,
                        blueprintId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeBlueprintFromDelegationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removeBlueprintFromDelegationReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removeBlueprintFromDelegationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeBlueprintFromDelegationReturn {
            fn _tokenize(
                &self,
            ) -> <removeBlueprintFromDelegationCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeBlueprintFromDelegationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeBlueprintFromDelegationReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeBlueprintFromDelegation(uint256,uint64)";
            const SELECTOR: [u8; 4] = [133u8, 156u8, 170u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.delegationIndex),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeBlueprintFromDelegationReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `removeSlasher(address)` and selector `0xaac6aa9c`.
```solidity
function removeSlasher(address slasher) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeSlasherCall {
        #[allow(missing_docs)]
        pub slasher: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removeSlasher(address)`](removeSlasherCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removeSlasherReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeSlasherCall> for UnderlyingRustTuple<'_> {
                fn from(value: removeSlasherCall) -> Self {
                    (value.slasher,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeSlasherCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slasher: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removeSlasherReturn> for UnderlyingRustTuple<'_> {
                fn from(value: removeSlasherReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for removeSlasherReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl removeSlasherReturn {
            fn _tokenize(
                &self,
            ) -> <removeSlasherCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removeSlasherCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removeSlasherReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removeSlasher(address)";
            const SELECTOR: [u8; 4] = [170u8, 198u8, 170u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.slasher,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                removeSlasherReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceRoleReturn {
            fn _tokenize(
                &self,
            ) -> <renounceRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `requireAdapters()` and selector `0xb54b2b9e`.
```solidity
function requireAdapters() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requireAdaptersCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`requireAdapters()`](requireAdaptersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requireAdaptersReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requireAdaptersCall> for UnderlyingRustTuple<'_> {
                fn from(value: requireAdaptersCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for requireAdaptersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requireAdaptersReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requireAdaptersReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requireAdaptersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requireAdaptersCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requireAdapters()";
            const SELECTOR: [u8; 4] = [181u8, 75u8, 43u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: requireAdaptersReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: requireAdaptersReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `rescueTokens(address,address,uint256)` and selector `0xcea9d26f`.
```solidity
function rescueTokens(address token, address to, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rescueTokensCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`rescueTokens(address,address,uint256)`](rescueTokensCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rescueTokensReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rescueTokensCall> for UnderlyingRustTuple<'_> {
                fn from(value: rescueTokensCall) -> Self {
                    (value.token, value.to, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rescueTokensCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        to: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rescueTokensReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rescueTokensReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rescueTokensReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl rescueTokensReturn {
            fn _tokenize(
                &self,
            ) -> <rescueTokensCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rescueTokensCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = rescueTokensReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rescueTokens(address,address,uint256)";
            const SELECTOR: [u8; 4] = [206u8, 169u8, 210u8, 111u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                rescueTokensReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl revokeRoleReturn {
            fn _tokenize(
                &self,
            ) -> <revokeRoleCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                revokeRoleReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `rewardPoolTotals(address)` and selector `0x697d08f9`.
```solidity
function rewardPoolTotals(address operator) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rewardPoolTotalsCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`rewardPoolTotals(address)`](rewardPoolTotalsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rewardPoolTotalsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rewardPoolTotalsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: rewardPoolTotalsCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for rewardPoolTotalsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rewardPoolTotalsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: rewardPoolTotalsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for rewardPoolTotalsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rewardPoolTotalsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rewardPoolTotals(address)";
            const SELECTOR: [u8; 4] = [105u8, 125u8, 8u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: rewardPoolTotalsReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: rewardPoolTotalsReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `rewardsManager()` and selector `0xdefe2053`.
```solidity
function rewardsManager() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rewardsManagerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`rewardsManager()`](rewardsManagerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rewardsManagerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rewardsManagerCall> for UnderlyingRustTuple<'_> {
                fn from(value: rewardsManagerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rewardsManagerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rewardsManagerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: rewardsManagerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for rewardsManagerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rewardsManagerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rewardsManager()";
            const SELECTOR: [u8; 4] = [222u8, 254u8, 32u8, 83u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: rewardsManagerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: rewardsManagerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `roundDuration()` and selector `0xf7cb789a`.
```solidity
function roundDuration() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct roundDurationCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`roundDuration()`](roundDurationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct roundDurationReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<roundDurationCall> for UnderlyingRustTuple<'_> {
                fn from(value: roundDurationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for roundDurationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<roundDurationReturn> for UnderlyingRustTuple<'_> {
                fn from(value: roundDurationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for roundDurationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for roundDurationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "roundDuration()";
            const SELECTOR: [u8; 4] = [247u8, 203u8, 120u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: roundDurationReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: roundDurationReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `scheduleDelegatorUnstake(address,address,uint256)` and selector `0xfc8a91af`.
```solidity
function scheduleDelegatorUnstake(address operator, address token, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct scheduleDelegatorUnstakeCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`scheduleDelegatorUnstake(address,address,uint256)`](scheduleDelegatorUnstakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct scheduleDelegatorUnstakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<scheduleDelegatorUnstakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: scheduleDelegatorUnstakeCall) -> Self {
                    (value.operator, value.token, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for scheduleDelegatorUnstakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        token: tuple.1,
                        amount: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<scheduleDelegatorUnstakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: scheduleDelegatorUnstakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for scheduleDelegatorUnstakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl scheduleDelegatorUnstakeReturn {
            fn _tokenize(
                &self,
            ) -> <scheduleDelegatorUnstakeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for scheduleDelegatorUnstakeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = scheduleDelegatorUnstakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "scheduleDelegatorUnstake(address,address,uint256)";
            const SELECTOR: [u8; 4] = [252u8, 138u8, 145u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                scheduleDelegatorUnstakeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `scheduleOperatorUnstake(uint256)` and selector `0x44aff252`.
```solidity
function scheduleOperatorUnstake(uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct scheduleOperatorUnstakeCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`scheduleOperatorUnstake(uint256)`](scheduleOperatorUnstakeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct scheduleOperatorUnstakeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<scheduleOperatorUnstakeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: scheduleOperatorUnstakeCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for scheduleOperatorUnstakeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<scheduleOperatorUnstakeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: scheduleOperatorUnstakeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for scheduleOperatorUnstakeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl scheduleOperatorUnstakeReturn {
            fn _tokenize(
                &self,
            ) -> <scheduleOperatorUnstakeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for scheduleOperatorUnstakeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = scheduleOperatorUnstakeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "scheduleOperatorUnstake(uint256)";
            const SELECTOR: [u8; 4] = [68u8, 175u8, 242u8, 82u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                scheduleOperatorUnstakeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `scheduleWithdraw(address,uint256)` and selector `0xe1ee4bcc`.
```solidity
function scheduleWithdraw(address token, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct scheduleWithdrawCall {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`scheduleWithdraw(address,uint256)`](scheduleWithdrawCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct scheduleWithdrawReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<scheduleWithdrawCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: scheduleWithdrawCall) -> Self {
                    (value.token, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for scheduleWithdrawCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        token: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<scheduleWithdrawReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: scheduleWithdrawReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for scheduleWithdrawReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl scheduleWithdrawReturn {
            fn _tokenize(
                &self,
            ) -> <scheduleWithdrawCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for scheduleWithdrawCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = scheduleWithdrawReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "scheduleWithdraw(address,uint256)";
            const SELECTOR: [u8; 4] = [225u8, 238u8, 75u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                scheduleWithdrawReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `serviceFeeDistributor()` and selector `0x2e40f7fb`.
```solidity
function serviceFeeDistributor() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serviceFeeDistributorCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`serviceFeeDistributor()`](serviceFeeDistributorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serviceFeeDistributorReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceFeeDistributorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: serviceFeeDistributorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for serviceFeeDistributorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceFeeDistributorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: serviceFeeDistributorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for serviceFeeDistributorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serviceFeeDistributorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serviceFeeDistributor()";
            const SELECTOR: [u8; 4] = [46u8, 64u8, 247u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: serviceFeeDistributorReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: serviceFeeDistributorReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `serviceSlashCount(uint64,address)` and selector `0x9722f4b9`.
```solidity
function serviceSlashCount(uint64, address) external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serviceSlashCountCall {
        #[allow(missing_docs)]
        pub _0: u64,
        #[allow(missing_docs)]
        pub _1: alloy::sol_types::private::Address,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`serviceSlashCount(uint64,address)`](serviceSlashCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serviceSlashCountReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceSlashCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: serviceSlashCountCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for serviceSlashCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceSlashCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: serviceSlashCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for serviceSlashCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serviceSlashCountCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = u64;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serviceSlashCount(uint64,address)";
            const SELECTOR: [u8; 4] = [151u8, 34u8, 244u8, 185u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self._0),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: serviceSlashCountReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: serviceSlashCountReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setDelays(uint64,uint64,uint64)` and selector `0x03780211`.
```solidity
function setDelays(uint64 _delegationBondLessDelay, uint64 _leaveDelegatorsDelay, uint64 _leaveOperatorsDelay) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDelaysCall {
        #[allow(missing_docs)]
        pub _delegationBondLessDelay: u64,
        #[allow(missing_docs)]
        pub _leaveDelegatorsDelay: u64,
        #[allow(missing_docs)]
        pub _leaveOperatorsDelay: u64,
    }
    ///Container type for the return parameters of the [`setDelays(uint64,uint64,uint64)`](setDelaysCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setDelaysReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u64, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDelaysCall> for UnderlyingRustTuple<'_> {
                fn from(value: setDelaysCall) -> Self {
                    (
                        value._delegationBondLessDelay,
                        value._leaveDelegatorsDelay,
                        value._leaveOperatorsDelay,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setDelaysCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _delegationBondLessDelay: tuple.0,
                        _leaveDelegatorsDelay: tuple.1,
                        _leaveOperatorsDelay: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setDelaysReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setDelaysReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setDelaysReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setDelaysReturn {
            fn _tokenize(
                &self,
            ) -> <setDelaysCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setDelaysCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setDelaysReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setDelays(uint64,uint64,uint64)";
            const SELECTOR: [u8; 4] = [3u8, 120u8, 2u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self._delegationBondLessDelay,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self._leaveDelegatorsDelay,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self._leaveOperatorsDelay),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setDelaysReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setOperatorCommission(uint16)` and selector `0xf3c4d8a0`.
```solidity
function setOperatorCommission(uint16 bps) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOperatorCommissionCall {
        #[allow(missing_docs)]
        pub bps: u16,
    }
    ///Container type for the return parameters of the [`setOperatorCommission(uint16)`](setOperatorCommissionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOperatorCommissionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorCommissionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorCommissionCall) -> Self {
                    (value.bps,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setOperatorCommissionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { bps: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorCommissionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorCommissionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setOperatorCommissionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setOperatorCommissionReturn {
            fn _tokenize(
                &self,
            ) -> <setOperatorCommissionCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setOperatorCommissionCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setOperatorCommissionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setOperatorCommission(uint16)";
            const SELECTOR: [u8; 4] = [243u8, 196u8, 216u8, 160u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.bps),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setOperatorCommissionReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setRequireAdapters(bool)` and selector `0x7b76fe5e`.
```solidity
function setRequireAdapters(bool required) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRequireAdaptersCall {
        #[allow(missing_docs)]
        pub required: bool,
    }
    ///Container type for the return parameters of the [`setRequireAdapters(bool)`](setRequireAdaptersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRequireAdaptersReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRequireAdaptersCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRequireAdaptersCall) -> Self {
                    (value.required,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRequireAdaptersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { required: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRequireAdaptersReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRequireAdaptersReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRequireAdaptersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setRequireAdaptersReturn {
            fn _tokenize(
                &self,
            ) -> <setRequireAdaptersCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRequireAdaptersCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRequireAdaptersReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRequireAdapters(bool)";
            const SELECTOR: [u8; 4] = [123u8, 118u8, 254u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.required,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setRequireAdaptersReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setRewardsManager(address)` and selector `0x0a8ddc5e`.
```solidity
function setRewardsManager(address manager) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRewardsManagerCall {
        #[allow(missing_docs)]
        pub manager: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setRewardsManager(address)`](setRewardsManagerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRewardsManagerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRewardsManagerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRewardsManagerCall) -> Self {
                    (value.manager,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRewardsManagerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { manager: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRewardsManagerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRewardsManagerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRewardsManagerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setRewardsManagerReturn {
            fn _tokenize(
                &self,
            ) -> <setRewardsManagerCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRewardsManagerCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRewardsManagerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRewardsManager(address)";
            const SELECTOR: [u8; 4] = [10u8, 141u8, 220u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.manager,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setRewardsManagerReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setServiceFeeDistributor(address)` and selector `0xfbcc7b3d`.
```solidity
function setServiceFeeDistributor(address distributor) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setServiceFeeDistributorCall {
        #[allow(missing_docs)]
        pub distributor: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setServiceFeeDistributor(address)`](setServiceFeeDistributorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setServiceFeeDistributorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setServiceFeeDistributorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setServiceFeeDistributorCall) -> Self {
                    (value.distributor,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setServiceFeeDistributorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { distributor: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setServiceFeeDistributorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setServiceFeeDistributorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setServiceFeeDistributorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setServiceFeeDistributorReturn {
            fn _tokenize(
                &self,
            ) -> <setServiceFeeDistributorCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setServiceFeeDistributorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setServiceFeeDistributorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setServiceFeeDistributor(address)";
            const SELECTOR: [u8; 4] = [251u8, 204u8, 123u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.distributor,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setServiceFeeDistributorReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `slash(address,uint64,uint256,bytes32)` and selector `0x356924ea`.
```solidity
function slash(address operator, uint64 serviceId, uint256 amount, bytes32 evidence) external returns (uint256 actualSlashed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct slashCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`slash(address,uint64,uint256,bytes32)`](slashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct slashReturn {
        #[allow(missing_docs)]
        pub actualSlashed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<slashCall> for UnderlyingRustTuple<'_> {
                fn from(value: slashCall) -> Self {
                    (value.operator, value.serviceId, value.amount, value.evidence)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for slashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        serviceId: tuple.1,
                        amount: tuple.2,
                        evidence: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<slashReturn> for UnderlyingRustTuple<'_> {
                fn from(value: slashReturn) -> Self {
                    (value.actualSlashed,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for slashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { actualSlashed: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for slashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "slash(address,uint64,uint256,bytes32)";
            const SELECTOR: [u8; 4] = [53u8, 105u8, 36u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: slashReturn = r.into();
                        r.actualSlashed
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: slashReturn = r.into();
                        r.actualSlashed
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `slashForBlueprint(address,uint64,uint64,uint256,bytes32)` and selector `0x8d795d50`.
```solidity
function slashForBlueprint(address operator, uint64 blueprintId, uint64 serviceId, uint256 amount, bytes32 evidence) external returns (uint256 actualSlashed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct slashForBlueprintCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`slashForBlueprint(address,uint64,uint64,uint256,bytes32)`](slashForBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct slashForBlueprintReturn {
        #[allow(missing_docs)]
        pub actualSlashed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u64,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<slashForBlueprintCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: slashForBlueprintCall) -> Self {
                    (
                        value.operator,
                        value.blueprintId,
                        value.serviceId,
                        value.amount,
                        value.evidence,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for slashForBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        blueprintId: tuple.1,
                        serviceId: tuple.2,
                        amount: tuple.3,
                        evidence: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<slashForBlueprintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: slashForBlueprintReturn) -> Self {
                    (value.actualSlashed,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for slashForBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { actualSlashed: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for slashForBlueprintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "slashForBlueprint(address,uint64,uint64,uint256,bytes32)";
            const SELECTOR: [u8; 4] = [141u8, 121u8, 93u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: slashForBlueprintReturn = r.into();
                        r.actualSlashed
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: slashForBlueprintReturn = r.into();
                        r.actualSlashed
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    /**Function with signature `slashForService(address,uint64,uint64,((uint8,address),uint16)[],uint256,bytes32)` and selector `0x9e8c49d4`.
```solidity
function slashForService(address operator, uint64 blueprintId, uint64 serviceId, Types.AssetSecurityCommitment[] memory commitments, uint256 amount, bytes32 evidence) external returns (uint256 actualSlashed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct slashForServiceCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub commitments: alloy::sol_types::private::Vec<
            <Types::AssetSecurityCommitment as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`slashForService(address,uint64,uint64,((uint8,address),uint16)[],uint256,bytes32)`](slashForServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct slashForServiceReturn {
        #[allow(missing_docs)]
        pub actualSlashed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<Types::AssetSecurityCommitment>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u64,
                u64,
                alloy::sol_types::private::Vec<
                    <Types::AssetSecurityCommitment as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<slashForServiceCall> for UnderlyingRustTuple<'_> {
                fn from(value: slashForServiceCall) -> Self {
                    (
                        value.operator,
                        value.blueprintId,
                        value.serviceId,
                        value.commitments,
                        value.amount,
                        value.evidence,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for slashForServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        blueprintId: tuple.1,
                        serviceId: tuple.2,
                        commitments: tuple.3,
                        amount: tuple.4,
                        evidence: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<slashForServiceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: slashForServiceReturn) -> Self {
                    (value.actualSlashed,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for slashForServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { actualSlashed: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for slashForServiceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<Types::AssetSecurityCommitment>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "slashForService(address,uint64,uint64,((uint8,address),uint16)[],uint256,bytes32)";
            const SELECTOR: [u8; 4] = [158u8, 140u8, 73u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Array<
                        Types::AssetSecurityCommitment,
                    > as alloy_sol_types::SolType>::tokenize(&self.commitments),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: slashForServiceReturn = r.into();
                        r.actualSlashed
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: slashForServiceReturn = r.into();
                        r.actualSlashed
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `slashHistory(address,uint64)` and selector `0x0aa8b110`.
```solidity
function slashHistory(address, uint64) external view returns (uint64 round, uint64 serviceId, uint64 blueprintId, uint256 totalSlashed, uint256 exchangeRateBefore, uint256 exchangeRateAfter, bytes32 evidence);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct slashHistoryCall {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _1: u64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`slashHistory(address,uint64)`](slashHistoryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct slashHistoryReturn {
        #[allow(missing_docs)]
        pub round: u64,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub totalSlashed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub exchangeRateBefore: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub exchangeRateAfter: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<slashHistoryCall> for UnderlyingRustTuple<'_> {
                fn from(value: slashHistoryCall) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for slashHistoryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                u64,
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<slashHistoryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: slashHistoryReturn) -> Self {
                    (
                        value.round,
                        value.serviceId,
                        value.blueprintId,
                        value.totalSlashed,
                        value.exchangeRateBefore,
                        value.exchangeRateAfter,
                        value.evidence,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for slashHistoryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        round: tuple.0,
                        serviceId: tuple.1,
                        blueprintId: tuple.2,
                        totalSlashed: tuple.3,
                        exchangeRateBefore: tuple.4,
                        exchangeRateAfter: tuple.5,
                        evidence: tuple.6,
                    }
                }
            }
        }
        impl slashHistoryReturn {
            fn _tokenize(
                &self,
            ) -> <slashHistoryCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.round),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalSlashed),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.exchangeRateBefore),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.exchangeRateAfter),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for slashHistoryCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = slashHistoryReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "slashHistory(address,uint64)";
            const SELECTOR: [u8; 4] = [10u8, 168u8, 177u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self._1),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                slashHistoryReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `snapshotOperator(address)` and selector `0xcadd550c`.
```solidity
function snapshotOperator(address operator) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct snapshotOperatorCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`snapshotOperator(address)`](snapshotOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct snapshotOperatorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<snapshotOperatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: snapshotOperatorCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for snapshotOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<snapshotOperatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: snapshotOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for snapshotOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl snapshotOperatorReturn {
            fn _tokenize(
                &self,
            ) -> <snapshotOperatorCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for snapshotOperatorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = snapshotOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "snapshotOperator(address)";
            const SELECTOR: [u8; 4] = [202u8, 221u8, 85u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                snapshotOperatorReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `startLeaving()` and selector `0x87703550`.
```solidity
function startLeaving() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startLeavingCall;
    ///Container type for the return parameters of the [`startLeaving()`](startLeavingCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct startLeavingReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startLeavingCall> for UnderlyingRustTuple<'_> {
                fn from(value: startLeavingCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startLeavingCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<startLeavingReturn> for UnderlyingRustTuple<'_> {
                fn from(value: startLeavingReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for startLeavingReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl startLeavingReturn {
            fn _tokenize(
                &self,
            ) -> <startLeavingCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for startLeavingCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = startLeavingReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "startLeaving()";
            const SELECTOR: [u8; 4] = [135u8, 112u8, 53u8, 80u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                startLeavingReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = bool;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: supportsInterfaceReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `undelegate(address,uint256)` and selector `0x4d99dd16`.
```solidity
function undelegate(address operator, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct undelegateCall {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`undelegate(address,uint256)`](undelegateCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct undelegateReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<undelegateCall> for UnderlyingRustTuple<'_> {
                fn from(value: undelegateCall) -> Self {
                    (value.operator, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for undelegateCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<undelegateReturn> for UnderlyingRustTuple<'_> {
                fn from(value: undelegateReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for undelegateReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl undelegateReturn {
            fn _tokenize(
                &self,
            ) -> <undelegateCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for undelegateCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = undelegateReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "undelegate(address,uint256)";
            const SELECTOR: [u8; 4] = [77u8, 153u8, 221u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                undelegateReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall;
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl unpauseReturn {
            fn _tokenize(
                &self,
            ) -> <unpauseCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                unpauseReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl upgradeToAndCallReturn {
            fn _tokenize(
                &self,
            ) -> <upgradeToAndCallCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                upgradeToAndCallReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`MultiAssetDelegationExposed`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum MultiAssetDelegationExposedCalls {
        #[allow(missing_docs)]
        ADMIN_ROLE(ADMIN_ROLECall),
        #[allow(missing_docs)]
        ASSET_MANAGER_ROLE(ASSET_MANAGER_ROLECall),
        #[allow(missing_docs)]
        BPS_DENOMINATOR(BPS_DENOMINATORCall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        LOCK_ONE_MONTH(LOCK_ONE_MONTHCall),
        #[allow(missing_docs)]
        LOCK_SIX_MONTHS(LOCK_SIX_MONTHSCall),
        #[allow(missing_docs)]
        LOCK_THREE_MONTHS(LOCK_THREE_MONTHSCall),
        #[allow(missing_docs)]
        LOCK_TWO_MONTHS(LOCK_TWO_MONTHSCall),
        #[allow(missing_docs)]
        MULTIPLIER_NONE(MULTIPLIER_NONECall),
        #[allow(missing_docs)]
        MULTIPLIER_ONE_MONTH(MULTIPLIER_ONE_MONTHCall),
        #[allow(missing_docs)]
        MULTIPLIER_SIX_MONTHS(MULTIPLIER_SIX_MONTHSCall),
        #[allow(missing_docs)]
        MULTIPLIER_THREE_MONTHS(MULTIPLIER_THREE_MONTHSCall),
        #[allow(missing_docs)]
        MULTIPLIER_TWO_MONTHS(MULTIPLIER_TWO_MONTHSCall),
        #[allow(missing_docs)]
        PRECISION(PRECISIONCall),
        #[allow(missing_docs)]
        SLASHER_ROLE(SLASHER_ROLECall),
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        addBlueprint(addBlueprintCall),
        #[allow(missing_docs)]
        addBlueprintToDelegation(addBlueprintToDelegationCall),
        #[allow(missing_docs)]
        addSlasher(addSlasherCall),
        #[allow(missing_docs)]
        advanceRound(advanceRoundCall),
        #[allow(missing_docs)]
        blueprintPoolTotals(blueprintPoolTotalsCall),
        #[allow(missing_docs)]
        blueprintSlashCount(blueprintSlashCountCall),
        #[allow(missing_docs)]
        claimDelegatorRewards(claimDelegatorRewardsCall),
        #[allow(missing_docs)]
        claimOperatorRewards(claimOperatorRewardsCall),
        #[allow(missing_docs)]
        claimOperatorRewardsTo(claimOperatorRewardsToCall),
        #[allow(missing_docs)]
        completeLeaving(completeLeavingCall),
        #[allow(missing_docs)]
        currentRound(currentRoundCall),
        #[allow(missing_docs)]
        delegate(delegateCall),
        #[allow(missing_docs)]
        delegateWithOptions(delegateWithOptionsCall),
        #[allow(missing_docs)]
        delegationBondLessDelay(delegationBondLessDelayCall),
        #[allow(missing_docs)]
        deposit(depositCall),
        #[allow(missing_docs)]
        depositAndDelegate(depositAndDelegateCall),
        #[allow(missing_docs)]
        depositAndDelegateWithOptions(depositAndDelegateWithOptionsCall),
        #[allow(missing_docs)]
        depositERC20(depositERC20Call),
        #[allow(missing_docs)]
        depositERC20WithLock(depositERC20WithLockCall),
        #[allow(missing_docs)]
        depositWithLock(depositWithLockCall),
        #[allow(missing_docs)]
        disableAsset(disableAssetCall),
        #[allow(missing_docs)]
        enableAsset(enableAssetCall),
        #[allow(missing_docs)]
        enableAssetWithAdapter(enableAssetWithAdapterCall),
        #[allow(missing_docs)]
        executeDelegatorUnstake(executeDelegatorUnstakeCall),
        #[allow(missing_docs)]
        executeOperatorUnstake(executeOperatorUnstakeCall),
        #[allow(missing_docs)]
        executeWithdraw(executeWithdrawCall),
        #[allow(missing_docs)]
        getAssetAdapter(getAssetAdapterCall),
        #[allow(missing_docs)]
        getAssetConfig(getAssetConfigCall),
        #[allow(missing_docs)]
        getDelegation(getDelegationCall),
        #[allow(missing_docs)]
        getDelegationBlueprints(getDelegationBlueprintsCall),
        #[allow(missing_docs)]
        getDelegations(getDelegationsCall),
        #[allow(missing_docs)]
        getDeposit(getDepositCall),
        #[allow(missing_docs)]
        getLocks(getLocksCall),
        #[allow(missing_docs)]
        getOperatorBlueprints(getOperatorBlueprintsCall),
        #[allow(missing_docs)]
        getOperatorDelegatedStake(getOperatorDelegatedStakeCall),
        #[allow(missing_docs)]
        getOperatorDelegatorCount(getOperatorDelegatorCountCall),
        #[allow(missing_docs)]
        getOperatorDelegators(getOperatorDelegatorsCall),
        #[allow(missing_docs)]
        getOperatorMetadata(getOperatorMetadataCall),
        #[allow(missing_docs)]
        getOperatorRewardPool(getOperatorRewardPoolCall),
        #[allow(missing_docs)]
        getOperatorSelfStake(getOperatorSelfStakeCall),
        #[allow(missing_docs)]
        getOperatorSlashFactor(getOperatorSlashFactorCall),
        #[allow(missing_docs)]
        getOperatorStake(getOperatorStakeCall),
        #[allow(missing_docs)]
        getPendingDelegatorRewards(getPendingDelegatorRewardsCall),
        #[allow(missing_docs)]
        getPendingOperatorRewards(getPendingOperatorRewardsCall),
        #[allow(missing_docs)]
        getPendingUnstakes(getPendingUnstakesCall),
        #[allow(missing_docs)]
        getPendingWithdrawals(getPendingWithdrawalsCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getSlashCount(getSlashCountCall),
        #[allow(missing_docs)]
        getSlashCountForBlueprint(getSlashCountForBlueprintCall),
        #[allow(missing_docs)]
        getSlashCountForService(getSlashCountForServiceCall),
        #[allow(missing_docs)]
        getSlashImpact(getSlashImpactCall),
        #[allow(missing_docs)]
        getSlashRecord(getSlashRecordCall),
        #[allow(missing_docs)]
        getSnapshot(getSnapshotCall),
        #[allow(missing_docs)]
        getTotalDelegation(getTotalDelegationCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        increaseStake(increaseStakeCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        isOperator(isOperatorCall),
        #[allow(missing_docs)]
        isOperatorActive(isOperatorActiveCall),
        #[allow(missing_docs)]
        isSlasher(isSlasherCall),
        #[allow(missing_docs)]
        lastRoundAdvance(lastRoundAdvanceCall),
        #[allow(missing_docs)]
        leaveDelegatorsDelay(leaveDelegatorsDelayCall),
        #[allow(missing_docs)]
        leaveOperatorsDelay(leaveOperatorsDelayCall),
        #[allow(missing_docs)]
        meetsStakeRequirement(meetsStakeRequirementCall),
        #[allow(missing_docs)]
        minOperatorStake(minOperatorStakeCall),
        #[allow(missing_docs)]
        nativeEnabled(nativeEnabledCall),
        #[allow(missing_docs)]
        nextSlashId(nextSlashIdCall),
        #[allow(missing_docs)]
        notifyReward(notifyRewardCall),
        #[allow(missing_docs)]
        notifyRewardForBlueprint(notifyRewardForBlueprintCall),
        #[allow(missing_docs)]
        operatorAt(operatorAtCall),
        #[allow(missing_docs)]
        operatorCommissionBps(operatorCommissionBpsCall),
        #[allow(missing_docs)]
        operatorCount(operatorCountCall),
        #[allow(missing_docs)]
        operatorStake(operatorStakeCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        registerAdapter(registerAdapterCall),
        #[allow(missing_docs)]
        registerOperator(registerOperatorCall),
        #[allow(missing_docs)]
        registerOperatorWithAsset(registerOperatorWithAssetCall),
        #[allow(missing_docs)]
        removeAdapter(removeAdapterCall),
        #[allow(missing_docs)]
        removeBlueprint(removeBlueprintCall),
        #[allow(missing_docs)]
        removeBlueprintFromDelegation(removeBlueprintFromDelegationCall),
        #[allow(missing_docs)]
        removeSlasher(removeSlasherCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        requireAdapters(requireAdaptersCall),
        #[allow(missing_docs)]
        rescueTokens(rescueTokensCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        rewardPoolTotals(rewardPoolTotalsCall),
        #[allow(missing_docs)]
        rewardsManager(rewardsManagerCall),
        #[allow(missing_docs)]
        roundDuration(roundDurationCall),
        #[allow(missing_docs)]
        scheduleDelegatorUnstake(scheduleDelegatorUnstakeCall),
        #[allow(missing_docs)]
        scheduleOperatorUnstake(scheduleOperatorUnstakeCall),
        #[allow(missing_docs)]
        scheduleWithdraw(scheduleWithdrawCall),
        #[allow(missing_docs)]
        serviceFeeDistributor(serviceFeeDistributorCall),
        #[allow(missing_docs)]
        serviceSlashCount(serviceSlashCountCall),
        #[allow(missing_docs)]
        setDelays(setDelaysCall),
        #[allow(missing_docs)]
        setOperatorCommission(setOperatorCommissionCall),
        #[allow(missing_docs)]
        setRequireAdapters(setRequireAdaptersCall),
        #[allow(missing_docs)]
        setRewardsManager(setRewardsManagerCall),
        #[allow(missing_docs)]
        setServiceFeeDistributor(setServiceFeeDistributorCall),
        #[allow(missing_docs)]
        slash(slashCall),
        #[allow(missing_docs)]
        slashForBlueprint(slashForBlueprintCall),
        #[allow(missing_docs)]
        slashForService(slashForServiceCall),
        #[allow(missing_docs)]
        slashHistory(slashHistoryCall),
        #[allow(missing_docs)]
        snapshotOperator(snapshotOperatorCall),
        #[allow(missing_docs)]
        startLeaving(startLeavingCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        undelegate(undelegateCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
    }
    impl MultiAssetDelegationExposedCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 121u8, 16u8, 208u8],
            [1u8, 255u8, 201u8, 167u8],
            [2u8, 110u8, 64u8, 43u8],
            [3u8, 88u8, 124u8, 29u8],
            [3u8, 120u8, 2u8, 17u8],
            [5u8, 214u8, 78u8, 56u8],
            [10u8, 141u8, 220u8, 94u8],
            [10u8, 168u8, 177u8, 16u8],
            [12u8, 136u8, 51u8, 206u8],
            [21u8, 4u8, 154u8, 90u8],
            [22u8, 143u8, 104u8, 101u8],
            [24u8, 5u8, 109u8, 194u8],
            [27u8, 169u8, 153u8, 139u8],
            [35u8, 204u8, 39u8, 0u8],
            [36u8, 138u8, 156u8, 163u8],
            [38u8, 20u8, 35u8, 53u8],
            [40u8, 231u8, 14u8, 204u8],
            [42u8, 205u8, 224u8, 152u8],
            [46u8, 64u8, 247u8, 251u8],
            [46u8, 230u8, 99u8, 184u8],
            [47u8, 47u8, 241u8, 93u8],
            [48u8, 34u8, 79u8, 200u8],
            [49u8, 204u8, 19u8, 186u8],
            [50u8, 39u8, 63u8, 97u8],
            [53u8, 78u8, 190u8, 249u8],
            [53u8, 105u8, 36u8, 234u8],
            [54u8, 86u8, 138u8, 190u8],
            [61u8, 202u8, 217u8, 219u8],
            [63u8, 75u8, 168u8, 58u8],
            [68u8, 175u8, 242u8, 82u8],
            [68u8, 209u8, 72u8, 11u8],
            [69u8, 62u8, 204u8, 234u8],
            [70u8, 28u8, 194u8, 59u8],
            [72u8, 99u8, 152u8, 195u8],
            [73u8, 98u8, 248u8, 143u8],
            [76u8, 78u8, 222u8, 45u8],
            [77u8, 153u8, 221u8, 22u8],
            [77u8, 232u8, 173u8, 220u8],
            [78u8, 156u8, 146u8, 154u8],
            [79u8, 30u8, 242u8, 134u8],
            [80u8, 149u8, 175u8, 100u8],
            [82u8, 209u8, 144u8, 45u8],
            [84u8, 222u8, 35u8, 32u8],
            [87u8, 34u8, 213u8, 18u8],
            [87u8, 96u8, 28u8, 93u8],
            [88u8, 92u8, 211u8, 75u8],
            [92u8, 151u8, 90u8, 187u8],
            [95u8, 220u8, 143u8, 45u8],
            [97u8, 93u8, 36u8, 222u8],
            [102u8, 195u8, 104u8, 117u8],
            [104u8, 169u8, 241u8, 156u8],
            [105u8, 125u8, 8u8, 249u8],
            [109u8, 112u8, 247u8, 174u8],
            [110u8, 195u8, 171u8, 103u8],
            [112u8, 128u8, 117u8, 40u8],
            [114u8, 181u8, 3u8, 45u8],
            [117u8, 178u8, 56u8, 252u8],
            [119u8, 171u8, 44u8, 243u8],
            [123u8, 118u8, 254u8, 94u8],
            [123u8, 153u8, 150u8, 197u8],
            [124u8, 111u8, 49u8, 88u8],
            [125u8, 105u8, 65u8, 198u8],
            [125u8, 249u8, 42u8, 218u8],
            [132u8, 86u8, 203u8, 89u8],
            [133u8, 156u8, 170u8, 24u8],
            [135u8, 112u8, 53u8, 80u8],
            [138u8, 25u8, 200u8, 188u8],
            [138u8, 127u8, 230u8, 15u8],
            [140u8, 91u8, 74u8, 231u8],
            [141u8, 121u8, 93u8, 80u8],
            [145u8, 209u8, 72u8, 84u8],
            [148u8, 148u8, 244u8, 38u8],
            [150u8, 8u8, 86u8, 115u8],
            [151u8, 34u8, 244u8, 185u8],
            [151u8, 254u8, 185u8, 38u8],
            [158u8, 135u8, 5u8, 133u8],
            [158u8, 140u8, 73u8, 212u8],
            [162u8, 23u8, 253u8, 223u8],
            [162u8, 153u8, 226u8, 152u8],
            [163u8, 185u8, 197u8, 194u8],
            [164u8, 87u8, 175u8, 61u8],
            [164u8, 179u8, 45u8, 232u8],
            [167u8, 250u8, 111u8, 152u8],
            [170u8, 198u8, 170u8, 156u8],
            [170u8, 245u8, 235u8, 104u8],
            [173u8, 60u8, 177u8, 204u8],
            [176u8, 223u8, 206u8, 6u8],
            [179u8, 155u8, 207u8, 63u8],
            [181u8, 75u8, 43u8, 158u8],
            [186u8, 5u8, 187u8, 245u8],
            [192u8, 116u8, 73u8, 226u8],
            [195u8, 80u8, 130u8, 169u8],
            [197u8, 80u8, 217u8, 56u8],
            [199u8, 53u8, 48u8, 37u8],
            [202u8, 221u8, 85u8, 12u8],
            [203u8, 21u8, 3u8, 139u8],
            [203u8, 182u8, 214u8, 189u8],
            [206u8, 169u8, 210u8, 111u8],
            [208u8, 227u8, 13u8, 176u8],
            [209u8, 115u8, 107u8, 167u8],
            [210u8, 122u8, 111u8, 6u8],
            [213u8, 71u8, 116u8, 31u8],
            [214u8, 85u8, 185u8, 42u8],
            [214u8, 115u8, 224u8, 185u8],
            [215u8, 117u8, 203u8, 97u8],
            [217u8, 226u8, 87u8, 239u8],
            [219u8, 138u8, 23u8, 58u8],
            [220u8, 151u8, 44u8, 204u8],
            [222u8, 254u8, 32u8, 83u8],
            [224u8, 165u8, 130u8, 91u8],
            [225u8, 164u8, 82u8, 24u8],
            [225u8, 238u8, 75u8, 204u8],
            [228u8, 232u8, 141u8, 232u8],
            [235u8, 71u8, 53u8, 51u8],
            [240u8, 181u8, 43u8, 180u8],
            [243u8, 64u8, 192u8, 208u8],
            [243u8, 140u8, 124u8, 78u8],
            [243u8, 196u8, 216u8, 160u8],
            [243u8, 201u8, 179u8, 17u8],
            [244u8, 105u8, 19u8, 187u8],
            [247u8, 203u8, 120u8, 154u8],
            [248u8, 253u8, 151u8, 149u8],
            [251u8, 204u8, 123u8, 61u8],
            [251u8, 236u8, 72u8, 97u8],
            [252u8, 94u8, 126u8, 9u8],
            [252u8, 138u8, 145u8, 175u8],
            [253u8, 125u8, 61u8, 188u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(executeDelegatorUnstake),
            ::core::stringify!(supportsInterface),
            ::core::stringify!(delegate),
            ::core::stringify!(getOperatorRewardPool),
            ::core::stringify!(setDelays),
            ::core::stringify!(lastRoundAdvance),
            ::core::stringify!(setRewardsManager),
            ::core::stringify!(slashHistory),
            ::core::stringify!(getLocks),
            ::core::stringify!(getDelegation),
            ::core::stringify!(getPendingDelegatorRewards),
            ::core::stringify!(MULTIPLIER_ONE_MONTH),
            ::core::stringify!(advanceRound),
            ::core::stringify!(addBlueprintToDelegation),
            ::core::stringify!(getRoleAdmin),
            ::core::stringify!(operatorAt),
            ::core::stringify!(removeBlueprint),
            ::core::stringify!(registerOperator),
            ::core::stringify!(serviceFeeDistributor),
            ::core::stringify!(getOperatorMetadata),
            ::core::stringify!(grantRole),
            ::core::stringify!(getPendingOperatorRewards),
            ::core::stringify!(getDelegations),
            ::core::stringify!(operatorCommissionBps),
            ::core::stringify!(enableAsset),
            ::core::stringify!(slash),
            ::core::stringify!(renounceRole),
            ::core::stringify!(notifyRewardForBlueprint),
            ::core::stringify!(unpause),
            ::core::stringify!(scheduleOperatorUnstake),
            ::core::stringify!(claimDelegatorRewards),
            ::core::stringify!(MULTIPLIER_SIX_MONTHS),
            ::core::stringify!(depositAndDelegate),
            ::core::stringify!(getOperatorDelegatorCount),
            ::core::stringify!(MULTIPLIER_NONE),
            ::core::stringify!(claimOperatorRewards),
            ::core::stringify!(undelegate),
            ::core::stringify!(leaveOperatorsDelay),
            ::core::stringify!(blueprintSlashCount),
            ::core::stringify!(upgradeToAndCall),
            ::core::stringify!(SLASHER_ROLE),
            ::core::stringify!(proxiableUUID),
            ::core::stringify!(MULTIPLIER_TWO_MONTHS),
            ::core::stringify!(getPendingUnstakes),
            ::core::stringify!(isSlasher),
            ::core::stringify!(removeAdapter),
            ::core::stringify!(paused),
            ::core::stringify!(blueprintPoolTotals),
            ::core::stringify!(getOperatorSlashFactor),
            ::core::stringify!(getSlashCount),
            ::core::stringify!(addSlasher),
            ::core::stringify!(rewardPoolTotals),
            ::core::stringify!(isOperator),
            ::core::stringify!(getAssetConfig),
            ::core::stringify!(disableAsset),
            ::core::stringify!(getSlashCountForService),
            ::core::stringify!(ADMIN_ROLE),
            ::core::stringify!(nativeEnabled),
            ::core::stringify!(setRequireAdapters),
            ::core::stringify!(getDelegationBlueprints),
            ::core::stringify!(operatorCount),
            ::core::stringify!(claimOperatorRewardsTo),
            ::core::stringify!(LOCK_TWO_MONTHS),
            ::core::stringify!(pause),
            ::core::stringify!(removeBlueprintFromDelegation),
            ::core::stringify!(startLeaving),
            ::core::stringify!(currentRound),
            ::core::stringify!(getAssetAdapter),
            ::core::stringify!(getOperatorDelegatedStake),
            ::core::stringify!(slashForBlueprint),
            ::core::stringify!(hasRole),
            ::core::stringify!(getSlashImpact),
            ::core::stringify!(nextSlashId),
            ::core::stringify!(serviceSlashCount),
            ::core::stringify!(depositERC20),
            ::core::stringify!(LOCK_ONE_MONTH),
            ::core::stringify!(slashForService),
            ::core::stringify!(DEFAULT_ADMIN_ROLE),
            ::core::stringify!(getOperatorDelegators),
            ::core::stringify!(notifyReward),
            ::core::stringify!(getSlashRecord),
            ::core::stringify!(ASSET_MANAGER_ROLE),
            ::core::stringify!(MULTIPLIER_THREE_MONTHS),
            ::core::stringify!(removeSlasher),
            ::core::stringify!(PRECISION),
            ::core::stringify!(UPGRADE_INTERFACE_VERSION),
            ::core::stringify!(executeOperatorUnstake),
            ::core::stringify!(operatorStake),
            ::core::stringify!(requireAdapters),
            ::core::stringify!(delegationBondLessDelay),
            ::core::stringify!(getSnapshot),
            ::core::stringify!(getDeposit),
            ::core::stringify!(getSlashCountForBlueprint),
            ::core::stringify!(addBlueprint),
            ::core::stringify!(snapshotOperator),
            ::core::stringify!(depositERC20WithLock),
            ::core::stringify!(initialize),
            ::core::stringify!(rescueTokens),
            ::core::stringify!(deposit),
            ::core::stringify!(completeLeaving),
            ::core::stringify!(LOCK_THREE_MONTHS),
            ::core::stringify!(revokeRole),
            ::core::stringify!(registerAdapter),
            ::core::stringify!(getOperatorSelfStake),
            ::core::stringify!(minOperatorStake),
            ::core::stringify!(increaseStake),
            ::core::stringify!(leaveDelegatorsDelay),
            ::core::stringify!(getOperatorBlueprints),
            ::core::stringify!(rewardsManager),
            ::core::stringify!(registerOperatorWithAsset),
            ::core::stringify!(BPS_DENOMINATOR),
            ::core::stringify!(scheduleWithdraw),
            ::core::stringify!(getOperatorStake),
            ::core::stringify!(isOperatorActive),
            ::core::stringify!(enableAssetWithAdapter),
            ::core::stringify!(getPendingWithdrawals),
            ::core::stringify!(depositWithLock),
            ::core::stringify!(setOperatorCommission),
            ::core::stringify!(LOCK_SIX_MONTHS),
            ::core::stringify!(meetsStakeRequirement),
            ::core::stringify!(roundDuration),
            ::core::stringify!(executeWithdraw),
            ::core::stringify!(setServiceFeeDistributor),
            ::core::stringify!(depositAndDelegateWithOptions),
            ::core::stringify!(getTotalDelegation),
            ::core::stringify!(scheduleDelegatorUnstake),
            ::core::stringify!(delegateWithOptions),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <executeDelegatorUnstakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <supportsInterfaceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <delegateCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorRewardPoolCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setDelaysCall as alloy_sol_types::SolCall>::SIGNATURE,
            <lastRoundAdvanceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setRewardsManagerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <slashHistoryCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getLocksCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getDelegationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getPendingDelegatorRewardsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <MULTIPLIER_ONE_MONTHCall as alloy_sol_types::SolCall>::SIGNATURE,
            <advanceRoundCall as alloy_sol_types::SolCall>::SIGNATURE,
            <addBlueprintToDelegationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getRoleAdminCall as alloy_sol_types::SolCall>::SIGNATURE,
            <operatorAtCall as alloy_sol_types::SolCall>::SIGNATURE,
            <removeBlueprintCall as alloy_sol_types::SolCall>::SIGNATURE,
            <registerOperatorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <serviceFeeDistributorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorMetadataCall as alloy_sol_types::SolCall>::SIGNATURE,
            <grantRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getPendingOperatorRewardsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getDelegationsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <operatorCommissionBpsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <enableAssetCall as alloy_sol_types::SolCall>::SIGNATURE,
            <slashCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <notifyRewardForBlueprintCall as alloy_sol_types::SolCall>::SIGNATURE,
            <unpauseCall as alloy_sol_types::SolCall>::SIGNATURE,
            <scheduleOperatorUnstakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimDelegatorRewardsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <MULTIPLIER_SIX_MONTHSCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositAndDelegateCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorDelegatorCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <MULTIPLIER_NONECall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimOperatorRewardsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <undelegateCall as alloy_sol_types::SolCall>::SIGNATURE,
            <leaveOperatorsDelayCall as alloy_sol_types::SolCall>::SIGNATURE,
            <blueprintSlashCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <upgradeToAndCallCall as alloy_sol_types::SolCall>::SIGNATURE,
            <SLASHER_ROLECall as alloy_sol_types::SolCall>::SIGNATURE,
            <proxiableUUIDCall as alloy_sol_types::SolCall>::SIGNATURE,
            <MULTIPLIER_TWO_MONTHSCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getPendingUnstakesCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isSlasherCall as alloy_sol_types::SolCall>::SIGNATURE,
            <removeAdapterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <pausedCall as alloy_sol_types::SolCall>::SIGNATURE,
            <blueprintPoolTotalsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorSlashFactorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getSlashCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <addSlasherCall as alloy_sol_types::SolCall>::SIGNATURE,
            <rewardPoolTotalsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isOperatorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getAssetConfigCall as alloy_sol_types::SolCall>::SIGNATURE,
            <disableAssetCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getSlashCountForServiceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ADMIN_ROLECall as alloy_sol_types::SolCall>::SIGNATURE,
            <nativeEnabledCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setRequireAdaptersCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getDelegationBlueprintsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <operatorCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimOperatorRewardsToCall as alloy_sol_types::SolCall>::SIGNATURE,
            <LOCK_TWO_MONTHSCall as alloy_sol_types::SolCall>::SIGNATURE,
            <pauseCall as alloy_sol_types::SolCall>::SIGNATURE,
            <removeBlueprintFromDelegationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <startLeavingCall as alloy_sol_types::SolCall>::SIGNATURE,
            <currentRoundCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getAssetAdapterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorDelegatedStakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <slashForBlueprintCall as alloy_sol_types::SolCall>::SIGNATURE,
            <hasRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getSlashImpactCall as alloy_sol_types::SolCall>::SIGNATURE,
            <nextSlashIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <serviceSlashCountCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositERC20Call as alloy_sol_types::SolCall>::SIGNATURE,
            <LOCK_ONE_MONTHCall as alloy_sol_types::SolCall>::SIGNATURE,
            <slashForServiceCall as alloy_sol_types::SolCall>::SIGNATURE,
            <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorDelegatorsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <notifyRewardCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getSlashRecordCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ASSET_MANAGER_ROLECall as alloy_sol_types::SolCall>::SIGNATURE,
            <MULTIPLIER_THREE_MONTHSCall as alloy_sol_types::SolCall>::SIGNATURE,
            <removeSlasherCall as alloy_sol_types::SolCall>::SIGNATURE,
            <PRECISIONCall as alloy_sol_types::SolCall>::SIGNATURE,
            <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SIGNATURE,
            <executeOperatorUnstakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <operatorStakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <requireAdaptersCall as alloy_sol_types::SolCall>::SIGNATURE,
            <delegationBondLessDelayCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getSnapshotCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getDepositCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getSlashCountForBlueprintCall as alloy_sol_types::SolCall>::SIGNATURE,
            <addBlueprintCall as alloy_sol_types::SolCall>::SIGNATURE,
            <snapshotOperatorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositERC20WithLockCall as alloy_sol_types::SolCall>::SIGNATURE,
            <initializeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <rescueTokensCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositCall as alloy_sol_types::SolCall>::SIGNATURE,
            <completeLeavingCall as alloy_sol_types::SolCall>::SIGNATURE,
            <LOCK_THREE_MONTHSCall as alloy_sol_types::SolCall>::SIGNATURE,
            <revokeRoleCall as alloy_sol_types::SolCall>::SIGNATURE,
            <registerAdapterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorSelfStakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <minOperatorStakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <increaseStakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <leaveDelegatorsDelayCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorBlueprintsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <rewardsManagerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <registerOperatorWithAssetCall as alloy_sol_types::SolCall>::SIGNATURE,
            <BPS_DENOMINATORCall as alloy_sol_types::SolCall>::SIGNATURE,
            <scheduleWithdrawCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getOperatorStakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <isOperatorActiveCall as alloy_sol_types::SolCall>::SIGNATURE,
            <enableAssetWithAdapterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getPendingWithdrawalsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositWithLockCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setOperatorCommissionCall as alloy_sol_types::SolCall>::SIGNATURE,
            <LOCK_SIX_MONTHSCall as alloy_sol_types::SolCall>::SIGNATURE,
            <meetsStakeRequirementCall as alloy_sol_types::SolCall>::SIGNATURE,
            <roundDurationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <executeWithdrawCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setServiceFeeDistributorCall as alloy_sol_types::SolCall>::SIGNATURE,
            <depositAndDelegateWithOptionsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getTotalDelegationCall as alloy_sol_types::SolCall>::SIGNATURE,
            <scheduleDelegatorUnstakeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <delegateWithOptionsCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MultiAssetDelegationExposedCalls {
        const NAME: &'static str = "MultiAssetDelegationExposedCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 127usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ADMIN_ROLE(_) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::ASSET_MANAGER_ROLE(_) => {
                    <ASSET_MANAGER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::BPS_DENOMINATOR(_) => {
                    <BPS_DENOMINATORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LOCK_ONE_MONTH(_) => {
                    <LOCK_ONE_MONTHCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LOCK_SIX_MONTHS(_) => {
                    <LOCK_SIX_MONTHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LOCK_THREE_MONTHS(_) => {
                    <LOCK_THREE_MONTHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::LOCK_TWO_MONTHS(_) => {
                    <LOCK_TWO_MONTHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MULTIPLIER_NONE(_) => {
                    <MULTIPLIER_NONECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MULTIPLIER_ONE_MONTH(_) => {
                    <MULTIPLIER_ONE_MONTHCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MULTIPLIER_SIX_MONTHS(_) => {
                    <MULTIPLIER_SIX_MONTHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MULTIPLIER_THREE_MONTHS(_) => {
                    <MULTIPLIER_THREE_MONTHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::MULTIPLIER_TWO_MONTHS(_) => {
                    <MULTIPLIER_TWO_MONTHSCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PRECISION(_) => {
                    <PRECISIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SLASHER_ROLE(_) => {
                    <SLASHER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addBlueprint(_) => {
                    <addBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addBlueprintToDelegation(_) => {
                    <addBlueprintToDelegationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addSlasher(_) => {
                    <addSlasherCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::advanceRound(_) => {
                    <advanceRoundCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::blueprintPoolTotals(_) => {
                    <blueprintPoolTotalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::blueprintSlashCount(_) => {
                    <blueprintSlashCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimDelegatorRewards(_) => {
                    <claimDelegatorRewardsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimOperatorRewards(_) => {
                    <claimOperatorRewardsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimOperatorRewardsTo(_) => {
                    <claimOperatorRewardsToCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::completeLeaving(_) => {
                    <completeLeavingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::currentRound(_) => {
                    <currentRoundCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::delegate(_) => <delegateCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegateWithOptions(_) => {
                    <delegateWithOptionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::delegationBondLessDelay(_) => {
                    <delegationBondLessDelayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deposit(_) => <depositCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::depositAndDelegate(_) => {
                    <depositAndDelegateCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositAndDelegateWithOptions(_) => {
                    <depositAndDelegateWithOptionsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositERC20(_) => {
                    <depositERC20Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositERC20WithLock(_) => {
                    <depositERC20WithLockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::depositWithLock(_) => {
                    <depositWithLockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::disableAsset(_) => {
                    <disableAssetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enableAsset(_) => {
                    <enableAssetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::enableAssetWithAdapter(_) => {
                    <enableAssetWithAdapterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::executeDelegatorUnstake(_) => {
                    <executeDelegatorUnstakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::executeOperatorUnstake(_) => {
                    <executeOperatorUnstakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::executeWithdraw(_) => {
                    <executeWithdrawCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAssetAdapter(_) => {
                    <getAssetAdapterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getAssetConfig(_) => {
                    <getAssetConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDelegation(_) => {
                    <getDelegationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDelegationBlueprints(_) => {
                    <getDelegationBlueprintsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDelegations(_) => {
                    <getDelegationsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getDeposit(_) => {
                    <getDepositCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getLocks(_) => <getLocksCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperatorBlueprints(_) => {
                    <getOperatorBlueprintsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorDelegatedStake(_) => {
                    <getOperatorDelegatedStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorDelegatorCount(_) => {
                    <getOperatorDelegatorCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorDelegators(_) => {
                    <getOperatorDelegatorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorMetadata(_) => {
                    <getOperatorMetadataCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorRewardPool(_) => {
                    <getOperatorRewardPoolCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorSelfStake(_) => {
                    <getOperatorSelfStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorSlashFactor(_) => {
                    <getOperatorSlashFactorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorStake(_) => {
                    <getOperatorStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPendingDelegatorRewards(_) => {
                    <getPendingDelegatorRewardsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPendingOperatorRewards(_) => {
                    <getPendingOperatorRewardsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPendingUnstakes(_) => {
                    <getPendingUnstakesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getPendingWithdrawals(_) => {
                    <getPendingWithdrawalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSlashCount(_) => {
                    <getSlashCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSlashCountForBlueprint(_) => {
                    <getSlashCountForBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSlashCountForService(_) => {
                    <getSlashCountForServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSlashImpact(_) => {
                    <getSlashImpactCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSlashRecord(_) => {
                    <getSlashRecordCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSnapshot(_) => {
                    <getSnapshotCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTotalDelegation(_) => {
                    <getTotalDelegationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::increaseStake(_) => {
                    <increaseStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isOperator(_) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isOperatorActive(_) => {
                    <isOperatorActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isSlasher(_) => {
                    <isSlasherCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::lastRoundAdvance(_) => {
                    <lastRoundAdvanceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leaveDelegatorsDelay(_) => {
                    <leaveDelegatorsDelayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leaveOperatorsDelay(_) => {
                    <leaveOperatorsDelayCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::meetsStakeRequirement(_) => {
                    <meetsStakeRequirementCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::minOperatorStake(_) => {
                    <minOperatorStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nativeEnabled(_) => {
                    <nativeEnabledCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::nextSlashId(_) => {
                    <nextSlashIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::notifyReward(_) => {
                    <notifyRewardCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::notifyRewardForBlueprint(_) => {
                    <notifyRewardForBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::operatorAt(_) => {
                    <operatorAtCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::operatorCommissionBps(_) => {
                    <operatorCommissionBpsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::operatorCount(_) => {
                    <operatorCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::operatorStake(_) => {
                    <operatorStakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::registerAdapter(_) => {
                    <registerAdapterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::registerOperator(_) => {
                    <registerOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::registerOperatorWithAsset(_) => {
                    <registerOperatorWithAssetCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeAdapter(_) => {
                    <removeAdapterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeBlueprint(_) => {
                    <removeBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeBlueprintFromDelegation(_) => {
                    <removeBlueprintFromDelegationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removeSlasher(_) => {
                    <removeSlasherCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requireAdapters(_) => {
                    <requireAdaptersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rescueTokens(_) => {
                    <rescueTokensCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rewardPoolTotals(_) => {
                    <rewardPoolTotalsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rewardsManager(_) => {
                    <rewardsManagerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::roundDuration(_) => {
                    <roundDurationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::scheduleDelegatorUnstake(_) => {
                    <scheduleDelegatorUnstakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::scheduleOperatorUnstake(_) => {
                    <scheduleOperatorUnstakeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::scheduleWithdraw(_) => {
                    <scheduleWithdrawCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serviceFeeDistributor(_) => {
                    <serviceFeeDistributorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serviceSlashCount(_) => {
                    <serviceSlashCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setDelays(_) => {
                    <setDelaysCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setOperatorCommission(_) => {
                    <setOperatorCommissionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRequireAdapters(_) => {
                    <setRequireAdaptersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRewardsManager(_) => {
                    <setRewardsManagerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setServiceFeeDistributor(_) => {
                    <setServiceFeeDistributorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::slash(_) => <slashCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::slashForBlueprint(_) => {
                    <slashForBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::slashForService(_) => {
                    <slashForServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::slashHistory(_) => {
                    <slashHistoryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::snapshotOperator(_) => {
                    <snapshotOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::startLeaving(_) => {
                    <startLeavingCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::undelegate(_) => {
                    <undelegateCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls>] = &[
                {
                    fn executeDelegatorUnstake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <executeDelegatorUnstakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::executeDelegatorUnstake,
                            )
                    }
                    executeDelegatorUnstake
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn delegate(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <delegateCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::delegate)
                    }
                    delegate
                },
                {
                    fn getOperatorRewardPool(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorRewardPoolCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorRewardPool)
                    }
                    getOperatorRewardPool
                },
                {
                    fn setDelays(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setDelaysCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::setDelays)
                    }
                    setDelays
                },
                {
                    fn lastRoundAdvance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <lastRoundAdvanceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::lastRoundAdvance)
                    }
                    lastRoundAdvance
                },
                {
                    fn setRewardsManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setRewardsManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::setRewardsManager)
                    }
                    setRewardsManager
                },
                {
                    fn slashHistory(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <slashHistoryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::slashHistory)
                    }
                    slashHistory
                },
                {
                    fn getLocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getLocksCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::getLocks)
                    }
                    getLocks
                },
                {
                    fn getDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getDelegation)
                    }
                    getDelegation
                },
                {
                    fn getPendingDelegatorRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getPendingDelegatorRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getPendingDelegatorRewards,
                            )
                    }
                    getPendingDelegatorRewards
                },
                {
                    fn MULTIPLIER_ONE_MONTH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_ONE_MONTHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::MULTIPLIER_ONE_MONTH)
                    }
                    MULTIPLIER_ONE_MONTH
                },
                {
                    fn advanceRound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <advanceRoundCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::advanceRound)
                    }
                    advanceRound
                },
                {
                    fn addBlueprintToDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <addBlueprintToDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::addBlueprintToDelegation,
                            )
                    }
                    addBlueprintToDelegation
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn operatorAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <operatorAtCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::operatorAt)
                    }
                    operatorAt
                },
                {
                    fn removeBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <removeBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::removeBlueprint)
                    }
                    removeBlueprint
                },
                {
                    fn registerOperator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <registerOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::registerOperator)
                    }
                    registerOperator
                },
                {
                    fn serviceFeeDistributor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <serviceFeeDistributorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::serviceFeeDistributor)
                    }
                    serviceFeeDistributor
                },
                {
                    fn getOperatorMetadata(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorMetadataCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorMetadata)
                    }
                    getOperatorMetadata
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn getPendingOperatorRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getPendingOperatorRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getPendingOperatorRewards,
                            )
                    }
                    getPendingOperatorRewards
                },
                {
                    fn getDelegations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getDelegationsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getDelegations)
                    }
                    getDelegations
                },
                {
                    fn operatorCommissionBps(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <operatorCommissionBpsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::operatorCommissionBps)
                    }
                    operatorCommissionBps
                },
                {
                    fn enableAsset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <enableAssetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::enableAsset)
                    }
                    enableAsset
                },
                {
                    fn slash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <slashCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::slash)
                    }
                    slash
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn notifyRewardForBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <notifyRewardForBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::notifyRewardForBlueprint,
                            )
                    }
                    notifyRewardForBlueprint
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::unpause)
                    }
                    unpause
                },
                {
                    fn scheduleOperatorUnstake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <scheduleOperatorUnstakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::scheduleOperatorUnstake,
                            )
                    }
                    scheduleOperatorUnstake
                },
                {
                    fn claimDelegatorRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <claimDelegatorRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::claimDelegatorRewards)
                    }
                    claimDelegatorRewards
                },
                {
                    fn MULTIPLIER_SIX_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_SIX_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::MULTIPLIER_SIX_MONTHS)
                    }
                    MULTIPLIER_SIX_MONTHS
                },
                {
                    fn depositAndDelegate(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositAndDelegateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::depositAndDelegate)
                    }
                    depositAndDelegate
                },
                {
                    fn getOperatorDelegatorCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorDelegatorCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getOperatorDelegatorCount,
                            )
                    }
                    getOperatorDelegatorCount
                },
                {
                    fn MULTIPLIER_NONE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_NONECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::MULTIPLIER_NONE)
                    }
                    MULTIPLIER_NONE
                },
                {
                    fn claimOperatorRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <claimOperatorRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::claimOperatorRewards)
                    }
                    claimOperatorRewards
                },
                {
                    fn undelegate(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <undelegateCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::undelegate)
                    }
                    undelegate
                },
                {
                    fn leaveOperatorsDelay(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <leaveOperatorsDelayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::leaveOperatorsDelay)
                    }
                    leaveOperatorsDelay
                },
                {
                    fn blueprintSlashCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <blueprintSlashCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::blueprintSlashCount)
                    }
                    blueprintSlashCount
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn SLASHER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <SLASHER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::SLASHER_ROLE)
                    }
                    SLASHER_ROLE
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn MULTIPLIER_TWO_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_TWO_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::MULTIPLIER_TWO_MONTHS)
                    }
                    MULTIPLIER_TWO_MONTHS
                },
                {
                    fn getPendingUnstakes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getPendingUnstakesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getPendingUnstakes)
                    }
                    getPendingUnstakes
                },
                {
                    fn isSlasher(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <isSlasherCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::isSlasher)
                    }
                    isSlasher
                },
                {
                    fn removeAdapter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <removeAdapterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::removeAdapter)
                    }
                    removeAdapter
                },
                {
                    fn paused(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::paused)
                    }
                    paused
                },
                {
                    fn blueprintPoolTotals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <blueprintPoolTotalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::blueprintPoolTotals)
                    }
                    blueprintPoolTotals
                },
                {
                    fn getOperatorSlashFactor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorSlashFactorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getOperatorSlashFactor,
                            )
                    }
                    getOperatorSlashFactor
                },
                {
                    fn getSlashCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getSlashCount)
                    }
                    getSlashCount
                },
                {
                    fn addSlasher(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <addSlasherCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::addSlasher)
                    }
                    addSlasher
                },
                {
                    fn rewardPoolTotals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <rewardPoolTotalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::rewardPoolTotals)
                    }
                    rewardPoolTotals
                },
                {
                    fn isOperator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <isOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::isOperator)
                    }
                    isOperator
                },
                {
                    fn getAssetConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getAssetConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getAssetConfig)
                    }
                    getAssetConfig
                },
                {
                    fn disableAsset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <disableAssetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::disableAsset)
                    }
                    disableAsset
                },
                {
                    fn getSlashCountForService(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashCountForServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getSlashCountForService,
                            )
                    }
                    getSlashCountForService
                },
                {
                    fn ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::ADMIN_ROLE)
                    }
                    ADMIN_ROLE
                },
                {
                    fn nativeEnabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <nativeEnabledCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::nativeEnabled)
                    }
                    nativeEnabled
                },
                {
                    fn setRequireAdapters(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setRequireAdaptersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::setRequireAdapters)
                    }
                    setRequireAdapters
                },
                {
                    fn getDelegationBlueprints(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getDelegationBlueprintsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getDelegationBlueprints,
                            )
                    }
                    getDelegationBlueprints
                },
                {
                    fn operatorCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <operatorCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::operatorCount)
                    }
                    operatorCount
                },
                {
                    fn claimOperatorRewardsTo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <claimOperatorRewardsToCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::claimOperatorRewardsTo,
                            )
                    }
                    claimOperatorRewardsTo
                },
                {
                    fn LOCK_TWO_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <LOCK_TWO_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::LOCK_TWO_MONTHS)
                    }
                    LOCK_TWO_MONTHS
                },
                {
                    fn pause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::pause)
                    }
                    pause
                },
                {
                    fn removeBlueprintFromDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <removeBlueprintFromDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::removeBlueprintFromDelegation,
                            )
                    }
                    removeBlueprintFromDelegation
                },
                {
                    fn startLeaving(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <startLeavingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::startLeaving)
                    }
                    startLeaving
                },
                {
                    fn currentRound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <currentRoundCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::currentRound)
                    }
                    currentRound
                },
                {
                    fn getAssetAdapter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getAssetAdapterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getAssetAdapter)
                    }
                    getAssetAdapter
                },
                {
                    fn getOperatorDelegatedStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorDelegatedStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getOperatorDelegatedStake,
                            )
                    }
                    getOperatorDelegatedStake
                },
                {
                    fn slashForBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <slashForBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::slashForBlueprint)
                    }
                    slashForBlueprint
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn getSlashImpact(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashImpactCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getSlashImpact)
                    }
                    getSlashImpact
                },
                {
                    fn nextSlashId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <nextSlashIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::nextSlashId)
                    }
                    nextSlashId
                },
                {
                    fn serviceSlashCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <serviceSlashCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::serviceSlashCount)
                    }
                    serviceSlashCount
                },
                {
                    fn depositERC20(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositERC20Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::depositERC20)
                    }
                    depositERC20
                },
                {
                    fn LOCK_ONE_MONTH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <LOCK_ONE_MONTHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::LOCK_ONE_MONTH)
                    }
                    LOCK_ONE_MONTH
                },
                {
                    fn slashForService(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <slashForServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::slashForService)
                    }
                    slashForService
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn getOperatorDelegators(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorDelegatorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorDelegators)
                    }
                    getOperatorDelegators
                },
                {
                    fn notifyReward(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <notifyRewardCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::notifyReward)
                    }
                    notifyReward
                },
                {
                    fn getSlashRecord(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashRecordCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getSlashRecord)
                    }
                    getSlashRecord
                },
                {
                    fn ASSET_MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <ASSET_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::ASSET_MANAGER_ROLE)
                    }
                    ASSET_MANAGER_ROLE
                },
                {
                    fn MULTIPLIER_THREE_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_THREE_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::MULTIPLIER_THREE_MONTHS,
                            )
                    }
                    MULTIPLIER_THREE_MONTHS
                },
                {
                    fn removeSlasher(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <removeSlasherCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::removeSlasher)
                    }
                    removeSlasher
                },
                {
                    fn PRECISION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <PRECISIONCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::PRECISION)
                    }
                    PRECISION
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::UPGRADE_INTERFACE_VERSION,
                            )
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn executeOperatorUnstake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <executeOperatorUnstakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::executeOperatorUnstake,
                            )
                    }
                    executeOperatorUnstake
                },
                {
                    fn operatorStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <operatorStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::operatorStake)
                    }
                    operatorStake
                },
                {
                    fn requireAdapters(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <requireAdaptersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::requireAdapters)
                    }
                    requireAdapters
                },
                {
                    fn delegationBondLessDelay(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <delegationBondLessDelayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::delegationBondLessDelay,
                            )
                    }
                    delegationBondLessDelay
                },
                {
                    fn getSnapshot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSnapshotCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getSnapshot)
                    }
                    getSnapshot
                },
                {
                    fn getDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getDepositCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getDeposit)
                    }
                    getDeposit
                },
                {
                    fn getSlashCountForBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashCountForBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getSlashCountForBlueprint,
                            )
                    }
                    getSlashCountForBlueprint
                },
                {
                    fn addBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <addBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::addBlueprint)
                    }
                    addBlueprint
                },
                {
                    fn snapshotOperator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <snapshotOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::snapshotOperator)
                    }
                    snapshotOperator
                },
                {
                    fn depositERC20WithLock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositERC20WithLockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::depositERC20WithLock)
                    }
                    depositERC20WithLock
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::initialize)
                    }
                    initialize
                },
                {
                    fn rescueTokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <rescueTokensCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::rescueTokens)
                    }
                    rescueTokens
                },
                {
                    fn deposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedCalls::deposit)
                    }
                    deposit
                },
                {
                    fn completeLeaving(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <completeLeavingCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::completeLeaving)
                    }
                    completeLeaving
                },
                {
                    fn LOCK_THREE_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <LOCK_THREE_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::LOCK_THREE_MONTHS)
                    }
                    LOCK_THREE_MONTHS
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn registerAdapter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <registerAdapterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::registerAdapter)
                    }
                    registerAdapter
                },
                {
                    fn getOperatorSelfStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorSelfStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorSelfStake)
                    }
                    getOperatorSelfStake
                },
                {
                    fn minOperatorStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <minOperatorStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::minOperatorStake)
                    }
                    minOperatorStake
                },
                {
                    fn increaseStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <increaseStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::increaseStake)
                    }
                    increaseStake
                },
                {
                    fn leaveDelegatorsDelay(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <leaveDelegatorsDelayCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::leaveDelegatorsDelay)
                    }
                    leaveDelegatorsDelay
                },
                {
                    fn getOperatorBlueprints(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorBlueprintsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorBlueprints)
                    }
                    getOperatorBlueprints
                },
                {
                    fn rewardsManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <rewardsManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::rewardsManager)
                    }
                    rewardsManager
                },
                {
                    fn registerOperatorWithAsset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <registerOperatorWithAssetCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::registerOperatorWithAsset,
                            )
                    }
                    registerOperatorWithAsset
                },
                {
                    fn BPS_DENOMINATOR(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <BPS_DENOMINATORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::BPS_DENOMINATOR)
                    }
                    BPS_DENOMINATOR
                },
                {
                    fn scheduleWithdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <scheduleWithdrawCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::scheduleWithdraw)
                    }
                    scheduleWithdraw
                },
                {
                    fn getOperatorStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorStakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorStake)
                    }
                    getOperatorStake
                },
                {
                    fn isOperatorActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <isOperatorActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::isOperatorActive)
                    }
                    isOperatorActive
                },
                {
                    fn enableAssetWithAdapter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <enableAssetWithAdapterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::enableAssetWithAdapter,
                            )
                    }
                    enableAssetWithAdapter
                },
                {
                    fn getPendingWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getPendingWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getPendingWithdrawals)
                    }
                    getPendingWithdrawals
                },
                {
                    fn depositWithLock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositWithLockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::depositWithLock)
                    }
                    depositWithLock
                },
                {
                    fn setOperatorCommission(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setOperatorCommissionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::setOperatorCommission)
                    }
                    setOperatorCommission
                },
                {
                    fn LOCK_SIX_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <LOCK_SIX_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::LOCK_SIX_MONTHS)
                    }
                    LOCK_SIX_MONTHS
                },
                {
                    fn meetsStakeRequirement(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <meetsStakeRequirementCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::meetsStakeRequirement)
                    }
                    meetsStakeRequirement
                },
                {
                    fn roundDuration(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <roundDurationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::roundDuration)
                    }
                    roundDuration
                },
                {
                    fn executeWithdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <executeWithdrawCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::executeWithdraw)
                    }
                    executeWithdraw
                },
                {
                    fn setServiceFeeDistributor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setServiceFeeDistributorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::setServiceFeeDistributor,
                            )
                    }
                    setServiceFeeDistributor
                },
                {
                    fn depositAndDelegateWithOptions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositAndDelegateWithOptionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::depositAndDelegateWithOptions,
                            )
                    }
                    depositAndDelegateWithOptions
                },
                {
                    fn getTotalDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getTotalDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getTotalDelegation)
                    }
                    getTotalDelegation
                },
                {
                    fn scheduleDelegatorUnstake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <scheduleDelegatorUnstakeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::scheduleDelegatorUnstake,
                            )
                    }
                    scheduleDelegatorUnstake
                },
                {
                    fn delegateWithOptions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <delegateWithOptionsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::delegateWithOptions)
                    }
                    delegateWithOptions
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls>] = &[
                {
                    fn executeDelegatorUnstake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <executeDelegatorUnstakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::executeDelegatorUnstake,
                            )
                    }
                    executeDelegatorUnstake
                },
                {
                    fn supportsInterface(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn delegate(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <delegateCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::delegate)
                    }
                    delegate
                },
                {
                    fn getOperatorRewardPool(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorRewardPoolCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorRewardPool)
                    }
                    getOperatorRewardPool
                },
                {
                    fn setDelays(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setDelaysCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::setDelays)
                    }
                    setDelays
                },
                {
                    fn lastRoundAdvance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <lastRoundAdvanceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::lastRoundAdvance)
                    }
                    lastRoundAdvance
                },
                {
                    fn setRewardsManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setRewardsManagerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::setRewardsManager)
                    }
                    setRewardsManager
                },
                {
                    fn slashHistory(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <slashHistoryCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::slashHistory)
                    }
                    slashHistory
                },
                {
                    fn getLocks(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getLocksCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getLocks)
                    }
                    getLocks
                },
                {
                    fn getDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getDelegation)
                    }
                    getDelegation
                },
                {
                    fn getPendingDelegatorRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getPendingDelegatorRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getPendingDelegatorRewards,
                            )
                    }
                    getPendingDelegatorRewards
                },
                {
                    fn MULTIPLIER_ONE_MONTH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_ONE_MONTHCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::MULTIPLIER_ONE_MONTH)
                    }
                    MULTIPLIER_ONE_MONTH
                },
                {
                    fn advanceRound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <advanceRoundCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::advanceRound)
                    }
                    advanceRound
                },
                {
                    fn addBlueprintToDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <addBlueprintToDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::addBlueprintToDelegation,
                            )
                    }
                    addBlueprintToDelegation
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn operatorAt(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <operatorAtCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::operatorAt)
                    }
                    operatorAt
                },
                {
                    fn removeBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <removeBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::removeBlueprint)
                    }
                    removeBlueprint
                },
                {
                    fn registerOperator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <registerOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::registerOperator)
                    }
                    registerOperator
                },
                {
                    fn serviceFeeDistributor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <serviceFeeDistributorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::serviceFeeDistributor)
                    }
                    serviceFeeDistributor
                },
                {
                    fn getOperatorMetadata(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorMetadataCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorMetadata)
                    }
                    getOperatorMetadata
                },
                {
                    fn grantRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn getPendingOperatorRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getPendingOperatorRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getPendingOperatorRewards,
                            )
                    }
                    getPendingOperatorRewards
                },
                {
                    fn getDelegations(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getDelegationsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getDelegations)
                    }
                    getDelegations
                },
                {
                    fn operatorCommissionBps(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <operatorCommissionBpsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::operatorCommissionBps)
                    }
                    operatorCommissionBps
                },
                {
                    fn enableAsset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <enableAssetCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::enableAsset)
                    }
                    enableAsset
                },
                {
                    fn slash(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <slashCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::slash)
                    }
                    slash
                },
                {
                    fn renounceRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn notifyRewardForBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <notifyRewardForBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::notifyRewardForBlueprint,
                            )
                    }
                    notifyRewardForBlueprint
                },
                {
                    fn unpause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::unpause)
                    }
                    unpause
                },
                {
                    fn scheduleOperatorUnstake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <scheduleOperatorUnstakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::scheduleOperatorUnstake,
                            )
                    }
                    scheduleOperatorUnstake
                },
                {
                    fn claimDelegatorRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <claimDelegatorRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::claimDelegatorRewards)
                    }
                    claimDelegatorRewards
                },
                {
                    fn MULTIPLIER_SIX_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_SIX_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::MULTIPLIER_SIX_MONTHS)
                    }
                    MULTIPLIER_SIX_MONTHS
                },
                {
                    fn depositAndDelegate(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositAndDelegateCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::depositAndDelegate)
                    }
                    depositAndDelegate
                },
                {
                    fn getOperatorDelegatorCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorDelegatorCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getOperatorDelegatorCount,
                            )
                    }
                    getOperatorDelegatorCount
                },
                {
                    fn MULTIPLIER_NONE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_NONECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::MULTIPLIER_NONE)
                    }
                    MULTIPLIER_NONE
                },
                {
                    fn claimOperatorRewards(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <claimOperatorRewardsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::claimOperatorRewards)
                    }
                    claimOperatorRewards
                },
                {
                    fn undelegate(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <undelegateCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::undelegate)
                    }
                    undelegate
                },
                {
                    fn leaveOperatorsDelay(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <leaveOperatorsDelayCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::leaveOperatorsDelay)
                    }
                    leaveOperatorsDelay
                },
                {
                    fn blueprintSlashCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <blueprintSlashCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::blueprintSlashCount)
                    }
                    blueprintSlashCount
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn SLASHER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <SLASHER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::SLASHER_ROLE)
                    }
                    SLASHER_ROLE
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn MULTIPLIER_TWO_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_TWO_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::MULTIPLIER_TWO_MONTHS)
                    }
                    MULTIPLIER_TWO_MONTHS
                },
                {
                    fn getPendingUnstakes(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getPendingUnstakesCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getPendingUnstakes)
                    }
                    getPendingUnstakes
                },
                {
                    fn isSlasher(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <isSlasherCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::isSlasher)
                    }
                    isSlasher
                },
                {
                    fn removeAdapter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <removeAdapterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::removeAdapter)
                    }
                    removeAdapter
                },
                {
                    fn paused(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::paused)
                    }
                    paused
                },
                {
                    fn blueprintPoolTotals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <blueprintPoolTotalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::blueprintPoolTotals)
                    }
                    blueprintPoolTotals
                },
                {
                    fn getOperatorSlashFactor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorSlashFactorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getOperatorSlashFactor,
                            )
                    }
                    getOperatorSlashFactor
                },
                {
                    fn getSlashCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getSlashCount)
                    }
                    getSlashCount
                },
                {
                    fn addSlasher(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <addSlasherCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::addSlasher)
                    }
                    addSlasher
                },
                {
                    fn rewardPoolTotals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <rewardPoolTotalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::rewardPoolTotals)
                    }
                    rewardPoolTotals
                },
                {
                    fn isOperator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <isOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::isOperator)
                    }
                    isOperator
                },
                {
                    fn getAssetConfig(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getAssetConfigCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getAssetConfig)
                    }
                    getAssetConfig
                },
                {
                    fn disableAsset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <disableAssetCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::disableAsset)
                    }
                    disableAsset
                },
                {
                    fn getSlashCountForService(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashCountForServiceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getSlashCountForService,
                            )
                    }
                    getSlashCountForService
                },
                {
                    fn ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::ADMIN_ROLE)
                    }
                    ADMIN_ROLE
                },
                {
                    fn nativeEnabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <nativeEnabledCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::nativeEnabled)
                    }
                    nativeEnabled
                },
                {
                    fn setRequireAdapters(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setRequireAdaptersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::setRequireAdapters)
                    }
                    setRequireAdapters
                },
                {
                    fn getDelegationBlueprints(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getDelegationBlueprintsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getDelegationBlueprints,
                            )
                    }
                    getDelegationBlueprints
                },
                {
                    fn operatorCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <operatorCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::operatorCount)
                    }
                    operatorCount
                },
                {
                    fn claimOperatorRewardsTo(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <claimOperatorRewardsToCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::claimOperatorRewardsTo,
                            )
                    }
                    claimOperatorRewardsTo
                },
                {
                    fn LOCK_TWO_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <LOCK_TWO_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::LOCK_TWO_MONTHS)
                    }
                    LOCK_TWO_MONTHS
                },
                {
                    fn pause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::pause)
                    }
                    pause
                },
                {
                    fn removeBlueprintFromDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <removeBlueprintFromDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::removeBlueprintFromDelegation,
                            )
                    }
                    removeBlueprintFromDelegation
                },
                {
                    fn startLeaving(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <startLeavingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::startLeaving)
                    }
                    startLeaving
                },
                {
                    fn currentRound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <currentRoundCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::currentRound)
                    }
                    currentRound
                },
                {
                    fn getAssetAdapter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getAssetAdapterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getAssetAdapter)
                    }
                    getAssetAdapter
                },
                {
                    fn getOperatorDelegatedStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorDelegatedStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getOperatorDelegatedStake,
                            )
                    }
                    getOperatorDelegatedStake
                },
                {
                    fn slashForBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <slashForBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::slashForBlueprint)
                    }
                    slashForBlueprint
                },
                {
                    fn hasRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn getSlashImpact(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashImpactCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getSlashImpact)
                    }
                    getSlashImpact
                },
                {
                    fn nextSlashId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <nextSlashIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::nextSlashId)
                    }
                    nextSlashId
                },
                {
                    fn serviceSlashCount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <serviceSlashCountCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::serviceSlashCount)
                    }
                    serviceSlashCount
                },
                {
                    fn depositERC20(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositERC20Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::depositERC20)
                    }
                    depositERC20
                },
                {
                    fn LOCK_ONE_MONTH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <LOCK_ONE_MONTHCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::LOCK_ONE_MONTH)
                    }
                    LOCK_ONE_MONTH
                },
                {
                    fn slashForService(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <slashForServiceCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::slashForService)
                    }
                    slashForService
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn getOperatorDelegators(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorDelegatorsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorDelegators)
                    }
                    getOperatorDelegators
                },
                {
                    fn notifyReward(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <notifyRewardCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::notifyReward)
                    }
                    notifyReward
                },
                {
                    fn getSlashRecord(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashRecordCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getSlashRecord)
                    }
                    getSlashRecord
                },
                {
                    fn ASSET_MANAGER_ROLE(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <ASSET_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::ASSET_MANAGER_ROLE)
                    }
                    ASSET_MANAGER_ROLE
                },
                {
                    fn MULTIPLIER_THREE_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <MULTIPLIER_THREE_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::MULTIPLIER_THREE_MONTHS,
                            )
                    }
                    MULTIPLIER_THREE_MONTHS
                },
                {
                    fn removeSlasher(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <removeSlasherCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::removeSlasher)
                    }
                    removeSlasher
                },
                {
                    fn PRECISION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <PRECISIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::PRECISION)
                    }
                    PRECISION
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::UPGRADE_INTERFACE_VERSION,
                            )
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn executeOperatorUnstake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <executeOperatorUnstakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::executeOperatorUnstake,
                            )
                    }
                    executeOperatorUnstake
                },
                {
                    fn operatorStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <operatorStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::operatorStake)
                    }
                    operatorStake
                },
                {
                    fn requireAdapters(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <requireAdaptersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::requireAdapters)
                    }
                    requireAdapters
                },
                {
                    fn delegationBondLessDelay(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <delegationBondLessDelayCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::delegationBondLessDelay,
                            )
                    }
                    delegationBondLessDelay
                },
                {
                    fn getSnapshot(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSnapshotCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getSnapshot)
                    }
                    getSnapshot
                },
                {
                    fn getDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getDepositCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getDeposit)
                    }
                    getDeposit
                },
                {
                    fn getSlashCountForBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getSlashCountForBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::getSlashCountForBlueprint,
                            )
                    }
                    getSlashCountForBlueprint
                },
                {
                    fn addBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <addBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::addBlueprint)
                    }
                    addBlueprint
                },
                {
                    fn snapshotOperator(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <snapshotOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::snapshotOperator)
                    }
                    snapshotOperator
                },
                {
                    fn depositERC20WithLock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositERC20WithLockCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::depositERC20WithLock)
                    }
                    depositERC20WithLock
                },
                {
                    fn initialize(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::initialize)
                    }
                    initialize
                },
                {
                    fn rescueTokens(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <rescueTokensCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::rescueTokens)
                    }
                    rescueTokens
                },
                {
                    fn deposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::deposit)
                    }
                    deposit
                },
                {
                    fn completeLeaving(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <completeLeavingCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::completeLeaving)
                    }
                    completeLeaving
                },
                {
                    fn LOCK_THREE_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <LOCK_THREE_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::LOCK_THREE_MONTHS)
                    }
                    LOCK_THREE_MONTHS
                },
                {
                    fn revokeRole(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn registerAdapter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <registerAdapterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::registerAdapter)
                    }
                    registerAdapter
                },
                {
                    fn getOperatorSelfStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorSelfStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorSelfStake)
                    }
                    getOperatorSelfStake
                },
                {
                    fn minOperatorStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <minOperatorStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::minOperatorStake)
                    }
                    minOperatorStake
                },
                {
                    fn increaseStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <increaseStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::increaseStake)
                    }
                    increaseStake
                },
                {
                    fn leaveDelegatorsDelay(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <leaveDelegatorsDelayCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::leaveDelegatorsDelay)
                    }
                    leaveDelegatorsDelay
                },
                {
                    fn getOperatorBlueprints(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorBlueprintsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorBlueprints)
                    }
                    getOperatorBlueprints
                },
                {
                    fn rewardsManager(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <rewardsManagerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::rewardsManager)
                    }
                    rewardsManager
                },
                {
                    fn registerOperatorWithAsset(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <registerOperatorWithAssetCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::registerOperatorWithAsset,
                            )
                    }
                    registerOperatorWithAsset
                },
                {
                    fn BPS_DENOMINATOR(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <BPS_DENOMINATORCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::BPS_DENOMINATOR)
                    }
                    BPS_DENOMINATOR
                },
                {
                    fn scheduleWithdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <scheduleWithdrawCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::scheduleWithdraw)
                    }
                    scheduleWithdraw
                },
                {
                    fn getOperatorStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getOperatorStakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getOperatorStake)
                    }
                    getOperatorStake
                },
                {
                    fn isOperatorActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <isOperatorActiveCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::isOperatorActive)
                    }
                    isOperatorActive
                },
                {
                    fn enableAssetWithAdapter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <enableAssetWithAdapterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::enableAssetWithAdapter,
                            )
                    }
                    enableAssetWithAdapter
                },
                {
                    fn getPendingWithdrawals(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getPendingWithdrawalsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getPendingWithdrawals)
                    }
                    getPendingWithdrawals
                },
                {
                    fn depositWithLock(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositWithLockCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::depositWithLock)
                    }
                    depositWithLock
                },
                {
                    fn setOperatorCommission(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setOperatorCommissionCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::setOperatorCommission)
                    }
                    setOperatorCommission
                },
                {
                    fn LOCK_SIX_MONTHS(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <LOCK_SIX_MONTHSCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::LOCK_SIX_MONTHS)
                    }
                    LOCK_SIX_MONTHS
                },
                {
                    fn meetsStakeRequirement(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <meetsStakeRequirementCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::meetsStakeRequirement)
                    }
                    meetsStakeRequirement
                },
                {
                    fn roundDuration(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <roundDurationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::roundDuration)
                    }
                    roundDuration
                },
                {
                    fn executeWithdraw(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <executeWithdrawCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::executeWithdraw)
                    }
                    executeWithdraw
                },
                {
                    fn setServiceFeeDistributor(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <setServiceFeeDistributorCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::setServiceFeeDistributor,
                            )
                    }
                    setServiceFeeDistributor
                },
                {
                    fn depositAndDelegateWithOptions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <depositAndDelegateWithOptionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::depositAndDelegateWithOptions,
                            )
                    }
                    depositAndDelegateWithOptions
                },
                {
                    fn getTotalDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <getTotalDelegationCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::getTotalDelegation)
                    }
                    getTotalDelegation
                },
                {
                    fn scheduleDelegatorUnstake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <scheduleDelegatorUnstakeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedCalls::scheduleDelegatorUnstake,
                            )
                    }
                    scheduleDelegatorUnstake
                },
                {
                    fn delegateWithOptions(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedCalls> {
                        <delegateWithOptionsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedCalls::delegateWithOptions)
                    }
                    delegateWithOptions
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ADMIN_ROLE(inner) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::ASSET_MANAGER_ROLE(inner) => {
                    <ASSET_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BPS_DENOMINATOR(inner) => {
                    <BPS_DENOMINATORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LOCK_ONE_MONTH(inner) => {
                    <LOCK_ONE_MONTHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LOCK_SIX_MONTHS(inner) => {
                    <LOCK_SIX_MONTHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LOCK_THREE_MONTHS(inner) => {
                    <LOCK_THREE_MONTHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LOCK_TWO_MONTHS(inner) => {
                    <LOCK_TWO_MONTHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MULTIPLIER_NONE(inner) => {
                    <MULTIPLIER_NONECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MULTIPLIER_ONE_MONTH(inner) => {
                    <MULTIPLIER_ONE_MONTHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MULTIPLIER_SIX_MONTHS(inner) => {
                    <MULTIPLIER_SIX_MONTHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MULTIPLIER_THREE_MONTHS(inner) => {
                    <MULTIPLIER_THREE_MONTHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MULTIPLIER_TWO_MONTHS(inner) => {
                    <MULTIPLIER_TWO_MONTHSCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PRECISION(inner) => {
                    <PRECISIONCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::SLASHER_ROLE(inner) => {
                    <SLASHER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addBlueprint(inner) => {
                    <addBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addBlueprintToDelegation(inner) => {
                    <addBlueprintToDelegationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addSlasher(inner) => {
                    <addSlasherCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::advanceRound(inner) => {
                    <advanceRoundCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::blueprintPoolTotals(inner) => {
                    <blueprintPoolTotalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::blueprintSlashCount(inner) => {
                    <blueprintSlashCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimDelegatorRewards(inner) => {
                    <claimDelegatorRewardsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimOperatorRewards(inner) => {
                    <claimOperatorRewardsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimOperatorRewardsTo(inner) => {
                    <claimOperatorRewardsToCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::completeLeaving(inner) => {
                    <completeLeavingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::currentRound(inner) => {
                    <currentRoundCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::delegateWithOptions(inner) => {
                    <delegateWithOptionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::delegationBondLessDelay(inner) => {
                    <delegationBondLessDelayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deposit(inner) => {
                    <depositCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::depositAndDelegate(inner) => {
                    <depositAndDelegateCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositAndDelegateWithOptions(inner) => {
                    <depositAndDelegateWithOptionsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositERC20(inner) => {
                    <depositERC20Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositERC20WithLock(inner) => {
                    <depositERC20WithLockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::depositWithLock(inner) => {
                    <depositWithLockCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::disableAsset(inner) => {
                    <disableAssetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enableAsset(inner) => {
                    <enableAssetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::enableAssetWithAdapter(inner) => {
                    <enableAssetWithAdapterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::executeDelegatorUnstake(inner) => {
                    <executeDelegatorUnstakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::executeOperatorUnstake(inner) => {
                    <executeOperatorUnstakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::executeWithdraw(inner) => {
                    <executeWithdrawCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAssetAdapter(inner) => {
                    <getAssetAdapterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getAssetConfig(inner) => {
                    <getAssetConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDelegation(inner) => {
                    <getDelegationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDelegationBlueprints(inner) => {
                    <getDelegationBlueprintsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDelegations(inner) => {
                    <getDelegationsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getDeposit(inner) => {
                    <getDepositCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getLocks(inner) => {
                    <getLocksCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getOperatorBlueprints(inner) => {
                    <getOperatorBlueprintsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorDelegatedStake(inner) => {
                    <getOperatorDelegatedStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorDelegatorCount(inner) => {
                    <getOperatorDelegatorCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorDelegators(inner) => {
                    <getOperatorDelegatorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorMetadata(inner) => {
                    <getOperatorMetadataCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorRewardPool(inner) => {
                    <getOperatorRewardPoolCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorSelfStake(inner) => {
                    <getOperatorSelfStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorSlashFactor(inner) => {
                    <getOperatorSlashFactorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorStake(inner) => {
                    <getOperatorStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPendingDelegatorRewards(inner) => {
                    <getPendingDelegatorRewardsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPendingOperatorRewards(inner) => {
                    <getPendingOperatorRewardsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPendingUnstakes(inner) => {
                    <getPendingUnstakesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getPendingWithdrawals(inner) => {
                    <getPendingWithdrawalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSlashCount(inner) => {
                    <getSlashCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSlashCountForBlueprint(inner) => {
                    <getSlashCountForBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSlashCountForService(inner) => {
                    <getSlashCountForServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSlashImpact(inner) => {
                    <getSlashImpactCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSlashRecord(inner) => {
                    <getSlashRecordCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSnapshot(inner) => {
                    <getSnapshotCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getTotalDelegation(inner) => {
                    <getTotalDelegationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::increaseStake(inner) => {
                    <increaseStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isOperator(inner) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isOperatorActive(inner) => {
                    <isOperatorActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isSlasher(inner) => {
                    <isSlasherCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::lastRoundAdvance(inner) => {
                    <lastRoundAdvanceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::leaveDelegatorsDelay(inner) => {
                    <leaveDelegatorsDelayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::leaveOperatorsDelay(inner) => {
                    <leaveOperatorsDelayCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::meetsStakeRequirement(inner) => {
                    <meetsStakeRequirementCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::minOperatorStake(inner) => {
                    <minOperatorStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nativeEnabled(inner) => {
                    <nativeEnabledCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::nextSlashId(inner) => {
                    <nextSlashIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::notifyReward(inner) => {
                    <notifyRewardCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::notifyRewardForBlueprint(inner) => {
                    <notifyRewardForBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::operatorAt(inner) => {
                    <operatorAtCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::operatorCommissionBps(inner) => {
                    <operatorCommissionBpsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::operatorCount(inner) => {
                    <operatorCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::operatorStake(inner) => {
                    <operatorStakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::registerAdapter(inner) => {
                    <registerAdapterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::registerOperator(inner) => {
                    <registerOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::registerOperatorWithAsset(inner) => {
                    <registerOperatorWithAssetCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeAdapter(inner) => {
                    <removeAdapterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeBlueprint(inner) => {
                    <removeBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeBlueprintFromDelegation(inner) => {
                    <removeBlueprintFromDelegationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removeSlasher(inner) => {
                    <removeSlasherCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requireAdapters(inner) => {
                    <requireAdaptersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rescueTokens(inner) => {
                    <rescueTokensCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::rewardPoolTotals(inner) => {
                    <rewardPoolTotalsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rewardsManager(inner) => {
                    <rewardsManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::roundDuration(inner) => {
                    <roundDurationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::scheduleDelegatorUnstake(inner) => {
                    <scheduleDelegatorUnstakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::scheduleOperatorUnstake(inner) => {
                    <scheduleOperatorUnstakeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::scheduleWithdraw(inner) => {
                    <scheduleWithdrawCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serviceFeeDistributor(inner) => {
                    <serviceFeeDistributorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serviceSlashCount(inner) => {
                    <serviceSlashCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setDelays(inner) => {
                    <setDelaysCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::setOperatorCommission(inner) => {
                    <setOperatorCommissionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRequireAdapters(inner) => {
                    <setRequireAdaptersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRewardsManager(inner) => {
                    <setRewardsManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setServiceFeeDistributor(inner) => {
                    <setServiceFeeDistributorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::slash(inner) => {
                    <slashCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::slashForBlueprint(inner) => {
                    <slashForBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::slashForService(inner) => {
                    <slashForServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::slashHistory(inner) => {
                    <slashHistoryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::snapshotOperator(inner) => {
                    <snapshotOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::startLeaving(inner) => {
                    <startLeavingCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::undelegate(inner) => {
                    <undelegateCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ADMIN_ROLE(inner) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ASSET_MANAGER_ROLE(inner) => {
                    <ASSET_MANAGER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BPS_DENOMINATOR(inner) => {
                    <BPS_DENOMINATORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LOCK_ONE_MONTH(inner) => {
                    <LOCK_ONE_MONTHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LOCK_SIX_MONTHS(inner) => {
                    <LOCK_SIX_MONTHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LOCK_THREE_MONTHS(inner) => {
                    <LOCK_THREE_MONTHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LOCK_TWO_MONTHS(inner) => {
                    <LOCK_TWO_MONTHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MULTIPLIER_NONE(inner) => {
                    <MULTIPLIER_NONECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MULTIPLIER_ONE_MONTH(inner) => {
                    <MULTIPLIER_ONE_MONTHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MULTIPLIER_SIX_MONTHS(inner) => {
                    <MULTIPLIER_SIX_MONTHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MULTIPLIER_THREE_MONTHS(inner) => {
                    <MULTIPLIER_THREE_MONTHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MULTIPLIER_TWO_MONTHS(inner) => {
                    <MULTIPLIER_TWO_MONTHSCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PRECISION(inner) => {
                    <PRECISIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SLASHER_ROLE(inner) => {
                    <SLASHER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addBlueprint(inner) => {
                    <addBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addBlueprintToDelegation(inner) => {
                    <addBlueprintToDelegationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addSlasher(inner) => {
                    <addSlasherCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::advanceRound(inner) => {
                    <advanceRoundCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::blueprintPoolTotals(inner) => {
                    <blueprintPoolTotalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::blueprintSlashCount(inner) => {
                    <blueprintSlashCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimDelegatorRewards(inner) => {
                    <claimDelegatorRewardsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimOperatorRewards(inner) => {
                    <claimOperatorRewardsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimOperatorRewardsTo(inner) => {
                    <claimOperatorRewardsToCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::completeLeaving(inner) => {
                    <completeLeavingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::currentRound(inner) => {
                    <currentRoundCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegate(inner) => {
                    <delegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegateWithOptions(inner) => {
                    <delegateWithOptionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::delegationBondLessDelay(inner) => {
                    <delegationBondLessDelayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deposit(inner) => {
                    <depositCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::depositAndDelegate(inner) => {
                    <depositAndDelegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositAndDelegateWithOptions(inner) => {
                    <depositAndDelegateWithOptionsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositERC20(inner) => {
                    <depositERC20Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositERC20WithLock(inner) => {
                    <depositERC20WithLockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::depositWithLock(inner) => {
                    <depositWithLockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::disableAsset(inner) => {
                    <disableAssetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enableAsset(inner) => {
                    <enableAssetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::enableAssetWithAdapter(inner) => {
                    <enableAssetWithAdapterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::executeDelegatorUnstake(inner) => {
                    <executeDelegatorUnstakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::executeOperatorUnstake(inner) => {
                    <executeOperatorUnstakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::executeWithdraw(inner) => {
                    <executeWithdrawCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAssetAdapter(inner) => {
                    <getAssetAdapterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getAssetConfig(inner) => {
                    <getAssetConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDelegation(inner) => {
                    <getDelegationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDelegationBlueprints(inner) => {
                    <getDelegationBlueprintsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDelegations(inner) => {
                    <getDelegationsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getDeposit(inner) => {
                    <getDepositCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getLocks(inner) => {
                    <getLocksCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorBlueprints(inner) => {
                    <getOperatorBlueprintsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorDelegatedStake(inner) => {
                    <getOperatorDelegatedStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorDelegatorCount(inner) => {
                    <getOperatorDelegatorCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorDelegators(inner) => {
                    <getOperatorDelegatorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorMetadata(inner) => {
                    <getOperatorMetadataCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorRewardPool(inner) => {
                    <getOperatorRewardPoolCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorSelfStake(inner) => {
                    <getOperatorSelfStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorSlashFactor(inner) => {
                    <getOperatorSlashFactorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorStake(inner) => {
                    <getOperatorStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPendingDelegatorRewards(inner) => {
                    <getPendingDelegatorRewardsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPendingOperatorRewards(inner) => {
                    <getPendingOperatorRewardsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPendingUnstakes(inner) => {
                    <getPendingUnstakesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getPendingWithdrawals(inner) => {
                    <getPendingWithdrawalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSlashCount(inner) => {
                    <getSlashCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSlashCountForBlueprint(inner) => {
                    <getSlashCountForBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSlashCountForService(inner) => {
                    <getSlashCountForServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSlashImpact(inner) => {
                    <getSlashImpactCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSlashRecord(inner) => {
                    <getSlashRecordCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSnapshot(inner) => {
                    <getSnapshotCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getTotalDelegation(inner) => {
                    <getTotalDelegationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::increaseStake(inner) => {
                    <increaseStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isOperator(inner) => {
                    <isOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isOperatorActive(inner) => {
                    <isOperatorActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isSlasher(inner) => {
                    <isSlasherCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::lastRoundAdvance(inner) => {
                    <lastRoundAdvanceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leaveDelegatorsDelay(inner) => {
                    <leaveDelegatorsDelayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leaveOperatorsDelay(inner) => {
                    <leaveOperatorsDelayCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::meetsStakeRequirement(inner) => {
                    <meetsStakeRequirementCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::minOperatorStake(inner) => {
                    <minOperatorStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nativeEnabled(inner) => {
                    <nativeEnabledCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::nextSlashId(inner) => {
                    <nextSlashIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::notifyReward(inner) => {
                    <notifyRewardCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::notifyRewardForBlueprint(inner) => {
                    <notifyRewardForBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::operatorAt(inner) => {
                    <operatorAtCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::operatorCommissionBps(inner) => {
                    <operatorCommissionBpsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::operatorCount(inner) => {
                    <operatorCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::operatorStake(inner) => {
                    <operatorStakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::registerAdapter(inner) => {
                    <registerAdapterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::registerOperator(inner) => {
                    <registerOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::registerOperatorWithAsset(inner) => {
                    <registerOperatorWithAssetCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeAdapter(inner) => {
                    <removeAdapterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeBlueprint(inner) => {
                    <removeBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeBlueprintFromDelegation(inner) => {
                    <removeBlueprintFromDelegationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removeSlasher(inner) => {
                    <removeSlasherCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requireAdapters(inner) => {
                    <requireAdaptersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rescueTokens(inner) => {
                    <rescueTokensCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rewardPoolTotals(inner) => {
                    <rewardPoolTotalsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rewardsManager(inner) => {
                    <rewardsManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::roundDuration(inner) => {
                    <roundDurationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::scheduleDelegatorUnstake(inner) => {
                    <scheduleDelegatorUnstakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::scheduleOperatorUnstake(inner) => {
                    <scheduleOperatorUnstakeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::scheduleWithdraw(inner) => {
                    <scheduleWithdrawCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serviceFeeDistributor(inner) => {
                    <serviceFeeDistributorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serviceSlashCount(inner) => {
                    <serviceSlashCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setDelays(inner) => {
                    <setDelaysCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setOperatorCommission(inner) => {
                    <setOperatorCommissionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRequireAdapters(inner) => {
                    <setRequireAdaptersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRewardsManager(inner) => {
                    <setRewardsManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setServiceFeeDistributor(inner) => {
                    <setServiceFeeDistributorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::slash(inner) => {
                    <slashCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::slashForBlueprint(inner) => {
                    <slashForBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::slashForService(inner) => {
                    <slashForServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::slashHistory(inner) => {
                    <slashHistoryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::snapshotOperator(inner) => {
                    <snapshotOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::startLeaving(inner) => {
                    <startLeavingCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::undelegate(inner) => {
                    <undelegateCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`MultiAssetDelegationExposed`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum MultiAssetDelegationExposedErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        AllModeDisallowsBlueprints(AllModeDisallowsBlueprints),
        #[allow(missing_docs)]
        AmountLocked(AmountLocked),
        #[allow(missing_docs)]
        AssetNotEnabled(AssetNotEnabled),
        #[allow(missing_docs)]
        BelowMinimumDeposit(BelowMinimumDeposit),
        #[allow(missing_docs)]
        BlueprintAlreadySelected(BlueprintAlreadySelected),
        #[allow(missing_docs)]
        BlueprintNotSelected(BlueprintNotSelected),
        #[allow(missing_docs)]
        CannotRemoveLastBlueprint(CannotRemoveLastBlueprint),
        #[allow(missing_docs)]
        DelegationNotFound(DelegationNotFound),
        #[allow(missing_docs)]
        DepositCapExceeded(DepositCapExceeded),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        FixedModeRequiresBlueprints(FixedModeRequiresBlueprints),
        #[allow(missing_docs)]
        InsufficientAvailableBalance(InsufficientAvailableBalance),
        #[allow(missing_docs)]
        InsufficientDelegation(InsufficientDelegation),
        #[allow(missing_docs)]
        InsufficientDeposit(InsufficientDeposit),
        #[allow(missing_docs)]
        InsufficientStake(InsufficientStake),
        #[allow(missing_docs)]
        InvalidDelegationIndex(InvalidDelegationIndex),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidLockMultiplier(InvalidLockMultiplier),
        #[allow(missing_docs)]
        LeavingTooEarly(LeavingTooEarly),
        #[allow(missing_docs)]
        LegacySlashRequiresAllMode(LegacySlashRequiresAllMode),
        #[allow(missing_docs)]
        NoRewardsToClaim(NoRewardsToClaim),
        #[allow(missing_docs)]
        NotFixedMode(NotFixedMode),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        OperatorAlreadyRegistered(OperatorAlreadyRegistered),
        #[allow(missing_docs)]
        OperatorNotActive(OperatorNotActive),
        #[allow(missing_docs)]
        OperatorNotLeaving(OperatorNotLeaving),
        #[allow(missing_docs)]
        OperatorNotRegistered(OperatorNotRegistered),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        RoundAdvanceTooSoon(RoundAdvanceTooSoon),
        #[allow(missing_docs)]
        SafeERC20FailedOperation(SafeERC20FailedOperation),
        #[allow(missing_docs)]
        SelectionModeMismatch(SelectionModeMismatch),
        #[allow(missing_docs)]
        TransferFailed(TransferFailed),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    impl MultiAssetDelegationExposedErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 160u8, 26u8, 94u8],
            [22u8, 67u8, 2u8, 186u8],
            [30u8, 43u8, 226u8, 17u8],
            [31u8, 42u8, 32u8, 5u8],
            [36u8, 30u8, 51u8, 252u8],
            [37u8, 195u8, 244u8, 110u8],
            [39u8, 27u8, 253u8, 170u8],
            [39u8, 73u8, 40u8, 213u8],
            [59u8, 109u8, 161u8, 22u8],
            [62u8, 229u8, 174u8, 181u8],
            [67u8, 110u8, 27u8, 124u8],
            [69u8, 190u8, 10u8, 38u8],
            [75u8, 152u8, 80u8, 69u8],
            [76u8, 156u8, 140u8, 227u8],
            [82u8, 116u8, 175u8, 231u8],
            [96u8, 196u8, 70u8, 214u8],
            [102u8, 151u8, 178u8, 50u8],
            [108u8, 19u8, 100u8, 116u8],
            [115u8, 56u8, 13u8, 153u8],
            [134u8, 107u8, 13u8, 207u8],
            [136u8, 196u8, 254u8, 143u8],
            [141u8, 252u8, 32u8, 43u8],
            [142u8, 195u8, 50u8, 17u8],
            [144u8, 184u8, 236u8, 24u8],
            [153u8, 35u8, 197u8, 57u8],
            [153u8, 150u8, 179u8, 21u8],
            [170u8, 29u8, 73u8, 164u8],
            [170u8, 231u8, 88u8, 161u8],
            [171u8, 206u8, 106u8, 240u8],
            [173u8, 185u8, 224u8, 67u8],
            [179u8, 152u8, 151u8, 159u8],
            [181u8, 22u8, 38u8, 13u8],
            [189u8, 98u8, 1u8, 51u8],
            [192u8, 107u8, 36u8, 148u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 230u8, 188u8, 248u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [224u8, 124u8, 141u8, 186u8],
            [226u8, 81u8, 125u8, 63u8],
            [227u8, 86u8, 213u8, 170u8],
            [246u8, 242u8, 75u8, 131u8],
            [249u8, 46u8, 232u8, 169u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(BlueprintAlreadySelected),
            ::core::stringify!(InvalidDelegationIndex),
            ::core::stringify!(BelowMinimumDeposit),
            ::core::stringify!(ZeroAmount),
            ::core::stringify!(DelegationNotFound),
            ::core::stringify!(InsufficientDeposit),
            ::core::stringify!(NotFixedMode),
            ::core::stringify!(RoundAdvanceTooSoon),
            ::core::stringify!(FixedModeRequiresBlueprints),
            ::core::stringify!(ReentrancyGuardReentrantCall),
            ::core::stringify!(AllModeDisallowsBlueprints),
            ::core::stringify!(InsufficientStake),
            ::core::stringify!(DepositCapExceeded),
            ::core::stringify!(ERC1967InvalidImplementation),
            ::core::stringify!(SafeERC20FailedOperation),
            ::core::stringify!(BlueprintNotSelected),
            ::core::stringify!(AccessControlBadConfirmation),
            ::core::stringify!(LeavingTooEarly),
            ::core::stringify!(NoRewardsToClaim),
            ::core::stringify!(OperatorAlreadyRegistered),
            ::core::stringify!(InsufficientDelegation),
            ::core::stringify!(ExpectedPause),
            ::core::stringify!(AmountLocked),
            ::core::stringify!(TransferFailed),
            ::core::stringify!(OperatorNotLeaving),
            ::core::stringify!(AddressEmptyCode),
            ::core::stringify!(UUPSUnsupportedProxiableUUID),
            ::core::stringify!(InvalidLockMultiplier),
            ::core::stringify!(SelectionModeMismatch),
            ::core::stringify!(InsufficientAvailableBalance),
            ::core::stringify!(ERC1967NonPayable),
            ::core::stringify!(LegacySlashRequiresAllMode),
            ::core::stringify!(OperatorNotRegistered),
            ::core::stringify!(CannotRemoveLastBlueprint),
            ::core::stringify!(FailedCall),
            ::core::stringify!(NotInitializing),
            ::core::stringify!(ZeroAddress),
            ::core::stringify!(EnforcedPause),
            ::core::stringify!(UUPSUnauthorizedCallContext),
            ::core::stringify!(AccessControlUnauthorizedAccount),
            ::core::stringify!(OperatorNotActive),
            ::core::stringify!(AssetNotEnabled),
            ::core::stringify!(InvalidInitialization),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <BlueprintAlreadySelected as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidDelegationIndex as alloy_sol_types::SolError>::SIGNATURE,
            <BelowMinimumDeposit as alloy_sol_types::SolError>::SIGNATURE,
            <ZeroAmount as alloy_sol_types::SolError>::SIGNATURE,
            <DelegationNotFound as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientDeposit as alloy_sol_types::SolError>::SIGNATURE,
            <NotFixedMode as alloy_sol_types::SolError>::SIGNATURE,
            <RoundAdvanceTooSoon as alloy_sol_types::SolError>::SIGNATURE,
            <FixedModeRequiresBlueprints as alloy_sol_types::SolError>::SIGNATURE,
            <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SIGNATURE,
            <AllModeDisallowsBlueprints as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientStake as alloy_sol_types::SolError>::SIGNATURE,
            <DepositCapExceeded as alloy_sol_types::SolError>::SIGNATURE,
            <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SIGNATURE,
            <SafeERC20FailedOperation as alloy_sol_types::SolError>::SIGNATURE,
            <BlueprintNotSelected as alloy_sol_types::SolError>::SIGNATURE,
            <AccessControlBadConfirmation as alloy_sol_types::SolError>::SIGNATURE,
            <LeavingTooEarly as alloy_sol_types::SolError>::SIGNATURE,
            <NoRewardsToClaim as alloy_sol_types::SolError>::SIGNATURE,
            <OperatorAlreadyRegistered as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientDelegation as alloy_sol_types::SolError>::SIGNATURE,
            <ExpectedPause as alloy_sol_types::SolError>::SIGNATURE,
            <AmountLocked as alloy_sol_types::SolError>::SIGNATURE,
            <TransferFailed as alloy_sol_types::SolError>::SIGNATURE,
            <OperatorNotLeaving as alloy_sol_types::SolError>::SIGNATURE,
            <AddressEmptyCode as alloy_sol_types::SolError>::SIGNATURE,
            <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidLockMultiplier as alloy_sol_types::SolError>::SIGNATURE,
            <SelectionModeMismatch as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientAvailableBalance as alloy_sol_types::SolError>::SIGNATURE,
            <ERC1967NonPayable as alloy_sol_types::SolError>::SIGNATURE,
            <LegacySlashRequiresAllMode as alloy_sol_types::SolError>::SIGNATURE,
            <OperatorNotRegistered as alloy_sol_types::SolError>::SIGNATURE,
            <CannotRemoveLastBlueprint as alloy_sol_types::SolError>::SIGNATURE,
            <FailedCall as alloy_sol_types::SolError>::SIGNATURE,
            <NotInitializing as alloy_sol_types::SolError>::SIGNATURE,
            <ZeroAddress as alloy_sol_types::SolError>::SIGNATURE,
            <EnforcedPause as alloy_sol_types::SolError>::SIGNATURE,
            <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SIGNATURE,
            <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SIGNATURE,
            <OperatorNotActive as alloy_sol_types::SolError>::SIGNATURE,
            <AssetNotEnabled as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidInitialization as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for MultiAssetDelegationExposedErrors {
        const NAME: &'static str = "MultiAssetDelegationExposedErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 43usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AllModeDisallowsBlueprints(_) => {
                    <AllModeDisallowsBlueprints as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AmountLocked(_) => {
                    <AmountLocked as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AssetNotEnabled(_) => {
                    <AssetNotEnabled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BelowMinimumDeposit(_) => {
                    <BelowMinimumDeposit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BlueprintAlreadySelected(_) => {
                    <BlueprintAlreadySelected as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BlueprintNotSelected(_) => {
                    <BlueprintNotSelected as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CannotRemoveLastBlueprint(_) => {
                    <CannotRemoveLastBlueprint as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DelegationNotFound(_) => {
                    <DelegationNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DepositCapExceeded(_) => {
                    <DepositCapExceeded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FixedModeRequiresBlueprints(_) => {
                    <FixedModeRequiresBlueprints as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientAvailableBalance(_) => {
                    <InsufficientAvailableBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientDelegation(_) => {
                    <InsufficientDelegation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientDeposit(_) => {
                    <InsufficientDeposit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientStake(_) => {
                    <InsufficientStake as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDelegationIndex(_) => {
                    <InvalidDelegationIndex as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidLockMultiplier(_) => {
                    <InvalidLockMultiplier as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LeavingTooEarly(_) => {
                    <LeavingTooEarly as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LegacySlashRequiresAllMode(_) => {
                    <LegacySlashRequiresAllMode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoRewardsToClaim(_) => {
                    <NoRewardsToClaim as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotFixedMode(_) => {
                    <NotFixedMode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorAlreadyRegistered(_) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorNotActive(_) => {
                    <OperatorNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorNotLeaving(_) => {
                    <OperatorNotLeaving as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorNotRegistered(_) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::RoundAdvanceTooSoon(_) => {
                    <RoundAdvanceTooSoon as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeERC20FailedOperation(_) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SelectionModeMismatch(_) => {
                    <SelectionModeMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TransferFailed(_) => {
                    <TransferFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors>] = &[
                {
                    fn BlueprintAlreadySelected(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <BlueprintAlreadySelected as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::BlueprintAlreadySelected,
                            )
                    }
                    BlueprintAlreadySelected
                },
                {
                    fn InvalidDelegationIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InvalidDelegationIndex as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InvalidDelegationIndex,
                            )
                    }
                    InvalidDelegationIndex
                },
                {
                    fn BelowMinimumDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <BelowMinimumDeposit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::BelowMinimumDeposit)
                    }
                    BelowMinimumDeposit
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn DelegationNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <DelegationNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::DelegationNotFound)
                    }
                    DelegationNotFound
                },
                {
                    fn InsufficientDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InsufficientDeposit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::InsufficientDeposit)
                    }
                    InsufficientDeposit
                },
                {
                    fn NotFixedMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <NotFixedMode as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedErrors::NotFixedMode)
                    }
                    NotFixedMode
                },
                {
                    fn RoundAdvanceTooSoon(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <RoundAdvanceTooSoon as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::RoundAdvanceTooSoon)
                    }
                    RoundAdvanceTooSoon
                },
                {
                    fn FixedModeRequiresBlueprints(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <FixedModeRequiresBlueprints as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::FixedModeRequiresBlueprints,
                            )
                    }
                    FixedModeRequiresBlueprints
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::ReentrancyGuardReentrantCall,
                            )
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn AllModeDisallowsBlueprints(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AllModeDisallowsBlueprints as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::AllModeDisallowsBlueprints,
                            )
                    }
                    AllModeDisallowsBlueprints
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn DepositCapExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <DepositCapExceeded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::DepositCapExceeded)
                    }
                    DepositCapExceeded
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::ERC1967InvalidImplementation,
                            )
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::SafeERC20FailedOperation,
                            )
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn BlueprintNotSelected(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <BlueprintNotSelected as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::BlueprintNotSelected)
                    }
                    BlueprintNotSelected
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::AccessControlBadConfirmation,
                            )
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn LeavingTooEarly(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <LeavingTooEarly as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::LeavingTooEarly)
                    }
                    LeavingTooEarly
                },
                {
                    fn NoRewardsToClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <NoRewardsToClaim as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::NoRewardsToClaim)
                    }
                    NoRewardsToClaim
                },
                {
                    fn OperatorAlreadyRegistered(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::OperatorAlreadyRegistered,
                            )
                    }
                    OperatorAlreadyRegistered
                },
                {
                    fn InsufficientDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InsufficientDelegation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InsufficientDelegation,
                            )
                    }
                    InsufficientDelegation
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn AmountLocked(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AmountLocked as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedErrors::AmountLocked)
                    }
                    AmountLocked
                },
                {
                    fn TransferFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <TransferFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::TransferFailed)
                    }
                    TransferFailed
                },
                {
                    fn OperatorNotLeaving(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <OperatorNotLeaving as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::OperatorNotLeaving)
                    }
                    OperatorNotLeaving
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::UUPSUnsupportedProxiableUUID,
                            )
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidLockMultiplier(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InvalidLockMultiplier as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InvalidLockMultiplier,
                            )
                    }
                    InvalidLockMultiplier
                },
                {
                    fn SelectionModeMismatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <SelectionModeMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::SelectionModeMismatch,
                            )
                    }
                    SelectionModeMismatch
                },
                {
                    fn InsufficientAvailableBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InsufficientAvailableBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InsufficientAvailableBalance,
                            )
                    }
                    InsufficientAvailableBalance
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn LegacySlashRequiresAllMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <LegacySlashRequiresAllMode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::LegacySlashRequiresAllMode,
                            )
                    }
                    LegacySlashRequiresAllMode
                },
                {
                    fn OperatorNotRegistered(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <OperatorNotRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::OperatorNotRegistered,
                            )
                    }
                    OperatorNotRegistered
                },
                {
                    fn CannotRemoveLastBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <CannotRemoveLastBlueprint as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::CannotRemoveLastBlueprint,
                            )
                    }
                    CannotRemoveLastBlueprint
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(MultiAssetDelegationExposedErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::UUPSUnauthorizedCallContext,
                            )
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn OperatorNotActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <OperatorNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::OperatorNotActive)
                    }
                    OperatorNotActive
                },
                {
                    fn AssetNotEnabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AssetNotEnabled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::AssetNotEnabled)
                    }
                    AssetNotEnabled
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InvalidInitialization,
                            )
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors>] = &[
                {
                    fn BlueprintAlreadySelected(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <BlueprintAlreadySelected as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::BlueprintAlreadySelected,
                            )
                    }
                    BlueprintAlreadySelected
                },
                {
                    fn InvalidDelegationIndex(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InvalidDelegationIndex as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InvalidDelegationIndex,
                            )
                    }
                    InvalidDelegationIndex
                },
                {
                    fn BelowMinimumDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <BelowMinimumDeposit as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::BelowMinimumDeposit)
                    }
                    BelowMinimumDeposit
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn DelegationNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <DelegationNotFound as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::DelegationNotFound)
                    }
                    DelegationNotFound
                },
                {
                    fn InsufficientDeposit(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InsufficientDeposit as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::InsufficientDeposit)
                    }
                    InsufficientDeposit
                },
                {
                    fn NotFixedMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <NotFixedMode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::NotFixedMode)
                    }
                    NotFixedMode
                },
                {
                    fn RoundAdvanceTooSoon(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <RoundAdvanceTooSoon as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::RoundAdvanceTooSoon)
                    }
                    RoundAdvanceTooSoon
                },
                {
                    fn FixedModeRequiresBlueprints(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <FixedModeRequiresBlueprints as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::FixedModeRequiresBlueprints,
                            )
                    }
                    FixedModeRequiresBlueprints
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::ReentrancyGuardReentrantCall,
                            )
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn AllModeDisallowsBlueprints(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AllModeDisallowsBlueprints as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::AllModeDisallowsBlueprints,
                            )
                    }
                    AllModeDisallowsBlueprints
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn DepositCapExceeded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <DepositCapExceeded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::DepositCapExceeded)
                    }
                    DepositCapExceeded
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::ERC1967InvalidImplementation,
                            )
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::SafeERC20FailedOperation,
                            )
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn BlueprintNotSelected(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <BlueprintNotSelected as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::BlueprintNotSelected)
                    }
                    BlueprintNotSelected
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::AccessControlBadConfirmation,
                            )
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn LeavingTooEarly(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <LeavingTooEarly as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::LeavingTooEarly)
                    }
                    LeavingTooEarly
                },
                {
                    fn NoRewardsToClaim(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <NoRewardsToClaim as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::NoRewardsToClaim)
                    }
                    NoRewardsToClaim
                },
                {
                    fn OperatorAlreadyRegistered(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::OperatorAlreadyRegistered,
                            )
                    }
                    OperatorAlreadyRegistered
                },
                {
                    fn InsufficientDelegation(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InsufficientDelegation as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InsufficientDelegation,
                            )
                    }
                    InsufficientDelegation
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn AmountLocked(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AmountLocked as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::AmountLocked)
                    }
                    AmountLocked
                },
                {
                    fn TransferFailed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <TransferFailed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::TransferFailed)
                    }
                    TransferFailed
                },
                {
                    fn OperatorNotLeaving(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <OperatorNotLeaving as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::OperatorNotLeaving)
                    }
                    OperatorNotLeaving
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::UUPSUnsupportedProxiableUUID,
                            )
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidLockMultiplier(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InvalidLockMultiplier as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InvalidLockMultiplier,
                            )
                    }
                    InvalidLockMultiplier
                },
                {
                    fn SelectionModeMismatch(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <SelectionModeMismatch as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::SelectionModeMismatch,
                            )
                    }
                    SelectionModeMismatch
                },
                {
                    fn InsufficientAvailableBalance(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InsufficientAvailableBalance as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InsufficientAvailableBalance,
                            )
                    }
                    InsufficientAvailableBalance
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn LegacySlashRequiresAllMode(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <LegacySlashRequiresAllMode as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::LegacySlashRequiresAllMode,
                            )
                    }
                    LegacySlashRequiresAllMode
                },
                {
                    fn OperatorNotRegistered(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <OperatorNotRegistered as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::OperatorNotRegistered,
                            )
                    }
                    OperatorNotRegistered
                },
                {
                    fn CannotRemoveLastBlueprint(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <CannotRemoveLastBlueprint as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::CannotRemoveLastBlueprint,
                            )
                    }
                    CannotRemoveLastBlueprint
                },
                {
                    fn FailedCall(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::UUPSUnauthorizedCallContext,
                            )
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::AccessControlUnauthorizedAccount,
                            )
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn OperatorNotActive(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <OperatorNotActive as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::OperatorNotActive)
                    }
                    OperatorNotActive
                },
                {
                    fn AssetNotEnabled(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <AssetNotEnabled as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(MultiAssetDelegationExposedErrors::AssetNotEnabled)
                    }
                    AssetNotEnabled
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<MultiAssetDelegationExposedErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                MultiAssetDelegationExposedErrors::InvalidInitialization,
                            )
                    }
                    InvalidInitialization
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AllModeDisallowsBlueprints(inner) => {
                    <AllModeDisallowsBlueprints as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AmountLocked(inner) => {
                    <AmountLocked as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::AssetNotEnabled(inner) => {
                    <AssetNotEnabled as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BelowMinimumDeposit(inner) => {
                    <BelowMinimumDeposit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BlueprintAlreadySelected(inner) => {
                    <BlueprintAlreadySelected as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BlueprintNotSelected(inner) => {
                    <BlueprintNotSelected as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CannotRemoveLastBlueprint(inner) => {
                    <CannotRemoveLastBlueprint as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DelegationNotFound(inner) => {
                    <DelegationNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DepositCapExceeded(inner) => {
                    <DepositCapExceeded as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FixedModeRequiresBlueprints(inner) => {
                    <FixedModeRequiresBlueprints as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientAvailableBalance(inner) => {
                    <InsufficientAvailableBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientDelegation(inner) => {
                    <InsufficientDelegation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientDeposit(inner) => {
                    <InsufficientDeposit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDelegationIndex(inner) => {
                    <InvalidDelegationIndex as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidLockMultiplier(inner) => {
                    <InvalidLockMultiplier as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LeavingTooEarly(inner) => {
                    <LeavingTooEarly as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LegacySlashRequiresAllMode(inner) => {
                    <LegacySlashRequiresAllMode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoRewardsToClaim(inner) => {
                    <NoRewardsToClaim as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotFixedMode(inner) => {
                    <NotFixedMode as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorAlreadyRegistered(inner) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorNotActive(inner) => {
                    <OperatorNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorNotLeaving(inner) => {
                    <OperatorNotLeaving as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorNotRegistered(inner) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RoundAdvanceTooSoon(inner) => {
                    <RoundAdvanceTooSoon as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SelectionModeMismatch(inner) => {
                    <SelectionModeMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TransferFailed(inner) => {
                    <TransferFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AllModeDisallowsBlueprints(inner) => {
                    <AllModeDisallowsBlueprints as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AmountLocked(inner) => {
                    <AmountLocked as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AssetNotEnabled(inner) => {
                    <AssetNotEnabled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BelowMinimumDeposit(inner) => {
                    <BelowMinimumDeposit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BlueprintAlreadySelected(inner) => {
                    <BlueprintAlreadySelected as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BlueprintNotSelected(inner) => {
                    <BlueprintNotSelected as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CannotRemoveLastBlueprint(inner) => {
                    <CannotRemoveLastBlueprint as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DelegationNotFound(inner) => {
                    <DelegationNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DepositCapExceeded(inner) => {
                    <DepositCapExceeded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::FixedModeRequiresBlueprints(inner) => {
                    <FixedModeRequiresBlueprints as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientAvailableBalance(inner) => {
                    <InsufficientAvailableBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientDelegation(inner) => {
                    <InsufficientDelegation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientDeposit(inner) => {
                    <InsufficientDeposit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDelegationIndex(inner) => {
                    <InvalidDelegationIndex as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidLockMultiplier(inner) => {
                    <InvalidLockMultiplier as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LeavingTooEarly(inner) => {
                    <LeavingTooEarly as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LegacySlashRequiresAllMode(inner) => {
                    <LegacySlashRequiresAllMode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoRewardsToClaim(inner) => {
                    <NoRewardsToClaim as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotFixedMode(inner) => {
                    <NotFixedMode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OperatorAlreadyRegistered(inner) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OperatorNotActive(inner) => {
                    <OperatorNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OperatorNotLeaving(inner) => {
                    <OperatorNotLeaving as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OperatorNotRegistered(inner) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RoundAdvanceTooSoon(inner) => {
                    <RoundAdvanceTooSoon as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SelectionModeMismatch(inner) => {
                    <SelectionModeMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TransferFailed(inner) => {
                    <TransferFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`MultiAssetDelegationExposed`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum MultiAssetDelegationExposedEvents {
        #[allow(missing_docs)]
        AdapterRegistered(AdapterRegistered),
        #[allow(missing_docs)]
        AdapterRemoved(AdapterRemoved),
        #[allow(missing_docs)]
        AssetDisabled(AssetDisabled),
        #[allow(missing_docs)]
        AssetEnabled(AssetEnabled),
        #[allow(missing_docs)]
        BlueprintAddedToDelegation(BlueprintAddedToDelegation),
        #[allow(missing_docs)]
        BlueprintRemovedFromDelegation(BlueprintRemovedFromDelegation),
        #[allow(missing_docs)]
        Delegated(Delegated),
        #[allow(missing_docs)]
        DelegatorUnstakeExecuted(DelegatorUnstakeExecuted),
        #[allow(missing_docs)]
        DelegatorUnstakeScheduled(DelegatorUnstakeScheduled),
        #[allow(missing_docs)]
        Deposited(Deposited),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        OperatorBlueprintAdded(OperatorBlueprintAdded),
        #[allow(missing_docs)]
        OperatorBlueprintRemoved(OperatorBlueprintRemoved),
        #[allow(missing_docs)]
        OperatorLeavingScheduled(OperatorLeavingScheduled),
        #[allow(missing_docs)]
        OperatorLeft(OperatorLeft),
        #[allow(missing_docs)]
        OperatorRegistered(OperatorRegistered),
        #[allow(missing_docs)]
        OperatorSlashed(OperatorSlashed),
        #[allow(missing_docs)]
        OperatorStakeIncreased(OperatorStakeIncreased),
        #[allow(missing_docs)]
        OperatorUnstakeExecuted(OperatorUnstakeExecuted),
        #[allow(missing_docs)]
        OperatorUnstakeScheduled(OperatorUnstakeScheduled),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        RequireAdaptersUpdated(RequireAdaptersUpdated),
        #[allow(missing_docs)]
        RewardClaimed(RewardClaimed),
        #[allow(missing_docs)]
        RewardDistributed(RewardDistributed),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        RoundAdvanced(RoundAdvanced),
        #[allow(missing_docs)]
        SlashRecorded(SlashRecorded),
        #[allow(missing_docs)]
        Slashed(Slashed),
        #[allow(missing_docs)]
        SlashedForService(SlashedForService),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
        #[allow(missing_docs)]
        WithdrawScheduled(WithdrawScheduled),
        #[allow(missing_docs)]
        Withdrawn(Withdrawn),
    }
    impl MultiAssetDelegationExposedEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                6u8, 50u8, 93u8, 131u8, 67u8, 93u8, 168u8, 118u8, 87u8, 176u8, 99u8,
                198u8, 20u8, 42u8, 91u8, 145u8, 166u8, 106u8, 126u8, 129u8, 24u8, 39u8,
                208u8, 130u8, 214u8, 36u8, 40u8, 122u8, 153u8, 83u8, 196u8, 186u8,
            ],
            [
                6u8, 55u8, 82u8, 38u8, 206u8, 237u8, 178u8, 3u8, 158u8, 181u8, 163u8,
                198u8, 31u8, 254u8, 170u8, 234u8, 19u8, 232u8, 113u8, 125u8, 56u8, 213u8,
                146u8, 9u8, 183u8, 224u8, 146u8, 245u8, 77u8, 191u8, 82u8, 118u8,
            ],
            [
                16u8, 111u8, 146u8, 63u8, 153u8, 60u8, 33u8, 73u8, 212u8, 155u8, 66u8,
                85u8, 255u8, 114u8, 58u8, 202u8, 250u8, 31u8, 45u8, 148u8, 57u8, 63u8,
                86u8, 29u8, 62u8, 218u8, 50u8, 174u8, 52u8, 143u8, 114u8, 65u8,
            ],
            [
                18u8, 5u8, 153u8, 248u8, 131u8, 1u8, 21u8, 237u8, 151u8, 49u8, 137u8,
                248u8, 244u8, 148u8, 124u8, 199u8, 147u8, 252u8, 217u8, 10u8, 21u8,
                212u8, 124u8, 77u8, 106u8, 216u8, 209u8, 163u8, 241u8, 90u8, 247u8, 52u8,
            ],
            [
                21u8, 8u8, 251u8, 226u8, 44u8, 152u8, 5u8, 119u8, 7u8, 64u8, 200u8,
                243u8, 130u8, 117u8, 103u8, 149u8, 0u8, 34u8, 114u8, 158u8, 0u8, 150u8,
                227u8, 17u8, 220u8, 8u8, 121u8, 144u8, 193u8, 87u8, 255u8, 252u8,
            ],
            [
                47u8, 135u8, 136u8, 17u8, 126u8, 126u8, 255u8, 29u8, 130u8, 233u8, 38u8,
                236u8, 121u8, 73u8, 1u8, 209u8, 124u8, 120u8, 2u8, 74u8, 80u8, 39u8, 9u8,
                64u8, 48u8, 69u8, 64u8, 167u8, 51u8, 101u8, 111u8, 13u8,
            ],
            [
                75u8, 155u8, 191u8, 46u8, 188u8, 121u8, 233u8, 251u8, 57u8, 166u8, 73u8,
                32u8, 147u8, 75u8, 63u8, 69u8, 138u8, 72u8, 101u8, 82u8, 211u8, 223u8,
                149u8, 57u8, 90u8, 167u8, 80u8, 236u8, 233u8, 233u8, 112u8, 147u8,
            ],
            [
                79u8, 226u8, 253u8, 230u8, 49u8, 233u8, 134u8, 238u8, 38u8, 40u8, 57u8,
                1u8, 185u8, 204u8, 141u8, 109u8, 74u8, 49u8, 27u8, 117u8, 15u8, 159u8,
                160u8, 214u8, 89u8, 82u8, 13u8, 235u8, 162u8, 153u8, 95u8, 31u8,
            ],
            [
                93u8, 185u8, 238u8, 10u8, 73u8, 91u8, 242u8, 230u8, 255u8, 156u8, 145u8,
                167u8, 131u8, 76u8, 27u8, 164u8, 253u8, 210u8, 68u8, 165u8, 232u8, 170u8,
                78u8, 83u8, 123u8, 211u8, 138u8, 234u8, 228u8, 176u8, 115u8, 170u8,
            ],
            [
                97u8, 74u8, 63u8, 168u8, 70u8, 126u8, 181u8, 76u8, 182u8, 10u8, 243u8,
                170u8, 180u8, 64u8, 39u8, 152u8, 55u8, 201u8, 252u8, 215u8, 92u8, 90u8,
                38u8, 23u8, 254u8, 10u8, 249u8, 198u8, 229u8, 230u8, 14u8, 131u8,
            ],
            [
                98u8, 231u8, 140u8, 234u8, 1u8, 190u8, 227u8, 32u8, 205u8, 78u8, 66u8,
                2u8, 112u8, 181u8, 234u8, 116u8, 0u8, 13u8, 17u8, 176u8, 201u8, 247u8,
                71u8, 84u8, 235u8, 219u8, 252u8, 84u8, 75u8, 5u8, 162u8, 88u8,
            ],
            [
                117u8, 79u8, 255u8, 34u8, 5u8, 202u8, 159u8, 26u8, 8u8, 174u8, 31u8,
                56u8, 244u8, 135u8, 131u8, 155u8, 167u8, 225u8, 136u8, 149u8, 240u8,
                35u8, 137u8, 8u8, 234u8, 139u8, 136u8, 66u8, 215u8, 66u8, 79u8, 187u8,
            ],
            [
                124u8, 238u8, 112u8, 135u8, 186u8, 175u8, 223u8, 168u8, 249u8, 209u8,
                189u8, 57u8, 197u8, 96u8, 120u8, 46u8, 46u8, 237u8, 248u8, 97u8, 226u8,
                100u8, 139u8, 35u8, 42u8, 128u8, 80u8, 51u8, 83u8, 124u8, 86u8, 149u8,
            ],
            [
                145u8, 117u8, 75u8, 37u8, 65u8, 83u8, 134u8, 28u8, 30u8, 155u8, 201u8,
                24u8, 100u8, 132u8, 160u8, 187u8, 119u8, 8u8, 35u8, 172u8, 250u8, 0u8,
                66u8, 48u8, 68u8, 186u8, 23u8, 89u8, 160u8, 18u8, 16u8, 231u8,
            ],
            [
                145u8, 239u8, 247u8, 211u8, 157u8, 36u8, 153u8, 215u8, 106u8, 194u8,
                26u8, 25u8, 3u8, 169u8, 90u8, 136u8, 243u8, 21u8, 137u8, 203u8, 7u8,
                177u8, 255u8, 223u8, 182u8, 29u8, 185u8, 247u8, 205u8, 138u8, 57u8, 120u8,
            ],
            [
                154u8, 76u8, 89u8, 197u8, 97u8, 83u8, 36u8, 94u8, 35u8, 220u8, 184u8,
                0u8, 14u8, 48u8, 27u8, 154u8, 94u8, 53u8, 184u8, 230u8, 105u8, 60u8,
                92u8, 219u8, 243u8, 182u8, 162u8, 170u8, 15u8, 138u8, 55u8, 234u8,
            ],
            [
                167u8, 184u8, 30u8, 1u8, 122u8, 190u8, 181u8, 14u8, 207u8, 44u8, 18u8,
                28u8, 176u8, 219u8, 112u8, 135u8, 223u8, 196u8, 179u8, 204u8, 133u8,
                205u8, 141u8, 133u8, 127u8, 154u8, 95u8, 30u8, 129u8, 246u8, 72u8, 69u8,
            ],
            [
                182u8, 213u8, 228u8, 93u8, 119u8, 184u8, 150u8, 124u8, 255u8, 82u8, 91u8,
                55u8, 91u8, 230u8, 224u8, 127u8, 153u8, 202u8, 90u8, 249u8, 29u8, 136u8,
                114u8, 74u8, 193u8, 35u8, 122u8, 175u8, 226u8, 149u8, 213u8, 14u8,
            ],
            [
                188u8, 17u8, 97u8, 126u8, 87u8, 93u8, 101u8, 140u8, 116u8, 233u8, 33u8,
                200u8, 223u8, 34u8, 248u8, 228u8, 133u8, 102u8, 7u8, 47u8, 167u8, 129u8,
                69u8, 166u8, 207u8, 225u8, 132u8, 32u8, 191u8, 141u8, 12u8, 78u8,
            ],
            [
                188u8, 124u8, 215u8, 90u8, 32u8, 238u8, 39u8, 253u8, 154u8, 222u8, 186u8,
                179u8, 32u8, 65u8, 247u8, 85u8, 33u8, 77u8, 188u8, 107u8, 255u8, 169u8,
                12u8, 192u8, 34u8, 91u8, 57u8, 218u8, 46u8, 92u8, 45u8, 59u8,
            ],
            [
                189u8, 121u8, 184u8, 111u8, 254u8, 10u8, 184u8, 232u8, 119u8, 97u8, 81u8,
                81u8, 66u8, 23u8, 205u8, 124u8, 172u8, 213u8, 44u8, 144u8, 159u8, 102u8,
                71u8, 92u8, 58u8, 244u8, 78u8, 18u8, 159u8, 11u8, 0u8, 255u8,
            ],
            [
                195u8, 140u8, 239u8, 13u8, 0u8, 59u8, 200u8, 169u8, 152u8, 45u8, 176u8,
                217u8, 148u8, 178u8, 234u8, 4u8, 137u8, 70u8, 2u8, 142u8, 146u8, 85u8,
                204u8, 6u8, 26u8, 86u8, 171u8, 203u8, 183u8, 213u8, 72u8, 161u8,
            ],
            [
                196u8, 125u8, 241u8, 74u8, 217u8, 48u8, 155u8, 89u8, 7u8, 53u8, 70u8,
                249u8, 61u8, 190u8, 49u8, 21u8, 237u8, 9u8, 200u8, 178u8, 6u8, 217u8,
                64u8, 248u8, 68u8, 29u8, 219u8, 7u8, 247u8, 69u8, 177u8, 11u8,
            ],
            [
                199u8, 245u8, 5u8, 178u8, 243u8, 113u8, 174u8, 33u8, 117u8, 238u8, 73u8,
                19u8, 244u8, 73u8, 158u8, 31u8, 38u8, 51u8, 167u8, 181u8, 147u8, 99u8,
                33u8, 238u8, 209u8, 205u8, 174u8, 182u8, 17u8, 81u8, 129u8, 210u8,
            ],
            [
                209u8, 193u8, 159u8, 188u8, 212u8, 85u8, 26u8, 94u8, 223u8, 182u8, 109u8,
                67u8, 210u8, 227u8, 55u8, 192u8, 72u8, 55u8, 175u8, 218u8, 52u8, 130u8,
                180u8, 43u8, 223u8, 86u8, 154u8, 143u8, 204u8, 218u8, 229u8, 251u8,
            ],
            [
                218u8, 43u8, 81u8, 52u8, 16u8, 121u8, 243u8, 221u8, 142u8, 103u8, 99u8,
                165u8, 15u8, 50u8, 155u8, 188u8, 61u8, 198u8, 202u8, 106u8, 81u8, 185u8,
                32u8, 254u8, 153u8, 251u8, 248u8, 154u8, 84u8, 236u8, 14u8, 39u8,
            ],
            [
                223u8, 152u8, 13u8, 33u8, 216u8, 199u8, 187u8, 52u8, 128u8, 14u8, 102u8,
                141u8, 190u8, 0u8, 50u8, 153u8, 9u8, 59u8, 172u8, 142u8, 105u8, 54u8,
                20u8, 21u8, 29u8, 60u8, 87u8, 247u8, 63u8, 152u8, 169u8, 61u8,
            ],
            [
                226u8, 195u8, 117u8, 174u8, 112u8, 239u8, 168u8, 47u8, 127u8, 29u8,
                142u8, 149u8, 85u8, 248u8, 63u8, 45u8, 245u8, 198u8, 146u8, 214u8, 104u8,
                52u8, 235u8, 171u8, 186u8, 157u8, 137u8, 127u8, 202u8, 70u8, 243u8, 223u8,
            ],
            [
                227u8, 73u8, 24u8, 255u8, 28u8, 112u8, 132u8, 151u8, 0u8, 104u8, 181u8,
                63u8, 215u8, 26u8, 214u8, 216u8, 176u8, 78u8, 159u8, 21u8, 211u8, 136u8,
                108u8, 191u8, 0u8, 100u8, 67u8, 230u8, 205u8, 197u8, 46u8, 166u8,
            ],
            [
                228u8, 24u8, 53u8, 20u8, 199u8, 72u8, 48u8, 57u8, 83u8, 140u8, 209u8,
                249u8, 202u8, 32u8, 228u8, 137u8, 179u8, 196u8, 17u8, 243u8, 175u8, 18u8,
                17u8, 207u8, 107u8, 90u8, 208u8, 160u8, 12u8, 164u8, 226u8, 40u8,
            ],
            [
                235u8, 13u8, 155u8, 52u8, 239u8, 7u8, 27u8, 135u8, 218u8, 133u8, 145u8,
                221u8, 216u8, 44u8, 198u8, 127u8, 144u8, 198u8, 128u8, 98u8, 1u8, 181u8,
                201u8, 221u8, 201u8, 31u8, 6u8, 36u8, 103u8, 125u8, 200u8, 21u8,
            ],
            [
                246u8, 57u8, 31u8, 92u8, 50u8, 217u8, 198u8, 157u8, 42u8, 71u8, 234u8,
                103u8, 11u8, 68u8, 41u8, 116u8, 181u8, 57u8, 53u8, 209u8, 237u8, 199u8,
                253u8, 100u8, 235u8, 33u8, 224u8, 71u8, 168u8, 57u8, 23u8, 27u8,
            ],
            [
                247u8, 232u8, 116u8, 217u8, 253u8, 66u8, 131u8, 139u8, 15u8, 6u8, 164u8,
                76u8, 123u8, 190u8, 69u8, 65u8, 123u8, 153u8, 30u8, 107u8, 0u8, 14u8,
                140u8, 164u8, 197u8, 193u8, 240u8, 134u8, 8u8, 74u8, 156u8, 211u8,
            ],
            [
                252u8, 146u8, 116u8, 173u8, 100u8, 171u8, 10u8, 125u8, 141u8, 237u8,
                216u8, 201u8, 41u8, 127u8, 180u8, 226u8, 93u8, 122u8, 23u8, 235u8, 5u8,
                116u8, 87u8, 198u8, 188u8, 242u8, 168u8, 241u8, 61u8, 200u8, 133u8, 156u8,
            ],
            [
                253u8, 71u8, 237u8, 142u8, 101u8, 63u8, 186u8, 94u8, 110u8, 159u8, 202u8,
                169u8, 71u8, 65u8, 156u8, 162u8, 51u8, 75u8, 57u8, 114u8, 206u8, 25u8,
                97u8, 50u8, 236u8, 105u8, 112u8, 133u8, 116u8, 214u8, 211u8, 90u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(DelegatorUnstakeScheduled),
            ::core::stringify!(OperatorSlashed),
            ::core::stringify!(RewardClaimed),
            ::core::stringify!(OperatorLeft),
            ::core::stringify!(SlashRecorded),
            ::core::stringify!(RoleGranted),
            ::core::stringify!(OperatorBlueprintRemoved),
            ::core::stringify!(Delegated),
            ::core::stringify!(Unpaused),
            ::core::stringify!(OperatorStakeIncreased),
            ::core::stringify!(Paused),
            ::core::stringify!(Deposited),
            ::core::stringify!(RoundAdvanced),
            ::core::stringify!(Slashed),
            ::core::stringify!(WithdrawScheduled),
            ::core::stringify!(AssetEnabled),
            ::core::stringify!(BlueprintAddedToDelegation),
            ::core::stringify!(OperatorBlueprintAdded),
            ::core::stringify!(OperatorRegistered),
            ::core::stringify!(Upgraded),
            ::core::stringify!(RoleAdminChanged),
            ::core::stringify!(BlueprintRemovedFromDelegation),
            ::core::stringify!(AdapterRegistered),
            ::core::stringify!(Initialized),
            ::core::stringify!(Withdrawn),
            ::core::stringify!(OperatorUnstakeExecuted),
            ::core::stringify!(AdapterRemoved),
            ::core::stringify!(RequireAdaptersUpdated),
            ::core::stringify!(RewardDistributed),
            ::core::stringify!(DelegatorUnstakeExecuted),
            ::core::stringify!(SlashedForService),
            ::core::stringify!(RoleRevoked),
            ::core::stringify!(OperatorUnstakeScheduled),
            ::core::stringify!(AssetDisabled),
            ::core::stringify!(OperatorLeavingScheduled),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <DelegatorUnstakeScheduled as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorSlashed as alloy_sol_types::SolEvent>::SIGNATURE,
            <RewardClaimed as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorLeft as alloy_sol_types::SolEvent>::SIGNATURE,
            <SlashRecorded as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorBlueprintRemoved as alloy_sol_types::SolEvent>::SIGNATURE,
            <Delegated as alloy_sol_types::SolEvent>::SIGNATURE,
            <Unpaused as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorStakeIncreased as alloy_sol_types::SolEvent>::SIGNATURE,
            <Paused as alloy_sol_types::SolEvent>::SIGNATURE,
            <Deposited as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoundAdvanced as alloy_sol_types::SolEvent>::SIGNATURE,
            <Slashed as alloy_sol_types::SolEvent>::SIGNATURE,
            <WithdrawScheduled as alloy_sol_types::SolEvent>::SIGNATURE,
            <AssetEnabled as alloy_sol_types::SolEvent>::SIGNATURE,
            <BlueprintAddedToDelegation as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorBlueprintAdded as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorRegistered as alloy_sol_types::SolEvent>::SIGNATURE,
            <Upgraded as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE,
            <BlueprintRemovedFromDelegation as alloy_sol_types::SolEvent>::SIGNATURE,
            <AdapterRegistered as alloy_sol_types::SolEvent>::SIGNATURE,
            <Initialized as alloy_sol_types::SolEvent>::SIGNATURE,
            <Withdrawn as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorUnstakeExecuted as alloy_sol_types::SolEvent>::SIGNATURE,
            <AdapterRemoved as alloy_sol_types::SolEvent>::SIGNATURE,
            <RequireAdaptersUpdated as alloy_sol_types::SolEvent>::SIGNATURE,
            <RewardDistributed as alloy_sol_types::SolEvent>::SIGNATURE,
            <DelegatorUnstakeExecuted as alloy_sol_types::SolEvent>::SIGNATURE,
            <SlashedForService as alloy_sol_types::SolEvent>::SIGNATURE,
            <RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorUnstakeScheduled as alloy_sol_types::SolEvent>::SIGNATURE,
            <AssetDisabled as alloy_sol_types::SolEvent>::SIGNATURE,
            <OperatorLeavingScheduled as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for MultiAssetDelegationExposedEvents {
        const NAME: &'static str = "MultiAssetDelegationExposedEvents";
        const COUNT: usize = 35usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AdapterRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AdapterRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::AdapterRegistered)
                }
                Some(<AdapterRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <AdapterRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::AdapterRemoved)
                }
                Some(<AssetDisabled as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <AssetDisabled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::AssetDisabled)
                }
                Some(<AssetEnabled as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <AssetEnabled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::AssetEnabled)
                }
                Some(
                    <BlueprintAddedToDelegation as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlueprintAddedToDelegation as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BlueprintAddedToDelegation)
                }
                Some(
                    <BlueprintRemovedFromDelegation as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlueprintRemovedFromDelegation as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BlueprintRemovedFromDelegation)
                }
                Some(<Delegated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Delegated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Delegated)
                }
                Some(
                    <DelegatorUnstakeExecuted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DelegatorUnstakeExecuted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DelegatorUnstakeExecuted)
                }
                Some(
                    <DelegatorUnstakeScheduled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <DelegatorUnstakeScheduled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::DelegatorUnstakeScheduled)
                }
                Some(<Deposited as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Deposited as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Deposited)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Initialized)
                }
                Some(
                    <OperatorBlueprintAdded as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorBlueprintAdded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorBlueprintAdded)
                }
                Some(
                    <OperatorBlueprintRemoved as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorBlueprintRemoved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorBlueprintRemoved)
                }
                Some(
                    <OperatorLeavingScheduled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorLeavingScheduled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorLeavingScheduled)
                }
                Some(<OperatorLeft as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorLeft as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorLeft)
                }
                Some(
                    <OperatorRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorRegistered)
                }
                Some(<OperatorSlashed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorSlashed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorSlashed)
                }
                Some(
                    <OperatorStakeIncreased as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorStakeIncreased as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorStakeIncreased)
                }
                Some(
                    <OperatorUnstakeExecuted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorUnstakeExecuted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorUnstakeExecuted)
                }
                Some(
                    <OperatorUnstakeScheduled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorUnstakeScheduled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OperatorUnstakeScheduled)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Paused)
                }
                Some(
                    <RequireAdaptersUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RequireAdaptersUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RequireAdaptersUpdated)
                }
                Some(<RewardClaimed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RewardClaimed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RewardClaimed)
                }
                Some(
                    <RewardDistributed as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RewardDistributed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RewardDistributed)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<RoundAdvanced as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoundAdvanced as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RoundAdvanced)
                }
                Some(<SlashRecorded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SlashRecorded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SlashRecorded)
                }
                Some(<Slashed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Slashed as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Slashed)
                }
                Some(
                    <SlashedForService as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SlashedForService as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SlashedForService)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Unpaused)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(topics, data)
                        .map(Self::Upgraded)
                }
                Some(
                    <WithdrawScheduled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <WithdrawScheduled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::WithdrawScheduled)
                }
                Some(<Withdrawn as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Withdrawn as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::Withdrawn)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for MultiAssetDelegationExposedEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AdapterRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::AdapterRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::AssetDisabled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::AssetEnabled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlueprintAddedToDelegation(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlueprintRemovedFromDelegation(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Delegated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegatorUnstakeExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::DelegatorUnstakeScheduled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Deposited(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorBlueprintAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorBlueprintRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorLeavingScheduled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorLeft(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorSlashed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorStakeIncreased(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorUnstakeExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorUnstakeScheduled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RequireAdaptersUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RewardClaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RewardDistributed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoundAdvanced(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SlashRecorded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Slashed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SlashedForService(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::WithdrawScheduled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Withdrawn(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AdapterRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::AdapterRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::AssetDisabled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::AssetEnabled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlueprintAddedToDelegation(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlueprintRemovedFromDelegation(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Delegated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegatorUnstakeExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::DelegatorUnstakeScheduled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Deposited(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorBlueprintAdded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorBlueprintRemoved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorLeavingScheduled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorLeft(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorSlashed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorStakeIncreased(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorUnstakeExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorUnstakeScheduled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RequireAdaptersUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RewardClaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RewardDistributed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoundAdvanced(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SlashRecorded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Slashed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SlashedForService(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::WithdrawScheduled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Withdrawn(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`MultiAssetDelegationExposed`](self) contract instance.

See the [wrapper's documentation](`MultiAssetDelegationExposedInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> MultiAssetDelegationExposedInstance<P, N> {
        MultiAssetDelegationExposedInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<MultiAssetDelegationExposedInstance<P, N>>,
    > {
        MultiAssetDelegationExposedInstance::<P, N>::deploy(__provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
        MultiAssetDelegationExposedInstance::<P, N>::deploy_builder(__provider)
    }
    /**A [`MultiAssetDelegationExposed`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`MultiAssetDelegationExposed`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct MultiAssetDelegationExposedInstance<
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for MultiAssetDelegationExposedInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("MultiAssetDelegationExposedInstance")
                .field(&self.address)
                .finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MultiAssetDelegationExposedInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`MultiAssetDelegationExposed`](self) contract instance.

See the [wrapper's documentation](`MultiAssetDelegationExposedInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
        ) -> alloy_contract::Result<MultiAssetDelegationExposedInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(__provider: P) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> MultiAssetDelegationExposedInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> MultiAssetDelegationExposedInstance<P, N> {
            MultiAssetDelegationExposedInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MultiAssetDelegationExposedInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`ADMIN_ROLE`] function.
        pub fn ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, ADMIN_ROLECall, N> {
            self.call_builder(&ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`ASSET_MANAGER_ROLE`] function.
        pub fn ASSET_MANAGER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, ASSET_MANAGER_ROLECall, N> {
            self.call_builder(&ASSET_MANAGER_ROLECall)
        }
        ///Creates a new call builder for the [`BPS_DENOMINATOR`] function.
        pub fn BPS_DENOMINATOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, BPS_DENOMINATORCall, N> {
            self.call_builder(&BPS_DENOMINATORCall)
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall)
        }
        ///Creates a new call builder for the [`LOCK_ONE_MONTH`] function.
        pub fn LOCK_ONE_MONTH(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, LOCK_ONE_MONTHCall, N> {
            self.call_builder(&LOCK_ONE_MONTHCall)
        }
        ///Creates a new call builder for the [`LOCK_SIX_MONTHS`] function.
        pub fn LOCK_SIX_MONTHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, LOCK_SIX_MONTHSCall, N> {
            self.call_builder(&LOCK_SIX_MONTHSCall)
        }
        ///Creates a new call builder for the [`LOCK_THREE_MONTHS`] function.
        pub fn LOCK_THREE_MONTHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, LOCK_THREE_MONTHSCall, N> {
            self.call_builder(&LOCK_THREE_MONTHSCall)
        }
        ///Creates a new call builder for the [`LOCK_TWO_MONTHS`] function.
        pub fn LOCK_TWO_MONTHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, LOCK_TWO_MONTHSCall, N> {
            self.call_builder(&LOCK_TWO_MONTHSCall)
        }
        ///Creates a new call builder for the [`MULTIPLIER_NONE`] function.
        pub fn MULTIPLIER_NONE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MULTIPLIER_NONECall, N> {
            self.call_builder(&MULTIPLIER_NONECall)
        }
        ///Creates a new call builder for the [`MULTIPLIER_ONE_MONTH`] function.
        pub fn MULTIPLIER_ONE_MONTH(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MULTIPLIER_ONE_MONTHCall, N> {
            self.call_builder(&MULTIPLIER_ONE_MONTHCall)
        }
        ///Creates a new call builder for the [`MULTIPLIER_SIX_MONTHS`] function.
        pub fn MULTIPLIER_SIX_MONTHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MULTIPLIER_SIX_MONTHSCall, N> {
            self.call_builder(&MULTIPLIER_SIX_MONTHSCall)
        }
        ///Creates a new call builder for the [`MULTIPLIER_THREE_MONTHS`] function.
        pub fn MULTIPLIER_THREE_MONTHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MULTIPLIER_THREE_MONTHSCall, N> {
            self.call_builder(&MULTIPLIER_THREE_MONTHSCall)
        }
        ///Creates a new call builder for the [`MULTIPLIER_TWO_MONTHS`] function.
        pub fn MULTIPLIER_TWO_MONTHS(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, MULTIPLIER_TWO_MONTHSCall, N> {
            self.call_builder(&MULTIPLIER_TWO_MONTHSCall)
        }
        ///Creates a new call builder for the [`PRECISION`] function.
        pub fn PRECISION(&self) -> alloy_contract::SolCallBuilder<&P, PRECISIONCall, N> {
            self.call_builder(&PRECISIONCall)
        }
        ///Creates a new call builder for the [`SLASHER_ROLE`] function.
        pub fn SLASHER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, SLASHER_ROLECall, N> {
            self.call_builder(&SLASHER_ROLECall)
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall)
        }
        ///Creates a new call builder for the [`addBlueprint`] function.
        pub fn addBlueprint(
            &self,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<&P, addBlueprintCall, N> {
            self.call_builder(&addBlueprintCall { blueprintId })
        }
        ///Creates a new call builder for the [`addBlueprintToDelegation`] function.
        pub fn addBlueprintToDelegation(
            &self,
            delegationIndex: alloy::sol_types::private::primitives::aliases::U256,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<&P, addBlueprintToDelegationCall, N> {
            self.call_builder(
                &addBlueprintToDelegationCall {
                    delegationIndex,
                    blueprintId,
                },
            )
        }
        ///Creates a new call builder for the [`addSlasher`] function.
        pub fn addSlasher(
            &self,
            slasher: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, addSlasherCall, N> {
            self.call_builder(&addSlasherCall { slasher })
        }
        ///Creates a new call builder for the [`advanceRound`] function.
        pub fn advanceRound(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, advanceRoundCall, N> {
            self.call_builder(&advanceRoundCall)
        }
        ///Creates a new call builder for the [`blueprintPoolTotals`] function.
        pub fn blueprintPoolTotals(
            &self,
            operator: alloy::sol_types::private::Address,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<&P, blueprintPoolTotalsCall, N> {
            self.call_builder(
                &blueprintPoolTotalsCall {
                    operator,
                    blueprintId,
                },
            )
        }
        ///Creates a new call builder for the [`blueprintSlashCount`] function.
        pub fn blueprintSlashCount(
            &self,
            _0: u64,
            _1: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, blueprintSlashCountCall, N> {
            self.call_builder(&blueprintSlashCountCall { _0, _1 })
        }
        ///Creates a new call builder for the [`claimDelegatorRewards`] function.
        pub fn claimDelegatorRewards(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, claimDelegatorRewardsCall, N> {
            self.call_builder(&claimDelegatorRewardsCall)
        }
        ///Creates a new call builder for the [`claimOperatorRewards`] function.
        pub fn claimOperatorRewards(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, claimOperatorRewardsCall, N> {
            self.call_builder(&claimOperatorRewardsCall)
        }
        ///Creates a new call builder for the [`claimOperatorRewardsTo`] function.
        pub fn claimOperatorRewardsTo(
            &self,
            recipient: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, claimOperatorRewardsToCall, N> {
            self.call_builder(
                &claimOperatorRewardsToCall {
                    recipient,
                },
            )
        }
        ///Creates a new call builder for the [`completeLeaving`] function.
        pub fn completeLeaving(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, completeLeavingCall, N> {
            self.call_builder(&completeLeavingCall)
        }
        ///Creates a new call builder for the [`currentRound`] function.
        pub fn currentRound(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, currentRoundCall, N> {
            self.call_builder(&currentRoundCall)
        }
        ///Creates a new call builder for the [`delegate`] function.
        pub fn delegate(
            &self,
            operator: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, delegateCall, N> {
            self.call_builder(&delegateCall { operator, amount })
        }
        ///Creates a new call builder for the [`delegateWithOptions`] function.
        pub fn delegateWithOptions(
            &self,
            operator: alloy::sol_types::private::Address,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            selectionMode: <Types::BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
            blueprintIds: alloy::sol_types::private::Vec<u64>,
        ) -> alloy_contract::SolCallBuilder<&P, delegateWithOptionsCall, N> {
            self.call_builder(
                &delegateWithOptionsCall {
                    operator,
                    token,
                    amount,
                    selectionMode,
                    blueprintIds,
                },
            )
        }
        ///Creates a new call builder for the [`delegationBondLessDelay`] function.
        pub fn delegationBondLessDelay(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, delegationBondLessDelayCall, N> {
            self.call_builder(&delegationBondLessDelayCall)
        }
        ///Creates a new call builder for the [`deposit`] function.
        pub fn deposit(&self) -> alloy_contract::SolCallBuilder<&P, depositCall, N> {
            self.call_builder(&depositCall)
        }
        ///Creates a new call builder for the [`depositAndDelegate`] function.
        pub fn depositAndDelegate(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, depositAndDelegateCall, N> {
            self.call_builder(&depositAndDelegateCall { operator })
        }
        ///Creates a new call builder for the [`depositAndDelegateWithOptions`] function.
        pub fn depositAndDelegateWithOptions(
            &self,
            operator: alloy::sol_types::private::Address,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            selectionMode: <Types::BlueprintSelectionMode as alloy::sol_types::SolType>::RustType,
            blueprintIds: alloy::sol_types::private::Vec<u64>,
        ) -> alloy_contract::SolCallBuilder<&P, depositAndDelegateWithOptionsCall, N> {
            self.call_builder(
                &depositAndDelegateWithOptionsCall {
                    operator,
                    token,
                    amount,
                    selectionMode,
                    blueprintIds,
                },
            )
        }
        ///Creates a new call builder for the [`depositERC20`] function.
        pub fn depositERC20(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, depositERC20Call, N> {
            self.call_builder(&depositERC20Call { token, amount })
        }
        ///Creates a new call builder for the [`depositERC20WithLock`] function.
        pub fn depositERC20WithLock(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            lockMultiplier: <Types::LockMultiplier as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, depositERC20WithLockCall, N> {
            self.call_builder(
                &depositERC20WithLockCall {
                    token,
                    amount,
                    lockMultiplier,
                },
            )
        }
        ///Creates a new call builder for the [`depositWithLock`] function.
        pub fn depositWithLock(
            &self,
            lockMultiplier: <Types::LockMultiplier as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, depositWithLockCall, N> {
            self.call_builder(
                &depositWithLockCall {
                    lockMultiplier,
                },
            )
        }
        ///Creates a new call builder for the [`disableAsset`] function.
        pub fn disableAsset(
            &self,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, disableAssetCall, N> {
            self.call_builder(&disableAssetCall { token })
        }
        ///Creates a new call builder for the [`enableAsset`] function.
        pub fn enableAsset(
            &self,
            token: alloy::sol_types::private::Address,
            _minOperatorStake: alloy::sol_types::private::primitives::aliases::U256,
            _minDelegation: alloy::sol_types::private::primitives::aliases::U256,
            _depositCap: alloy::sol_types::private::primitives::aliases::U256,
            _rewardMultiplierBps: u16,
        ) -> alloy_contract::SolCallBuilder<&P, enableAssetCall, N> {
            self.call_builder(
                &enableAssetCall {
                    token,
                    _minOperatorStake,
                    _minDelegation,
                    _depositCap,
                    _rewardMultiplierBps,
                },
            )
        }
        ///Creates a new call builder for the [`enableAssetWithAdapter`] function.
        pub fn enableAssetWithAdapter(
            &self,
            token: alloy::sol_types::private::Address,
            adapter: alloy::sol_types::private::Address,
            _minOperatorStake: alloy::sol_types::private::primitives::aliases::U256,
            _minDelegation: alloy::sol_types::private::primitives::aliases::U256,
            _depositCap: alloy::sol_types::private::primitives::aliases::U256,
            _rewardMultiplierBps: u16,
        ) -> alloy_contract::SolCallBuilder<&P, enableAssetWithAdapterCall, N> {
            self.call_builder(
                &enableAssetWithAdapterCall {
                    token,
                    adapter,
                    _minOperatorStake,
                    _minDelegation,
                    _depositCap,
                    _rewardMultiplierBps,
                },
            )
        }
        ///Creates a new call builder for the [`executeDelegatorUnstake`] function.
        pub fn executeDelegatorUnstake(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, executeDelegatorUnstakeCall, N> {
            self.call_builder(&executeDelegatorUnstakeCall)
        }
        ///Creates a new call builder for the [`executeOperatorUnstake`] function.
        pub fn executeOperatorUnstake(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, executeOperatorUnstakeCall, N> {
            self.call_builder(&executeOperatorUnstakeCall)
        }
        ///Creates a new call builder for the [`executeWithdraw`] function.
        pub fn executeWithdraw(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, executeWithdrawCall, N> {
            self.call_builder(&executeWithdrawCall)
        }
        ///Creates a new call builder for the [`getAssetAdapter`] function.
        pub fn getAssetAdapter(
            &self,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getAssetAdapterCall, N> {
            self.call_builder(&getAssetAdapterCall { token })
        }
        ///Creates a new call builder for the [`getAssetConfig`] function.
        pub fn getAssetConfig(
            &self,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getAssetConfigCall, N> {
            self.call_builder(&getAssetConfigCall { token })
        }
        ///Creates a new call builder for the [`getDelegation`] function.
        pub fn getDelegation(
            &self,
            delegator: alloy::sol_types::private::Address,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getDelegationCall, N> {
            self.call_builder(
                &getDelegationCall {
                    delegator,
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getDelegationBlueprints`] function.
        pub fn getDelegationBlueprints(
            &self,
            delegator: alloy::sol_types::private::Address,
            idx: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, getDelegationBlueprintsCall, N> {
            self.call_builder(
                &getDelegationBlueprintsCall {
                    delegator,
                    idx,
                },
            )
        }
        ///Creates a new call builder for the [`getDelegations`] function.
        pub fn getDelegations(
            &self,
            delegator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getDelegationsCall, N> {
            self.call_builder(&getDelegationsCall { delegator })
        }
        ///Creates a new call builder for the [`getDeposit`] function.
        pub fn getDeposit(
            &self,
            delegator: alloy::sol_types::private::Address,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getDepositCall, N> {
            self.call_builder(&getDepositCall { delegator, token })
        }
        ///Creates a new call builder for the [`getLocks`] function.
        pub fn getLocks(
            &self,
            delegator: alloy::sol_types::private::Address,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getLocksCall, N> {
            self.call_builder(&getLocksCall { delegator, token })
        }
        ///Creates a new call builder for the [`getOperatorBlueprints`] function.
        pub fn getOperatorBlueprints(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorBlueprintsCall, N> {
            self.call_builder(
                &getOperatorBlueprintsCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorDelegatedStake`] function.
        pub fn getOperatorDelegatedStake(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorDelegatedStakeCall, N> {
            self.call_builder(
                &getOperatorDelegatedStakeCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorDelegatorCount`] function.
        pub fn getOperatorDelegatorCount(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorDelegatorCountCall, N> {
            self.call_builder(
                &getOperatorDelegatorCountCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorDelegators`] function.
        pub fn getOperatorDelegators(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorDelegatorsCall, N> {
            self.call_builder(
                &getOperatorDelegatorsCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorMetadata`] function.
        pub fn getOperatorMetadata(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorMetadataCall, N> {
            self.call_builder(
                &getOperatorMetadataCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorRewardPool`] function.
        pub fn getOperatorRewardPool(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorRewardPoolCall, N> {
            self.call_builder(
                &getOperatorRewardPoolCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorSelfStake`] function.
        pub fn getOperatorSelfStake(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorSelfStakeCall, N> {
            self.call_builder(
                &getOperatorSelfStakeCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorSlashFactor`] function.
        pub fn getOperatorSlashFactor(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorSlashFactorCall, N> {
            self.call_builder(
                &getOperatorSlashFactorCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorStake`] function.
        pub fn getOperatorStake(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getOperatorStakeCall, N> {
            self.call_builder(&getOperatorStakeCall { operator })
        }
        ///Creates a new call builder for the [`getPendingDelegatorRewards`] function.
        pub fn getPendingDelegatorRewards(
            &self,
            delegator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getPendingDelegatorRewardsCall, N> {
            self.call_builder(
                &getPendingDelegatorRewardsCall {
                    delegator,
                },
            )
        }
        ///Creates a new call builder for the [`getPendingOperatorRewards`] function.
        pub fn getPendingOperatorRewards(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getPendingOperatorRewardsCall, N> {
            self.call_builder(
                &getPendingOperatorRewardsCall {
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getPendingUnstakes`] function.
        pub fn getPendingUnstakes(
            &self,
            delegator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getPendingUnstakesCall, N> {
            self.call_builder(
                &getPendingUnstakesCall {
                    delegator,
                },
            )
        }
        ///Creates a new call builder for the [`getPendingWithdrawals`] function.
        pub fn getPendingWithdrawals(
            &self,
            delegator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getPendingWithdrawalsCall, N> {
            self.call_builder(
                &getPendingWithdrawalsCall {
                    delegator,
                },
            )
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getSlashCount`] function.
        pub fn getSlashCount(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getSlashCountCall, N> {
            self.call_builder(&getSlashCountCall { operator })
        }
        ///Creates a new call builder for the [`getSlashCountForBlueprint`] function.
        pub fn getSlashCountForBlueprint(
            &self,
            blueprintId: u64,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getSlashCountForBlueprintCall, N> {
            self.call_builder(
                &getSlashCountForBlueprintCall {
                    blueprintId,
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getSlashCountForService`] function.
        pub fn getSlashCountForService(
            &self,
            serviceId: u64,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getSlashCountForServiceCall, N> {
            self.call_builder(
                &getSlashCountForServiceCall {
                    serviceId,
                    operator,
                },
            )
        }
        ///Creates a new call builder for the [`getSlashImpact`] function.
        pub fn getSlashImpact(
            &self,
            operator: alloy::sol_types::private::Address,
            slashId: u64,
            delegator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getSlashImpactCall, N> {
            self.call_builder(
                &getSlashImpactCall {
                    operator,
                    slashId,
                    delegator,
                },
            )
        }
        ///Creates a new call builder for the [`getSlashRecord`] function.
        pub fn getSlashRecord(
            &self,
            operator: alloy::sol_types::private::Address,
            slashId: u64,
        ) -> alloy_contract::SolCallBuilder<&P, getSlashRecordCall, N> {
            self.call_builder(
                &getSlashRecordCall {
                    operator,
                    slashId,
                },
            )
        }
        ///Creates a new call builder for the [`getSnapshot`] function.
        pub fn getSnapshot(
            &self,
            round: u64,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getSnapshotCall, N> {
            self.call_builder(&getSnapshotCall { round, operator })
        }
        ///Creates a new call builder for the [`getTotalDelegation`] function.
        pub fn getTotalDelegation(
            &self,
            delegator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, getTotalDelegationCall, N> {
            self.call_builder(
                &getTotalDelegationCall {
                    delegator,
                },
            )
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`increaseStake`] function.
        pub fn increaseStake(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, increaseStakeCall, N> {
            self.call_builder(&increaseStakeCall)
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            admin: alloy::sol_types::private::Address,
            nativeMinOperatorStake: alloy::sol_types::private::primitives::aliases::U256,
            nativeMinDelegation: alloy::sol_types::private::primitives::aliases::U256,
            _operatorCommissionBps: u16,
        ) -> alloy_contract::SolCallBuilder<&P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    admin,
                    nativeMinOperatorStake,
                    nativeMinDelegation,
                    _operatorCommissionBps,
                },
            )
        }
        ///Creates a new call builder for the [`isOperator`] function.
        pub fn isOperator(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isOperatorCall, N> {
            self.call_builder(&isOperatorCall { operator })
        }
        ///Creates a new call builder for the [`isOperatorActive`] function.
        pub fn isOperatorActive(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isOperatorActiveCall, N> {
            self.call_builder(&isOperatorActiveCall { operator })
        }
        ///Creates a new call builder for the [`isSlasher`] function.
        pub fn isSlasher(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, isSlasherCall, N> {
            self.call_builder(&isSlasherCall { account })
        }
        ///Creates a new call builder for the [`lastRoundAdvance`] function.
        pub fn lastRoundAdvance(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, lastRoundAdvanceCall, N> {
            self.call_builder(&lastRoundAdvanceCall)
        }
        ///Creates a new call builder for the [`leaveDelegatorsDelay`] function.
        pub fn leaveDelegatorsDelay(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, leaveDelegatorsDelayCall, N> {
            self.call_builder(&leaveDelegatorsDelayCall)
        }
        ///Creates a new call builder for the [`leaveOperatorsDelay`] function.
        pub fn leaveOperatorsDelay(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, leaveOperatorsDelayCall, N> {
            self.call_builder(&leaveOperatorsDelayCall)
        }
        ///Creates a new call builder for the [`meetsStakeRequirement`] function.
        pub fn meetsStakeRequirement(
            &self,
            operator: alloy::sol_types::private::Address,
            required: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, meetsStakeRequirementCall, N> {
            self.call_builder(
                &meetsStakeRequirementCall {
                    operator,
                    required,
                },
            )
        }
        ///Creates a new call builder for the [`minOperatorStake`] function.
        pub fn minOperatorStake(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, minOperatorStakeCall, N> {
            self.call_builder(&minOperatorStakeCall)
        }
        ///Creates a new call builder for the [`nativeEnabled`] function.
        pub fn nativeEnabled(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, nativeEnabledCall, N> {
            self.call_builder(&nativeEnabledCall)
        }
        ///Creates a new call builder for the [`nextSlashId`] function.
        pub fn nextSlashId(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, nextSlashIdCall, N> {
            self.call_builder(&nextSlashIdCall(_0))
        }
        ///Creates a new call builder for the [`notifyReward`] function.
        pub fn notifyReward(
            &self,
            operator: alloy::sol_types::private::Address,
            serviceId: u64,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, notifyRewardCall, N> {
            self.call_builder(
                &notifyRewardCall {
                    operator,
                    serviceId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`notifyRewardForBlueprint`] function.
        pub fn notifyRewardForBlueprint(
            &self,
            operator: alloy::sol_types::private::Address,
            blueprintId: u64,
            serviceId: u64,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, notifyRewardForBlueprintCall, N> {
            self.call_builder(
                &notifyRewardForBlueprintCall {
                    operator,
                    blueprintId,
                    serviceId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`operatorAt`] function.
        pub fn operatorAt(
            &self,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, operatorAtCall, N> {
            self.call_builder(&operatorAtCall { index })
        }
        ///Creates a new call builder for the [`operatorCommissionBps`] function.
        pub fn operatorCommissionBps(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, operatorCommissionBpsCall, N> {
            self.call_builder(&operatorCommissionBpsCall)
        }
        ///Creates a new call builder for the [`operatorCount`] function.
        pub fn operatorCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, operatorCountCall, N> {
            self.call_builder(&operatorCountCall)
        }
        ///Creates a new call builder for the [`operatorStake`] function.
        pub fn operatorStake(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, operatorStakeCall, N> {
            self.call_builder(&operatorStakeCall { operator })
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<&P, pauseCall, N> {
            self.call_builder(&pauseCall)
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<&P, pausedCall, N> {
            self.call_builder(&pausedCall)
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall)
        }
        ///Creates a new call builder for the [`registerAdapter`] function.
        pub fn registerAdapter(
            &self,
            token: alloy::sol_types::private::Address,
            adapter: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, registerAdapterCall, N> {
            self.call_builder(
                &registerAdapterCall {
                    token,
                    adapter,
                },
            )
        }
        ///Creates a new call builder for the [`registerOperator`] function.
        pub fn registerOperator(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, registerOperatorCall, N> {
            self.call_builder(&registerOperatorCall)
        }
        ///Creates a new call builder for the [`registerOperatorWithAsset`] function.
        pub fn registerOperatorWithAsset(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, registerOperatorWithAssetCall, N> {
            self.call_builder(
                &registerOperatorWithAssetCall {
                    token,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`removeAdapter`] function.
        pub fn removeAdapter(
            &self,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, removeAdapterCall, N> {
            self.call_builder(&removeAdapterCall { token })
        }
        ///Creates a new call builder for the [`removeBlueprint`] function.
        pub fn removeBlueprint(
            &self,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<&P, removeBlueprintCall, N> {
            self.call_builder(&removeBlueprintCall { blueprintId })
        }
        ///Creates a new call builder for the [`removeBlueprintFromDelegation`] function.
        pub fn removeBlueprintFromDelegation(
            &self,
            delegationIndex: alloy::sol_types::private::primitives::aliases::U256,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<&P, removeBlueprintFromDelegationCall, N> {
            self.call_builder(
                &removeBlueprintFromDelegationCall {
                    delegationIndex,
                    blueprintId,
                },
            )
        }
        ///Creates a new call builder for the [`removeSlasher`] function.
        pub fn removeSlasher(
            &self,
            slasher: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, removeSlasherCall, N> {
            self.call_builder(&removeSlasherCall { slasher })
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`requireAdapters`] function.
        pub fn requireAdapters(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, requireAdaptersCall, N> {
            self.call_builder(&requireAdaptersCall)
        }
        ///Creates a new call builder for the [`rescueTokens`] function.
        pub fn rescueTokens(
            &self,
            token: alloy::sol_types::private::Address,
            to: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, rescueTokensCall, N> {
            self.call_builder(
                &rescueTokensCall {
                    token,
                    to,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`rewardPoolTotals`] function.
        pub fn rewardPoolTotals(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, rewardPoolTotalsCall, N> {
            self.call_builder(&rewardPoolTotalsCall { operator })
        }
        ///Creates a new call builder for the [`rewardsManager`] function.
        pub fn rewardsManager(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, rewardsManagerCall, N> {
            self.call_builder(&rewardsManagerCall)
        }
        ///Creates a new call builder for the [`roundDuration`] function.
        pub fn roundDuration(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, roundDurationCall, N> {
            self.call_builder(&roundDurationCall)
        }
        ///Creates a new call builder for the [`scheduleDelegatorUnstake`] function.
        pub fn scheduleDelegatorUnstake(
            &self,
            operator: alloy::sol_types::private::Address,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, scheduleDelegatorUnstakeCall, N> {
            self.call_builder(
                &scheduleDelegatorUnstakeCall {
                    operator,
                    token,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`scheduleOperatorUnstake`] function.
        pub fn scheduleOperatorUnstake(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, scheduleOperatorUnstakeCall, N> {
            self.call_builder(
                &scheduleOperatorUnstakeCall {
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`scheduleWithdraw`] function.
        pub fn scheduleWithdraw(
            &self,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, scheduleWithdrawCall, N> {
            self.call_builder(
                &scheduleWithdrawCall {
                    token,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`serviceFeeDistributor`] function.
        pub fn serviceFeeDistributor(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, serviceFeeDistributorCall, N> {
            self.call_builder(&serviceFeeDistributorCall)
        }
        ///Creates a new call builder for the [`serviceSlashCount`] function.
        pub fn serviceSlashCount(
            &self,
            _0: u64,
            _1: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, serviceSlashCountCall, N> {
            self.call_builder(&serviceSlashCountCall { _0, _1 })
        }
        ///Creates a new call builder for the [`setDelays`] function.
        pub fn setDelays(
            &self,
            _delegationBondLessDelay: u64,
            _leaveDelegatorsDelay: u64,
            _leaveOperatorsDelay: u64,
        ) -> alloy_contract::SolCallBuilder<&P, setDelaysCall, N> {
            self.call_builder(
                &setDelaysCall {
                    _delegationBondLessDelay,
                    _leaveDelegatorsDelay,
                    _leaveOperatorsDelay,
                },
            )
        }
        ///Creates a new call builder for the [`setOperatorCommission`] function.
        pub fn setOperatorCommission(
            &self,
            bps: u16,
        ) -> alloy_contract::SolCallBuilder<&P, setOperatorCommissionCall, N> {
            self.call_builder(&setOperatorCommissionCall { bps })
        }
        ///Creates a new call builder for the [`setRequireAdapters`] function.
        pub fn setRequireAdapters(
            &self,
            required: bool,
        ) -> alloy_contract::SolCallBuilder<&P, setRequireAdaptersCall, N> {
            self.call_builder(&setRequireAdaptersCall { required })
        }
        ///Creates a new call builder for the [`setRewardsManager`] function.
        pub fn setRewardsManager(
            &self,
            manager: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setRewardsManagerCall, N> {
            self.call_builder(&setRewardsManagerCall { manager })
        }
        ///Creates a new call builder for the [`setServiceFeeDistributor`] function.
        pub fn setServiceFeeDistributor(
            &self,
            distributor: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setServiceFeeDistributorCall, N> {
            self.call_builder(
                &setServiceFeeDistributorCall {
                    distributor,
                },
            )
        }
        ///Creates a new call builder for the [`slash`] function.
        pub fn slash(
            &self,
            operator: alloy::sol_types::private::Address,
            serviceId: u64,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            evidence: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, slashCall, N> {
            self.call_builder(
                &slashCall {
                    operator,
                    serviceId,
                    amount,
                    evidence,
                },
            )
        }
        ///Creates a new call builder for the [`slashForBlueprint`] function.
        pub fn slashForBlueprint(
            &self,
            operator: alloy::sol_types::private::Address,
            blueprintId: u64,
            serviceId: u64,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            evidence: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, slashForBlueprintCall, N> {
            self.call_builder(
                &slashForBlueprintCall {
                    operator,
                    blueprintId,
                    serviceId,
                    amount,
                    evidence,
                },
            )
        }
        ///Creates a new call builder for the [`slashForService`] function.
        pub fn slashForService(
            &self,
            operator: alloy::sol_types::private::Address,
            blueprintId: u64,
            serviceId: u64,
            commitments: alloy::sol_types::private::Vec<
                <Types::AssetSecurityCommitment as alloy::sol_types::SolType>::RustType,
            >,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            evidence: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, slashForServiceCall, N> {
            self.call_builder(
                &slashForServiceCall {
                    operator,
                    blueprintId,
                    serviceId,
                    commitments,
                    amount,
                    evidence,
                },
            )
        }
        ///Creates a new call builder for the [`slashHistory`] function.
        pub fn slashHistory(
            &self,
            _0: alloy::sol_types::private::Address,
            _1: u64,
        ) -> alloy_contract::SolCallBuilder<&P, slashHistoryCall, N> {
            self.call_builder(&slashHistoryCall { _0, _1 })
        }
        ///Creates a new call builder for the [`snapshotOperator`] function.
        pub fn snapshotOperator(
            &self,
            operator: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, snapshotOperatorCall, N> {
            self.call_builder(&snapshotOperatorCall { operator })
        }
        ///Creates a new call builder for the [`startLeaving`] function.
        pub fn startLeaving(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, startLeavingCall, N> {
            self.call_builder(&startLeavingCall)
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<&P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`undelegate`] function.
        pub fn undelegate(
            &self,
            operator: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, undelegateCall, N> {
            self.call_builder(&undelegateCall { operator, amount })
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<&P, unpauseCall, N> {
            self.call_builder(&unpauseCall)
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<&P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > MultiAssetDelegationExposedInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AdapterRegistered`] event.
        pub fn AdapterRegistered_filter(
            &self,
        ) -> alloy_contract::Event<&P, AdapterRegistered, N> {
            self.event_filter::<AdapterRegistered>()
        }
        ///Creates a new event filter for the [`AdapterRemoved`] event.
        pub fn AdapterRemoved_filter(
            &self,
        ) -> alloy_contract::Event<&P, AdapterRemoved, N> {
            self.event_filter::<AdapterRemoved>()
        }
        ///Creates a new event filter for the [`AssetDisabled`] event.
        pub fn AssetDisabled_filter(
            &self,
        ) -> alloy_contract::Event<&P, AssetDisabled, N> {
            self.event_filter::<AssetDisabled>()
        }
        ///Creates a new event filter for the [`AssetEnabled`] event.
        pub fn AssetEnabled_filter(&self) -> alloy_contract::Event<&P, AssetEnabled, N> {
            self.event_filter::<AssetEnabled>()
        }
        ///Creates a new event filter for the [`BlueprintAddedToDelegation`] event.
        pub fn BlueprintAddedToDelegation_filter(
            &self,
        ) -> alloy_contract::Event<&P, BlueprintAddedToDelegation, N> {
            self.event_filter::<BlueprintAddedToDelegation>()
        }
        ///Creates a new event filter for the [`BlueprintRemovedFromDelegation`] event.
        pub fn BlueprintRemovedFromDelegation_filter(
            &self,
        ) -> alloy_contract::Event<&P, BlueprintRemovedFromDelegation, N> {
            self.event_filter::<BlueprintRemovedFromDelegation>()
        }
        ///Creates a new event filter for the [`Delegated`] event.
        pub fn Delegated_filter(&self) -> alloy_contract::Event<&P, Delegated, N> {
            self.event_filter::<Delegated>()
        }
        ///Creates a new event filter for the [`DelegatorUnstakeExecuted`] event.
        pub fn DelegatorUnstakeExecuted_filter(
            &self,
        ) -> alloy_contract::Event<&P, DelegatorUnstakeExecuted, N> {
            self.event_filter::<DelegatorUnstakeExecuted>()
        }
        ///Creates a new event filter for the [`DelegatorUnstakeScheduled`] event.
        pub fn DelegatorUnstakeScheduled_filter(
            &self,
        ) -> alloy_contract::Event<&P, DelegatorUnstakeScheduled, N> {
            self.event_filter::<DelegatorUnstakeScheduled>()
        }
        ///Creates a new event filter for the [`Deposited`] event.
        pub fn Deposited_filter(&self) -> alloy_contract::Event<&P, Deposited, N> {
            self.event_filter::<Deposited>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(&self) -> alloy_contract::Event<&P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`OperatorBlueprintAdded`] event.
        pub fn OperatorBlueprintAdded_filter(
            &self,
        ) -> alloy_contract::Event<&P, OperatorBlueprintAdded, N> {
            self.event_filter::<OperatorBlueprintAdded>()
        }
        ///Creates a new event filter for the [`OperatorBlueprintRemoved`] event.
        pub fn OperatorBlueprintRemoved_filter(
            &self,
        ) -> alloy_contract::Event<&P, OperatorBlueprintRemoved, N> {
            self.event_filter::<OperatorBlueprintRemoved>()
        }
        ///Creates a new event filter for the [`OperatorLeavingScheduled`] event.
        pub fn OperatorLeavingScheduled_filter(
            &self,
        ) -> alloy_contract::Event<&P, OperatorLeavingScheduled, N> {
            self.event_filter::<OperatorLeavingScheduled>()
        }
        ///Creates a new event filter for the [`OperatorLeft`] event.
        pub fn OperatorLeft_filter(&self) -> alloy_contract::Event<&P, OperatorLeft, N> {
            self.event_filter::<OperatorLeft>()
        }
        ///Creates a new event filter for the [`OperatorRegistered`] event.
        pub fn OperatorRegistered_filter(
            &self,
        ) -> alloy_contract::Event<&P, OperatorRegistered, N> {
            self.event_filter::<OperatorRegistered>()
        }
        ///Creates a new event filter for the [`OperatorSlashed`] event.
        pub fn OperatorSlashed_filter(
            &self,
        ) -> alloy_contract::Event<&P, OperatorSlashed, N> {
            self.event_filter::<OperatorSlashed>()
        }
        ///Creates a new event filter for the [`OperatorStakeIncreased`] event.
        pub fn OperatorStakeIncreased_filter(
            &self,
        ) -> alloy_contract::Event<&P, OperatorStakeIncreased, N> {
            self.event_filter::<OperatorStakeIncreased>()
        }
        ///Creates a new event filter for the [`OperatorUnstakeExecuted`] event.
        pub fn OperatorUnstakeExecuted_filter(
            &self,
        ) -> alloy_contract::Event<&P, OperatorUnstakeExecuted, N> {
            self.event_filter::<OperatorUnstakeExecuted>()
        }
        ///Creates a new event filter for the [`OperatorUnstakeScheduled`] event.
        pub fn OperatorUnstakeScheduled_filter(
            &self,
        ) -> alloy_contract::Event<&P, OperatorUnstakeScheduled, N> {
            self.event_filter::<OperatorUnstakeScheduled>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<&P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`RequireAdaptersUpdated`] event.
        pub fn RequireAdaptersUpdated_filter(
            &self,
        ) -> alloy_contract::Event<&P, RequireAdaptersUpdated, N> {
            self.event_filter::<RequireAdaptersUpdated>()
        }
        ///Creates a new event filter for the [`RewardClaimed`] event.
        pub fn RewardClaimed_filter(
            &self,
        ) -> alloy_contract::Event<&P, RewardClaimed, N> {
            self.event_filter::<RewardClaimed>()
        }
        ///Creates a new event filter for the [`RewardDistributed`] event.
        pub fn RewardDistributed_filter(
            &self,
        ) -> alloy_contract::Event<&P, RewardDistributed, N> {
            self.event_filter::<RewardDistributed>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(&self) -> alloy_contract::Event<&P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(&self) -> alloy_contract::Event<&P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`RoundAdvanced`] event.
        pub fn RoundAdvanced_filter(
            &self,
        ) -> alloy_contract::Event<&P, RoundAdvanced, N> {
            self.event_filter::<RoundAdvanced>()
        }
        ///Creates a new event filter for the [`SlashRecorded`] event.
        pub fn SlashRecorded_filter(
            &self,
        ) -> alloy_contract::Event<&P, SlashRecorded, N> {
            self.event_filter::<SlashRecorded>()
        }
        ///Creates a new event filter for the [`Slashed`] event.
        pub fn Slashed_filter(&self) -> alloy_contract::Event<&P, Slashed, N> {
            self.event_filter::<Slashed>()
        }
        ///Creates a new event filter for the [`SlashedForService`] event.
        pub fn SlashedForService_filter(
            &self,
        ) -> alloy_contract::Event<&P, SlashedForService, N> {
            self.event_filter::<SlashedForService>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<&P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<&P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
        ///Creates a new event filter for the [`WithdrawScheduled`] event.
        pub fn WithdrawScheduled_filter(
            &self,
        ) -> alloy_contract::Event<&P, WithdrawScheduled, N> {
            self.event_filter::<WithdrawScheduled>()
        }
        ///Creates a new event filter for the [`Withdrawn`] event.
        pub fn Withdrawn_filter(&self) -> alloy_contract::Event<&P, Withdrawn, N> {
            self.event_filter::<Withdrawn>()
        }
    }
}
