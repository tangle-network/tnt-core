name: Generate Bytecode

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**/*.sol'
  pull_request:
    paths:
      - 'src/**/*.sol'
  workflow_dispatch:

jobs:
  generate-bytecode:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Update with Soldeer
        run: |
          forge soldeer update -d

      - name: Build contracts
        run: |
          forge build

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Generate Rust bytecode
        run: |
          # Create Python script to extract bytecode and generate Rust code
          cat > generate_bytecode.py << 'EOL'
          import json
          import os
          import re
          from pathlib import Path

          def to_screaming_snake_case(name):
              # First, handle camelCase and PascalCase by adding underscore before capitals
              s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
              s2 = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)
              # Convert to uppercase
              return s2.upper()

          contracts = [
              'MasterBlueprintServiceManager',
          ]

          rust_code = """\
          /// TNT Core contract bytecode exports
          /// 
          /// This module exports the bytecode of TNT Core contracts as constant byte vectors
          /// that can be easily imported and used in other Rust projects.

          pub mod bytecode {"""

          for contract in contracts:
              json_path = Path('out') / f"{contract}.sol" / f"{contract}.json"
              with open(json_path) as f:
                  contract_data = json.load(f)
              
              # Get bytecode, handling different possible formats
              bytecode = contract_data['bytecode'].get('object', contract_data['bytecode'])
              if bytecode.startswith('0x'):
                  bytecode = bytecode[2:]
              
              # Convert bytecode string to byte array
              bytes_array = [f"0x{bytecode[i:i+2]}" for i in range(0, len(bytecode), 2)]
              
              # Convert contract name to SCREAMING_SNAKE_CASE
              const_name = to_screaming_snake_case(contract)
              
              # Add constant to Rust code
              rust_code += f"""
                  /// Bytecode for the {contract} contract
                  pub const {const_name}: &[u8] = &[{', '.join(bytes_array)}];
              """

          rust_code += """
          }

          #[cfg(test)]
          mod tests {
              use super::*;

              #[test]
              fn verify_bytecode_not_empty() {
                  assert!(!bytecode::MASTER_BLUEPRINT_SERVICE_MANAGER.is_empty());
              }
          }"""

          with open('bytecode/src/lib.rs', 'w') as f:
              f.write(rust_code)
          EOL

          python3 generate_bytecode.py

      - name: Run tests
        run: |
          cd bytecode
          cargo test

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          commit-message: 'chore: update contract bytecode'
          title: 'Update Contract Bytecode'
          body: |
            This PR updates the Rust bytecode constants based on the latest Solidity contract builds.
            
            This is an automated PR created by the generate-bytecode workflow.
          branch: update-bytecode
          base: main
