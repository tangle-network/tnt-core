\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{titlesec}

\geometry{margin=1in}

\hypersetup{
    colorlinks=true,
    linkcolor=blue!70!black,
    urlcolor=blue!70!black,
    citecolor=blue!70!black,
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small Tangle Network Whitepaper}
\fancyhead[R]{\small\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

\title{\textbf{Tangle Network}\\[0.5em]\large The Operating Layer for Autonomous Work\\[1em]\normalsize Protocol Specification v1.0}
\author{Tangle Foundation}
\date{January 2025}

\begin{document}

\maketitle

\begin{abstract}
Tangle Network is a decentralized protocol for coordinating computational services with cryptoeconomic accountability. This document describes the protocol's architecture, economic mechanisms, and security model. Tangle enables developers to define service templates (blueprints), operators to provide compute with staked collateral, and customers to consume services with cryptographic guarantees. The protocol uses O(1) algorithms for staking, slashing, and reward distribution, enabling unlimited scalability. Economic security emerges from aligned incentives: operators stake assets that can be destroyed if they misbehave, making honest behavior more profitable than cheating.
\end{abstract}

\tableofcontents
\newpage

%==============================================================================
\section{Introduction}
%==============================================================================

The deployment of increasingly capable AI systems demands infrastructure that can scale with their requirements while maintaining accountability. Current infrastructure options---centralized cloud providers or fragmented decentralized alternatives---impose constraints that limit both innovation and access. Centralized systems concentrate power in few hands, creating single points of failure and extracting value from a position of control. Decentralized alternatives lack the coordination mechanisms necessary for production workloads.

Tangle addresses this gap by providing a protocol layer where computational services operate with cryptographic accountability and economic security. The protocol coordinates three participant types: developers who define service templates, operators who provide compute, and customers who consume services. Value flows through the system via service fees and inflation rewards, distributed according to contribution rather than position.

\subsection{The Infrastructure Question}

AI agents capable of autonomous action require infrastructure that matches their capabilities. An agent managing a portfolio needs compute that cannot be arbitrarily terminated. An agent processing sensitive data needs isolation guarantees beyond contractual promises. An agent making consequential decisions needs audit trails that cannot be falsified.

Traditional cloud infrastructure provides compute but not accountability. Terms of service change. Access can be revoked. Providers are few, and their market power grows as dependence deepens. For infrastructure underpinning significant economic activity, this concentration creates systemic risk.

Tangle provides an alternative where accountability is cryptographic rather than contractual. Operators stake assets that can be destroyed if they violate service terms. Customers pay for services with cryptographic proof of delivery. The protocol coordinates without controlling, enabling a competitive market of independent operators rather than dependence on a few large providers.

\subsection{Design Philosophy}

Seven principles guide Tangle's design.

\textbf{Democratized Ownership.} The value generated by AI infrastructure should accrue broadly, not concentrate in platform owners. Operators, developers, delegators, and users all capture value proportional to their contributions.

\textbf{Permissionless Participation.} Anyone can become an operator by staking the minimum bond. Anyone can deploy a blueprint. Anyone can use services. No committee approves applications. No foundation decides who may participate.

\textbf{Developer Expressiveness.} The protocol provides primitives that developers compose into applications. Blueprints define pricing models, membership rules, slashing conditions, and verification mechanisms through hooks.

\textbf{Economic Security.} Trust emerges from aligned incentives. Operators deposit assets that can be destroyed if they misbehave. The cost of cheating exceeds any benefit from cheating.

\textbf{Scalable Efficiency.} O(1) algorithms handle unlimited participants without iteration. Share-based accounting tracks delegation through exchange rates. Accumulated-per-share rewards distribute income through single accumulators.

\textbf{Isolation by Default.} AI agents execute in sandboxes with explicit permissions. Containers separate processes. Resource limits prevent exhaustion attacks.

\textbf{Navigating Tensions.} When principles conflict, mechanism design finds balance. Permissionless participation combined with market selection allows anyone to enter while quality emerges through competition.

%==============================================================================
\section{Blueprints and Services}
%==============================================================================

The blueprint system forms the foundation of Tangle's service architecture. Blueprints define what services do; services are running instances with assigned operators.

\subsection{What Is a Blueprint?}

A blueprint is a reusable template defining a service type. Developers create blueprints to specify computational tasks, pricing models, operator requirements, and optionally custom logic through hooks.

Formally, a blueprint comprises:
\begin{itemize}[noitemsep]
    \item Metadata for discovery (name, description, author)
    \item Configuration for pricing and membership
    \item Job definitions specifying tasks operators execute
    \item Validation schemas ensuring well-formed requests
    \item Optional custom service manager implementing hooks
\end{itemize}

Blueprints are identified by unique numeric IDs assigned at creation. Once an operator registers, the protocol locks blueprint metadata, preventing developers from modifying terms after operators have committed.

\subsection{What Is a Service Instance?}

A service is a running instance of a blueprint with assigned operators. Where blueprints define what a service type does, service instances represent actual deployments.

A service comprises:
\begin{itemize}[noitemsep]
    \item Reference to its blueprint
    \item Set of participating operators with committed exposures
    \item Configuration parameters validated against the schema
    \item Time-to-live (TTL) defining service duration
    \item Payment configuration specifying token and amount
\end{itemize}

Services move through defined states: pending (awaiting operator approvals), active (operational), and terminated (completed lifecycle).

\subsection{Service Lifecycle}

The lifecycle proceeds through request, approval, activation, operation, and termination.

A customer initiates by submitting a request specifying the blueprint, desired operators, configuration, payment, TTL, permitted callers, and security requirements. The protocol validates parameters and notifies operators.

Each operator must respond. Approval requires committing an exposure (fraction of stake backing the service). If any operator rejects, the service fails. When all approve, the service activates.

Upon activation, operators provide the service. Customers submit jobs; operators execute and submit results. The payment system distributes funds according to the configured model.

Services terminate through customer request, TTL expiration, or failure to maintain minimum operator count. Remaining escrow refunds to the customer.

\subsection{Pricing Models}

Three pricing models accommodate different service types:

\textbf{Pay-once} collects a single upfront payment, distributed when operators approve. This suits one-time computations.

\textbf{Subscription} collects recurring payments from customer-funded escrow. This suits ongoing services.

\textbf{Event-driven} collects payment per job execution. This suits variable workloads.

\subsection{Membership Models}

\textbf{Fixed membership} locks the operator set at service creation. Operators cannot join or leave once activated.

\textbf{Dynamic membership} permits operators to join after activation and leave subject to exit queue constraints. This enables long-running services to adapt.

%==============================================================================
\section{Operators and Staking}
%==============================================================================

Operators are staked entities that run services and earn rewards. The staking system provides economic security backing service guarantees.

\subsection{Operator Registration}

An entity becomes an operator by depositing a bond meeting minimum stake requirements. Registration creates metadata tracking self-stake, delegation count, and status.

Operators then register for specific blueprints, providing an ECDSA public key for gossip identity and an RPC endpoint for communication. The protocol validates that the blueprint is active, minimum stakes are met, and schema validation passes.

\subsection{Delegation Modes}

Operators configure delegation mode:
\begin{itemize}[noitemsep]
    \item \textbf{Disabled}: Only self-stake accepted
    \item \textbf{Whitelist}: Only approved addresses may delegate
    \item \textbf{Open}: Any address may delegate
\end{itemize}

\subsection{Exposure Selection}

When operators approve service requests, they commit an exposure in basis points (0-10000). This determines what fraction of stake backs the service.

Exposure has two consequences: it determines reward share (higher exposure = more rewards) and bounds slashing (operators lose at most their committed percentage).

This design enables participation in multiple services with bounded total risk.

\subsection{O(1) Share-Based Accounting}

The staking system uses share-based accounting for O(1) operations. Each operator maintains a reward pool tracking total shares and total assets.

When delegating amount $x$ to a pool with state $(T_s, T_a)$, the delegator receives shares:
\[
h = x \cdot \frac{T_s + V}{T_a + V}
\]
where $V$ is a virtual offset preventing first-depositor attacks.

The delegation's value is $v = h \cdot (T_a / T_s)$. When assets change through rewards or slashing, this value changes proportionally without per-delegator updates.

When slashing occurs, only total assets decrease. Shares remain constant. The exchange rate decreases, affecting all delegators proportionally. No iteration is required.

%==============================================================================
\section{The Service Marketplace}
%==============================================================================

The service marketplace bridges supply (operators) with demand (customers) through request-for-quote pricing.

\subsection{Why Request-for-Quote}

Service pricing mechanisms face design choices. Fixed pricing cannot adapt to changing costs. Order books work poorly for heterogeneous services. AMMs struggle with operator differentiation.

Request-for-quote asks operators to provide binding prices for specific requests. Customers collect quotes, evaluate holistically, and select. RFQ accommodates operator heterogeneity naturally, requires no on-chain state, and provides instant finality.

\subsection{The RFQ Flow}

Operators register with ECDSA keys and RPC endpoints. They run software that listens for quote requests and returns signed quotes containing:
\begin{itemize}[noitemsep]
    \item Blueprint ID and service duration (TTL)
    \item Total cost and payment token
    \item Timestamp and expiry
    \item Security commitments (exposure per asset)
\end{itemize}

Customers collect quotes, verify terms, and submit all quotes in a single transaction. The protocol verifies signatures, checks expiry and replay protection, validates registrations, and confirms payment.

\subsection{Quote Security}

EIP-712 signatures bind quotes to specific chains and contracts. Each quote includes a unique timestamp; the protocol tracks used quotes. Quotes expire after their specified time. Maximum quote age (default one hour) ensures quotes reflect current conditions.

\subsection{MEV Considerations}

Quote sniping fails because quotes specify security commitments only registered operators can provide. Price manipulation is mitigated by competition. Sandwich attacks have limited applicability since RFQ transactions do not interact with liquidity pools.

%==============================================================================
\section{Fee Distribution and Rewards}
%==============================================================================

Value flows through Tangle via service fees and inflation rewards.

\subsection{Service Fee Splits}

When customers pay, the payment splits across recipients. Default allocation:
\begin{center}
\begin{tabular}{lr}
\toprule
Recipient & Share \\
\midrule
Developer & 20\% \\
Protocol Treasury & 20\% \\
Operators & 40\% \\
Delegators & 20\% \\
\bottomrule
\end{tabular}
\end{center}

These percentages are governance-controlled. The delegator share captures rounding dust.

\subsection{Operator Revenue}

The operator allocation distributes weighted by committed exposure:
\[
\text{operatorShare}_i = \frac{\text{operatorAmount} \times e_i}{\sum_j e_j}
\]

Operators who commit more stake earn more from that service.

\subsection{Delegator Rewards}

Lock duration multipliers reward longer commitments:
\begin{center}
\begin{tabular}{ll}
\toprule
Lock Duration & Multiplier \\
\midrule
None & 1.0x \\
One Month & 1.1x \\
Two Months & 1.2x \\
Three Months & 1.3x \\
Six Months & 1.6x \\
\bottomrule
\end{tabular}
\end{center}

A delegator's score is amount $\times$ multiplier. Rewards distribute proportionally using accumulated-per-share accounting for O(1) efficiency.

\subsection{Developer Rewards}

Developers earn from service fees and inflation rewards through scoring:
\begin{align*}
\text{blueprintScore} &= \text{blueprintCount} \times 500 \\
\text{serviceScore} &= \text{serviceCount} \times 1000 \\
\text{jobScore} &= \text{jobCount} \times 100 \\
\text{feeScore} &= \sqrt{\text{totalFees} / 10^{18}} \times 10^9
\end{align*}

The square root on fees prevents whale dominance.

%==============================================================================
\section{Inflation and Epoch Distribution}
%==============================================================================

Inflation rewards provide income while service demand develops, encouraging early participation.

\subsection{The Pre-Funded Model}

The InflationPool uses a pre-funded model. The pool cannot mint tokens; it distributes tokens it holds. Governance funds the pool with yearly allocations.

Each epoch's budget:
\[
\text{epochBudget} = \frac{\text{poolBalance}}{\text{epochsRemaining}}
\]

This smooths distribution over the funding period.

\subsection{Distribution Weights}

Default allocation:
\begin{center}
\begin{tabular}{lr}
\toprule
Category & Weight \\
\midrule
Stakers (delegators) & 40\% \\
Operators (performance) & 25\% \\
Developers (merit) & 25\% \\
Customers (usage) & 10\% \\
\bottomrule
\end{tabular}
\end{center}

Governance can adjust weights to steer network growth.

\subsection{Operator Scoring}

Operator inflation rewards use performance metrics:
\begin{align*}
\text{successRate} &= \frac{\text{successfulJobs} \times 10000}{\text{totalJobs}} \\
\text{stakeWeight} &= \frac{\text{totalStake}}{10^9} \\
\text{jobScore} &= \frac{\text{jobs} \times \text{successRate} \times \text{stakeWeight}}{10000}
\end{align*}

Stake weight is linear to defeat Sybil attacks.

%==============================================================================
\section{Slashing and Accountability}
%==============================================================================

Slashing provides consequences for misbehavior, making economic security meaningful.

\subsection{Developer-Defined Conditions}

The protocol provides slashing mechanism; developers define when to use it. Each service type has different requirements the protocol cannot anticipate.

Developers implement conditions through hooks: \texttt{querySlashingOrigin} specifies who may propose slashes; \texttt{onSlash} executes when slashing finalizes.

\subsection{The Dispute Window}

Slash proposals do not execute immediately. A dispute window (default 7 days) provides operators opportunity to contest.

The lifecycle:
\begin{enumerate}[noitemsep]
    \item \textbf{Proposal}: Evidence submitted, pending proposal created
    \item \textbf{Dispute}: Operator may submit counter-evidence; administrators may cancel
    \item \textbf{Execution}: After window expires, any address may execute undisputed slashes
\end{enumerate}

\subsection{Proportional Slashing}

Slashing is proportional to committed exposure:
\[
\text{effectiveSlashBps} = \frac{\text{slashBps} \times \text{exposureBps}}{10000}
\]

An operator with 10\% exposure faces at most 10\% of stake at risk.

\subsection{Withdrawal Protection}

Pending slashes block withdrawals. Delegators cannot withdraw while slashes are pending against their operator.

%==============================================================================
\section{Governance}
%==============================================================================

Token holders control protocol evolution through on-chain governance.

\subsection{Governance Philosophy}

Tangle prioritizes \textbf{safety over liveness}. Proposals that fail do less damage than malicious proposals that pass. Thresholds are high, quorum requirements ensure participation, and timelocks provide escape hatches.

\textbf{Stake-weighted voting} gives those with more at stake more say. This reflects that economic exposure confers governance rights.

\subsection{Governance Mechanism}

On-chain governance uses OpenZeppelin Governor with ERC20Votes:

\begin{center}
\begin{tabular}{ll}
\toprule
Parameter & Default \\
\midrule
Proposal threshold & 1\% of supply \\
Voting delay & 2 days \\
Voting period & 7 days \\
Quorum & 10\% of supply \\
Timelock & 3 days (7 for upgrades) \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Attack Resistance}

\textbf{Governance capture}: High thresholds, long voting periods, and timelocks enable defensive mobilization.

\textbf{Flash loan attacks}: Vote checkpointing determines power at snapshot, not current holdings.

\textbf{Voter apathy}: Quorum requirements and delegation provide defense.

\subsection{Vote Delegation}

Token holders may delegate voting power. Delegation enables passive holders to participate through trusted representatives.

\subsection{Emergency Mechanisms}

\textbf{Pause functionality} allows PAUSER\_ROLE to halt operations.

\textbf{Emergency withdrawal} enables DEFAULT\_ADMIN\_ROLE to withdraw funds to safety.

\textbf{Guardian multisig} may hold emergency roles during early protocol period.

\subsection{Upgrade Mechanism}

Contract upgrades use UUPS pattern. Upgrades follow standard governance with the longest timelock (7 days).

%==============================================================================
\section{Security Model}
%==============================================================================

\subsection{Threat Model}

Three adversary classes:

\textbf{Rational adversaries} attack if expected value exceeds expected cost. Defense is economic: ensure slashing cost exceeds potential gain.

\textbf{Byzantine adversaries} may behave irrationally. Defense bounds damage through stake requirements, exposure limits, and dispute windows.

\textbf{Colluding adversaries} coordinate to overcome individual defenses. Defense requires structural mechanisms: randomized selection, stake distribution requirements.

\subsection{Economic Security Analysis}

The \textbf{cost of corruption} (CoC) is the minimum stake an adversary must control to corrupt a service.

The \textbf{profit from corruption} (PfC) is the maximum value extractable.

The \textbf{security ratio} is CoC/PfC. Ratios above 1 make honest behavior more profitable under perfect detection. We recommend minimum ratios of 1.5x, with 2x+ for high-value services.

\subsection{Formal Security Properties}

\textbf{Withdrawal Safety}: Operators with pending slashes cannot reduce stake below slash amount.

\textbf{Proportional Slashing}: When $x$\% slash executes, all delegators lose exactly $x$\% of delegation value.

\textbf{Dust Conservation}: Payment splits distribute exactly the input amount.

\textbf{Temporal Separation}: Stake cannot participate in services until locked for \texttt{minStakeEpochs}.

\textbf{Bounded Governance}: Proposals cannot execute until timelock elapses.

\subsection{Security Recommendations}

\begin{enumerate}[noitemsep]
    \item Size stake requirements to exceed maximum corruption profit
    \item Implement detection mechanisms appropriate to threat model
    \item Use multi-operator services for high-value applications
    \item Monitor economic conditions and pause if security margins decline
    \item Participate actively in governance
\end{enumerate}

%==============================================================================
\section{Comparison to Existing Protocols}
%==============================================================================

\subsection{The Restaking Landscape}

Restaking protocols share a premise: staked assets can secure additional systems beyond their primary use.

\textbf{EigenLayer} enables ETH stakers to opt into additional slashing for yield.

\textbf{Symbiotic} accepts diverse collateral with modular design.

\textbf{Karak} uses risk-adjusted collateral matching.

\subsection{Differentiating Tangle}

\textbf{Compute focus}: Tangle focuses on compute services (AI inference, data processing), not just validation tasks.

\textbf{Developer-defined services}: Blueprints enable new service types through configuration, not protocol modification.

\textbf{Integrated products}: Tangle combines infrastructure with products that demonstrate and utilize it.

\textbf{O(1) algorithms}: Fundamental design choice enabling unlimited scalability.

\textbf{RFQ marketplace}: Accommodates heterogeneous services naturally.

%==============================================================================
\section{Conclusion}
%==============================================================================

Tangle provides the coordination layer for a decentralized compute economy. The protocol enables developers to define computational services, operators to provide those services with economic accountability, and customers to consume services with cryptographic guarantees.

The mechanisms described---blueprints and services, staking and delegation, the service marketplace, fee distribution, slashing, and governance---compose into a coherent system where honest participation is more profitable than cheating, where value distributes according to contribution, and where no single party controls the infrastructure on which others depend.

This is not merely an ideological position but a practical one. Decentralized infrastructure is more resilient, competitive markets produce better pricing, and cryptographic verification provides stronger guarantees than legal agreements. The same properties that made decentralized finance compelling make decentralized AI infrastructure compelling.

The operating layer for autonomous work must be built now. Tangle is that layer.

\end{document}
